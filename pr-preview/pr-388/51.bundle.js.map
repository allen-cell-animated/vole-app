{"version":3,"file":"51.bundle.js","mappings":"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","sources":["webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/Histogram.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/VolumeDims.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/ImageInfo.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/loaders/zarr_utils/ChunkPrefetchIterator.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/loaders/zarr_utils/WrappedStore.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/loaders/zarr_utils/utils.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/loaders/zarr_utils/validation.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/utils/RequestQueue.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/utils/SubscribableRequestQueue.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/workers/types.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/workers/util.js","webpack://@aics/vole-app/./node_modules/@zarrita/core/dist/src/codecs/transpose.js","webpack://@aics/vole-app/./node_modules/@zarrita/core/dist/src/codecs/endian.js","webpack://@aics/vole-app/./node_modules/@zarrita/core/dist/src/codecs/crc32c.js","webpack://@aics/vole-app/./node_modules/@zarrita/core/dist/src/codecs/vlen-utf8.js","webpack://@aics/vole-app/./node_modules/@zarrita/core/dist/src/codecs.js","webpack://@aics/vole-app/./node_modules/@zarrita/core/dist/src/codecs/sharding.js","webpack://@aics/vole-app/./node_modules/@zarrita/core/dist/src/hierarchy.js","webpack://@aics/vole-app/./node_modules/@zarrita/core/dist/src/open.js","webpack://@aics/vole-app/./node_modules/@zarrita/core/dist/src/util.js","webpack://@aics/vole-app/./node_modules/@zarrita/indexing/dist/src/indexer.js","webpack://@aics/vole-app/./node_modules/@zarrita/indexing/dist/src/ops.js","webpack://@aics/vole-app/./node_modules/@zarrita/indexing/dist/src/get.js","webpack://@aics/vole-app/./node_modules/@zarrita/indexing/dist/src/util.js","webpack://@aics/vole-app/./node_modules/@zarrita/storage/dist/src/util.js","webpack://@aics/vole-app/./node_modules/@zarrita/storage/dist/src/fetch.js","webpack://@aics/vole-app/./node_modules/@zarrita/typedarray/index.js"],"sourcesContent":["const NBINS = 256;\n/**\n * Builds a histogram with 256 bins from a data array. Assume data is 8 bit single channel grayscale.\n * @class\n * @param {Array.<number>} data\n */\nexport default class Histogram {\n  // no more than 2^32 pixels of any one intensity in the data!?!?!\n\n  /** Min value in the original raw data. */\n\n  /** Max value in the original raw data. */\n\n  /** Size of each histogram bin in the scale of the original data. */\n\n  /** Index of the first bin (other than 0) with at least 1 value. */\n\n  /** Index of the last bin (other than 0) with at least 1 value. */\n\n  constructor(data) {\n    this.dataMinBin = 0;\n    this.dataMaxBin = 0;\n    this.maxBin = 0;\n    this.bins = new Uint32Array();\n    this.min = 0;\n    this.max = 0;\n    this.binSize = 0;\n\n    // build up the histogram\n    const hinfo = Histogram.calculateHistogram(data, NBINS);\n    this.bins = hinfo.bins;\n    this.min = hinfo.min;\n    this.max = hinfo.max;\n    this.binSize = hinfo.binSize;\n\n    // TODO: These should always return 0 and NBINS - 1, respectively. Test if these\n    // can be removed.\n    for (let i = 0; i < this.bins.length; i++) {\n      if (this.bins[i] > 0) {\n        this.dataMinBin = i;\n        break;\n      }\n    }\n    for (let i = this.bins.length - 1; i >= 0; i--) {\n      if (this.bins[i] > 0) {\n        this.dataMaxBin = i;\n        break;\n      }\n    }\n    this.pixelCount = data.length;\n\n    // get the bin with the most frequently occurring NONZERO value\n    this.maxBin = 1;\n    let max = this.bins[1];\n    for (let i = 1; i < this.bins.length; i++) {\n      if (this.bins[i] > max) {\n        this.maxBin = i;\n        max = this.bins[i];\n      }\n    }\n  }\n\n  // return the bin index of the given data value\n  static findBin(dataValue, dataMin, binSize, numBins) {\n    let binIndex = Math.floor((dataValue - dataMin) / binSize);\n    // for values that lie exactly on last bin we need to subtract one\n    if (binIndex === numBins) {\n      binIndex--;\n    }\n    return binIndex;\n  }\n\n  // return the bin index of the given data value\n  findBinOfValue(value) {\n    return Histogram.findBin(value, this.min, this.binSize, NBINS);\n  }\n\n  /**\n   * Return the min data value\n   * @return {number}\n   */\n  getDataMin() {\n    return this.min;\n  }\n\n  /**\n   * Return the max data value\n   * @return {number}\n   */\n  getDataMax() {\n    return this.max;\n  }\n\n  /**\n   * Returns the first bin index with at least 1 value, other than the 0th bin.\n   * @return {number}\n   */\n  getMin() {\n    return this.dataMinBin;\n  }\n\n  /**\n   * Returns the last bin index with at least 1 value, other than the 0th bin.\n   * @return {number}\n   */\n  getMax() {\n    // Note that this will always return `NBINS - 1`.\n    return this.dataMaxBin;\n  }\n  getNumBins() {\n    return this.bins.length;\n  }\n  getBin(i) {\n    return this.bins[i];\n  }\n  getBinRange(i) {\n    return [this.min + i * this.binSize, this.min + (i + 1) * this.binSize];\n  }\n\n  /**\n   * Find the bin that contains the percentage of pixels below it\n   * @return {number}\n   * @param {number} pct\n   */\n  findBinOfPercentile(pct) {\n    const limit = this.pixelCount * pct;\n    let i = 0;\n    let count = 0;\n    for (i = 0; i < this.bins.length; ++i) {\n      count += this.bins[i];\n      if (count > limit) {\n        break;\n      }\n    }\n    return i;\n  }\n\n  // Find bins at 10th / 90th percentile\n  findBestFitBins() {\n    const pixcount = this.pixelCount;\n    //const pixcount = this.imgData.data.length;\n    const limit = pixcount / 10;\n    let i = 0;\n    let count = 0;\n    for (i = 1; i < this.bins.length; ++i) {\n      count += this.bins[i];\n      if (count > limit) {\n        break;\n      }\n    }\n    const hmin = i;\n    count = 0;\n    for (i = this.bins.length - 1; i >= 1; --i) {\n      count += this.bins[i];\n      if (count > limit) {\n        break;\n      }\n    }\n    const hmax = i;\n    return [hmin, hmax];\n  }\n\n  // Find min and max bins attempting to replicate ImageJ's \"Auto\" button\n  findAutoIJBins() {\n    // note that consecutive applications of this should modify the auto threshold. see:\n    // https://github.com/imagej/ImageJ/blob/7746fcb0f5744a7a7758244c5dcd2193459e6e0e/ij/plugin/frame/ContrastAdjuster.java#L816\n    const AUTO_THRESHOLD = 5000;\n    const pixcount = this.pixelCount;\n    //  const pixcount = this.imgData.data.length;\n    const limit = pixcount / 10;\n    const threshold = pixcount / AUTO_THRESHOLD;\n\n    // this will skip the \"zero\" bin which contains pixels of zero intensity.\n    let hmin = this.bins.length - 1;\n    let hmax = 1;\n    for (let i = 1; i < this.bins.length; ++i) {\n      if (this.bins[i] > threshold && this.bins[i] <= limit) {\n        hmin = i;\n        break;\n      }\n    }\n    for (let i = this.bins.length - 1; i >= 1; --i) {\n      if (this.bins[i] > threshold && this.bins[i] <= limit) {\n        hmax = i;\n        break;\n      }\n    }\n    if (hmax < hmin) {\n      hmin = 0;\n      hmax = 255;\n    }\n    return [hmin, hmax];\n  }\n\n  // Find min and max bins using a percentile of the most commonly occurring value\n  findAutoMinMax() {\n    // simple linear mapping cutting elements with small appearence\n    // get 10% threshold\n    const PERCENTAGE = 0.1;\n    const th = Math.floor(this.bins[this.maxBin] * PERCENTAGE);\n    let b = 0;\n    let e = this.bins.length - 1;\n    for (let x = 1; x < this.bins.length; ++x) {\n      if (this.bins[x] > th) {\n        b = x;\n        break;\n      }\n    }\n    for (let x = this.bins.length - 1; x >= 1; --x) {\n      if (this.bins[x] > th) {\n        e = x;\n        break;\n      }\n    }\n    return [b, e];\n  }\n  static calculateHistogram(arr, numBins = 1) {\n    if (numBins < 1) {\n      numBins = 1;\n    }\n\n    // calculate min and max of arr\n    // TODO See convertChannel, which will also compute min and max!\n    // We could save a whole extra loop over the data, or have convertChannel compute the whole histogram.\n    // need to be careful about computing over chunks or whole ready-to-display volume\n\n    let min = arr[0];\n    let max = arr[0];\n    for (let i = 1; i < arr.length; i++) {\n      if (arr[i] < min) {\n        min = arr[i];\n      } else if (arr[i] > max) {\n        max = arr[i];\n      }\n    }\n    const bins = new Uint32Array(numBins).fill(0);\n    const binSize = (max - min) / numBins === 0 ? 1 : (max - min) / numBins;\n    for (let i = 0; i < arr.length; i++) {\n      const item = arr[i];\n      const binIndex = Histogram.findBin(item, min, binSize, numBins);\n      bins[binIndex]++;\n    }\n    return {\n      bins,\n      min,\n      max,\n      binSize\n    };\n  }\n}","import { Vector3 } from \"three\";\nexport function defaultVolumeDims() {\n  return {\n    shape: [0, 0, 0, 0, 0],\n    spacing: [1, 1, 1, 1, 1],\n    spaceUnit: \"m\",\n    timeUnit: \"s\",\n    dataType: \"uint8\"\n  };\n}\nexport function volumeSize(volumeDims) {\n  return new Vector3(volumeDims.shape[4], volumeDims.shape[3], volumeDims.shape[2]);\n}\nexport function physicalPixelSize(volumeDims) {\n  return new Vector3(volumeDims.spacing[4], volumeDims.spacing[3], volumeDims.spacing[2]);\n}","import { volumeSize, physicalPixelSize } from \"./VolumeDims.js\";\nimport { Vector3, Vector2 } from \"three\";\nexport function defaultImageInfo() {\n  return {\n    name: \"\",\n    atlasTileDims: [1, 1],\n    subregionSize: [1, 1, 1],\n    subregionOffset: [0, 0, 0],\n    combinedNumChannels: 1,\n    channelNames: [\"0\"],\n    channelColors: [[255, 255, 255]],\n    multiscaleLevel: 0,\n    multiscaleLevelDims: [{\n      shape: [1, 1, 1, 1, 1],\n      spacing: [1, 1, 1, 1, 1],\n      spaceUnit: \"\",\n      timeUnit: \"\",\n      dataType: \"uint8\"\n    }],\n    transform: {\n      translation: [0, 0, 0],\n      rotation: [0, 0, 0],\n      scale: [1, 1, 1]\n    }\n  };\n}\nexport class CImageInfo {\n  constructor(imageInfo) {\n    this.imageInfo = imageInfo || defaultImageInfo();\n  }\n  get currentLevelDims() {\n    return this.imageInfo.multiscaleLevelDims[this.imageInfo.multiscaleLevel];\n  }\n\n  /** Number of channels in the image */\n  get numChannels() {\n    return this.imageInfo.combinedNumChannels;\n  }\n\n  /** XYZ size of the *original* (not downsampled) volume, in pixels */\n  get originalSize() {\n    return volumeSize(this.imageInfo.multiscaleLevelDims[0]);\n  }\n\n  /** Size of the volume, in pixels */\n  get volumeSize() {\n    return volumeSize(this.currentLevelDims);\n  }\n\n  /** Size of a single *original* (not downsampled) pixel, in spatial units */\n  get physicalPixelSize() {\n    return physicalPixelSize(this.imageInfo.multiscaleLevelDims[0]);\n  }\n\n  /** Symbol of physical spatial unit used by `physicalPixelSize` */\n  get spatialUnit() {\n    return this.imageInfo.multiscaleLevelDims[0].spaceUnit;\n  }\n\n  /** Number of timesteps in the time series, or 1 if the image is not a time series */\n  get times() {\n    // 0 is T\n    return this.currentLevelDims.shape[0];\n  }\n\n  /** Size of each timestep in temporal units */\n  get timeScale() {\n    // 0 is T\n    return this.currentLevelDims.spacing[0];\n  }\n\n  /** Symbol of physical time unit used by `timeScale` */\n  get timeUnit() {\n    return this.currentLevelDims.timeUnit;\n  }\n\n  /** Number of scale levels available for this volume */\n  get numMultiscaleLevels() {\n    return this.imageInfo.multiscaleLevelDims.length;\n  }\n\n  /** The names of each channel */\n  get channelNames() {\n    return this.imageInfo.channelNames;\n  }\n\n  /** Optional overrides to default channel colors, in 0-255 range */\n  get channelColors() {\n    return this.imageInfo.channelColors;\n  }\n\n  /** Size of the currently loaded subregion, in pixels */\n  get subregionSize() {\n    return new Vector3(...this.imageInfo.subregionSize);\n  }\n\n  /** Offset of the loaded subregion into the total volume, in pixels */\n  get subregionOffset() {\n    return new Vector3(...this.imageInfo.subregionOffset);\n  }\n  get multiscaleLevel() {\n    return this.imageInfo.multiscaleLevel;\n  }\n\n  /**\n   * XY dimensions of the texture atlas used by `RayMarchedAtlasVolume` and `Atlas2DSlice`, in number of z-slice\n   * tiles (not pixels). Chosen by the loader to lay out the 3D volume in the squarest possible 2D texture atlas.\n   */\n  get atlasTileDims() {\n    return new Vector2(...this.imageInfo.atlasTileDims);\n  }\n  get transform() {\n    return {\n      translation: new Vector3(...this.imageInfo.transform.translation),\n      rotation: new Vector3(...this.imageInfo.transform.rotation),\n      scale: new Vector3(...this.imageInfo.transform.scale)\n    };\n  }\n}\nexport function computeAtlasSize(imageInfo) {\n  const {\n    atlasTileDims\n  } = imageInfo;\n  const volDims = imageInfo.multiscaleLevelDims[imageInfo.multiscaleLevel];\n  // TCZYX: 4 = x, 3 = y\n  return [atlasTileDims[0] * volDims.shape[4], atlasTileDims[1] * volDims.shape[3]];\n}","const allEqual = arr => arr.every(v => v === arr[0]);\nconst pushN = (arr, val, n) => {\n  for (let i = 0; i < n; i++) {\n    arr.push(val);\n  }\n};\nconst directionToIndex = dir => {\n  const absDir = dir >> 1; // shave off sign bit to get index in TZYX\n  return absDir + Number(absDir !== 0); // convert TZYX -> TCZYX by skipping c (index 1)\n};\nfunction updateMinMax(val, minmax) {\n  if (val < minmax[0]) {\n    minmax[0] = val;\n  }\n  if (val > minmax[1]) {\n    minmax[1] = val;\n  }\n}\n\n/**\n * Since the user is most likely to want nearby data (in space or time) first, we should prefetch those chunks first.\n *\n * Given a list of just-loaded chunks and some bounds, `ChunkPrefetchIterator` iterates evenly outwards in T/Z/Y/X.\n */\n// NOTE: Assumes `chunks` form a rectangular prism! Will create gaps otherwise! (in practice they always should)\nexport default class ChunkPrefetchIterator {\n  constructor(chunks, tzyxMaxPrefetchOffset, tczyxChunksPerSource, priorityDirections, onlyPriorityDirections = false) {\n    // Get min and max chunk coordinates for T/Z/Y/X\n    const extrema = [[Infinity, -Infinity], [Infinity, -Infinity], [Infinity, -Infinity], [Infinity, -Infinity]];\n    for (const chunk of chunks) {\n      updateMinMax(chunk[0], extrema[0]);\n      updateMinMax(chunk[2], extrema[1]);\n      updateMinMax(chunk[3], extrema[2]);\n      updateMinMax(chunk[4], extrema[3]);\n    }\n\n    // Create `PrefetchDirectionState`s for each direction\n    this.directionStates = [];\n    this.priorityDirectionStates = [];\n\n    // iterating like this: direction is the index in the flattened entries\n    // and corresponds to our +T, -T, +Z, -Z, +Y, -Y, +X, -X directions in order\n    // because extrema is in TZYX order.\n    for (const [direction, start] of extrema.flat().entries()) {\n      const dimension = direction >> 1; // shave off sign bit to get index in TZYX\n      const tczyxIndex = dimension + Number(dimension !== 0); // convert TZYX -> TCZYX by skipping c (index 1)\n      let end;\n      if (direction & 1) {\n        // Positive direction - end is either the max coordinate in the fetched set plus the max offset in this\n        // dimension, or the max chunk coordinate in this dimension, whichever comes first\n        const endsPerSource = tczyxChunksPerSource.map(chunkDims => {\n          return Math.min(start + tzyxMaxPrefetchOffset[dimension], chunkDims[tczyxIndex] - 1);\n        });\n\n        // Save some time: if all sources have the same end, we can just store that\n        if (allEqual(endsPerSource)) {\n          end = endsPerSource[0];\n        } else {\n          // Otherwise, expand our ends per source array to ends per channel\n          end = [];\n          for (const [i, sourceEnd] of endsPerSource.entries()) {\n            pushN(end, sourceEnd, tczyxChunksPerSource[i][1]);\n          }\n        }\n        // end = Math.min(start + tzyxMaxPrefetchOffset[dimension], tczyxChunksPerDimension[dimension] - 1);\n      } else {\n        // Negative direction - end is either the min coordinate in the fetched set minus the max offset in this\n        // dimension, or 0, whichever comes first\n        end = Math.max(start - tzyxMaxPrefetchOffset[dimension], 0);\n      }\n      const directionState = {\n        direction,\n        start,\n        end,\n        chunks: []\n      };\n      if (priorityDirections && priorityDirections.includes(direction)) {\n        this.priorityDirectionStates.push(directionState);\n      } else {\n        // we have an option setting that can let us ignore non-priority directions\n        if (!onlyPriorityDirections) {\n          this.directionStates.push(directionState);\n        }\n      }\n    }\n\n    // Fill each `PrefetchDirectionState` with chunks at the border of the fetched set\n    for (const chunk of chunks) {\n      for (const dir of this.directionStates) {\n        if (chunk[directionToIndex(dir.direction)] === dir.start) {\n          dir.chunks.push(chunk);\n        }\n      }\n      for (const dir of this.priorityDirectionStates) {\n        if (chunk[directionToIndex(dir.direction)] === dir.start) {\n          dir.chunks.push(chunk);\n        }\n      }\n    }\n  }\n  static *iterateDirections(directions) {\n    let offset = 1;\n    while (directions.length > 0) {\n      // Remove directions in which we have reached the end (or, if per-channel ends, the end for all channels)\n      directions = directions.filter(dir => {\n        const end = Array.isArray(dir.end) ? Math.max(...dir.end) : dir.end;\n        if (dir.direction & 1) {\n          return dir.start + offset <= end;\n        } else {\n          return dir.start - offset >= end;\n        }\n      });\n\n      // Yield chunks one chunk farther out in every remaining direction\n      for (const dir of directions) {\n        const offsetDir = offset * (dir.direction & 1 ? 1 : -1);\n        for (const chunk of dir.chunks) {\n          // Skip this chunk if this channel has a specific per-channel end and we've reached it\n          if (Array.isArray(dir.end) && chunk[directionToIndex(dir.direction)] + offsetDir > dir.end[chunk[1]]) {\n            continue;\n          }\n          const newChunk = chunk.slice();\n          newChunk[directionToIndex(dir.direction)] += offsetDir;\n          yield newChunk;\n        }\n      }\n      offset += 1;\n    }\n  }\n  *[Symbol.iterator]() {\n    // Yield all chunks in priority direction(s) first, if any\n    if (this.priorityDirectionStates.length > 0) {\n      for (const chunk of ChunkPrefetchIterator.iterateDirections(this.priorityDirectionStates)) {\n        yield chunk;\n      }\n    }\n\n    // Then yield all chunks in other directions\n    for (const chunk of ChunkPrefetchIterator.iterateDirections(this.directionStates)) {\n      yield chunk;\n    }\n  }\n}","/**\n * `Readable` is zarrita's minimal abstraction for any source of data.\n * `WrappedStore` wraps another `Readable` and adds (optional) connections to `VolumeCache` and `RequestQueue`.\n */\nclass WrappedStore {\n  constructor(baseStore, cache, queue) {\n    this.baseStore = baseStore;\n    this.cache = cache;\n    this.queue = queue;\n  }\n  // Dummy implementation to make this class easier to use in tests\n  set(_key, _value) {\n    return Promise.resolve();\n  }\n  async getAndCache(key, cacheKey, opts) {\n    const result = await this.baseStore.get(key, opts);\n    if (this.cache && result) {\n      this.cache.insert(cacheKey, result);\n    }\n    return result;\n  }\n  async get(key, opts) {\n    const ZARR_EXTS = [\".zarray\", \".zgroup\", \".zattrs\", \"zarr.json\"];\n    if (!this.cache || ZARR_EXTS.some(s => key.endsWith(s))) {\n      return this.baseStore.get(key, opts?.options);\n    }\n    if (opts?.reportKey) {\n      opts.reportKey(key, opts.subscriber);\n    }\n    let keyPrefix = this.baseStore.url ?? \"\";\n    if (keyPrefix !== \"\" && !(keyPrefix instanceof URL) && !keyPrefix.endsWith(\"/\")) {\n      keyPrefix += \"/\";\n    }\n    const fullKey = keyPrefix + key.slice(1);\n\n    // Check the cache\n    const cacheResult = this.cache.get(fullKey);\n    if (cacheResult) {\n      return new Uint8Array(cacheResult);\n    }\n\n    // Not in cache; load the chunk and cache it\n    if (this.queue && opts) {\n      return this.queue.addRequest(fullKey, opts.subscriber, () => this.getAndCache(key, fullKey, opts?.options), opts.isPrefetch);\n    } else {\n      // Should we ever hit this code?  We should always have a request queue.\n      return this.getAndCache(key, fullKey, opts?.options);\n    }\n  }\n}\nexport default WrappedStore;","import { VolumeLoadErrorType, VolumeLoadError } from \"../VolumeLoadError.js\";\n/** Extracts channel names from a `ZarrSource`. Handles missing `omeroMetadata`. Does *not* resolve name collisions. */\nexport function getSourceChannelNames(src) {\n  if (src.omeroMetadata?.channels) {\n    return src.omeroMetadata.channels.map(({\n      label\n    }, idx) => label ?? `Channel ${idx + src.channelOffset}`);\n  }\n  const length = src.scaleLevels[0].shape[src.axesTCZYX[1]];\n  return Array.from({\n    length\n  }, (_, idx) => `Channel ${idx + src.channelOffset}`);\n}\n\n/** Turns `axesTCZYX` into the number of dimensions in the array */\nexport const getDimensionCount = ([t, c, z]) => 2 + Number(t > -1) + Number(c > -1) + Number(z > -1);\nexport function remapAxesToTCZYX(axes) {\n  const axesTCZYX = [-1, -1, -1, -1, -1];\n  const axisNames = [\"t\", \"c\", \"z\", \"y\", \"x\"];\n  axes.forEach((axis, idx) => {\n    const axisIdx = axisNames.indexOf(axis.name);\n    if (axisIdx > -1) {\n      axesTCZYX[axisIdx] = idx;\n    } else {\n      throw new VolumeLoadError(`Unrecognized axis in zarr: ${axis.name}`, {\n        type: VolumeLoadErrorType.INVALID_METADATA\n      });\n    }\n  });\n\n  // it is possible that Z might not exist but we require X and Y at least.\n  const noXAxis = axesTCZYX[4] === -1;\n  if (noXAxis || axesTCZYX[3] === -1) {\n    throw new VolumeLoadError(`Did not find ${noXAxis ? \"an X\" : \"a Y\"} axis in zarr`, {\n      type: VolumeLoadErrorType.INVALID_METADATA\n    });\n  }\n  return axesTCZYX;\n}\n\n/** Reorder an array of values [T, C, Z, Y, X] to the given dimension order */\nexport function orderByDimension(valsTCZYX, orderTCZYX) {\n  const specLen = getDimensionCount(orderTCZYX);\n  const result = Array(specLen);\n  orderTCZYX.forEach((val, idx) => {\n    if (val >= 0) {\n      if (val >= specLen) {\n        throw new VolumeLoadError(`Unexpected axis index in zarr: ${val}`, {\n          type: VolumeLoadErrorType.INVALID_METADATA\n        });\n      }\n      result[val] = valsTCZYX[idx];\n    }\n  });\n  return result;\n}\n\n/** Reorder an array of values in the given dimension order to [T, C, Z, Y, X] */\nexport function orderByTCZYX(valsDimension, orderTCZYX, defaultValue) {\n  const result = [defaultValue, defaultValue, defaultValue, defaultValue, defaultValue];\n  orderTCZYX.forEach((val, idx) => {\n    if (val >= 0) {\n      if (val >= valsDimension.length) {\n        throw new VolumeLoadError(`Unexpected axis index in zarr: ${val}`, {\n          type: VolumeLoadErrorType.INVALID_METADATA\n        });\n      }\n      result[idx] = valsDimension[val];\n    }\n  });\n  return result;\n}\n\n/** Select the scale transform from an OME metadata object with coordinate transforms, and return it in TCZYX order */\nexport function getScale(dataset, orderTCZYX) {\n  const transforms = dataset.coordinateTransformations;\n  if (transforms === undefined) {\n    console.warn(\"WARNING: OMEZarrLoader: no coordinate transformations for scale level.\");\n    return [1, 1, 1, 1, 1];\n  }\n\n  // this assumes we'll never encounter the \"path\" variant\n  const isScaleTransform = t => t.type === \"scale\";\n\n  // there can be any number of coordinateTransformations\n  // but there must be only one of type \"scale\".\n  const scaleTransform = transforms.find(isScaleTransform);\n  if (!scaleTransform) {\n    console.warn(`WARNING: OMEZarrLoader: no coordinate transformation of type \"scale\" for scale level.`);\n    return [1, 1, 1, 1, 1];\n  }\n  const scale = scaleTransform.scale.slice();\n  return orderByTCZYX(scale, orderTCZYX, 1);\n}\n\n/**\n * Defines a partial order of zarr arrays based on their size. Specifically:\n * - If array size x, y, z are all equal, the arrays are equal\n * - otherwise, if all xyz of `a` are less than or equal to those of `b`, `a` is less than `b` (and vice versa)\n * - if some xyz is less and some is greater, the arrays are uncomparable\n */\nfunction compareZarrArraySize(aArr, aTCZYX, bArr, bTCZYX) {\n  const aZ = aTCZYX[2] > -1 ? aArr.shape[aTCZYX[2]] : 1;\n  const bZ = bTCZYX[2] > -1 ? bArr.shape[bTCZYX[2]] : 1;\n  const diffZ = aZ - bZ;\n  const diffY = aArr.shape[aTCZYX[3]] - bArr.shape[bTCZYX[3]];\n  const diffX = aArr.shape[aTCZYX[4]] - bArr.shape[bTCZYX[4]];\n  if (diffZ === 0 && diffY === 0 && diffX === 0) {\n    return 0;\n  } else if (diffZ <= 0 && diffY <= 0 && diffX <= 0) {\n    return -1;\n  } else if (diffZ >= 0 && diffY >= 0 && diffX >= 0) {\n    return 1;\n  } else {\n    return undefined;\n  }\n}\nconst EPSILON = 0.00001;\nconst aboutEquals = (a, b) => Math.abs(a - b) < EPSILON;\nfunction scaleTransformsAreEqual(aSrc, aLevel, bSrc, bLevel) {\n  const aScale = getScale(aSrc.multiscaleMetadata.datasets[aLevel], aSrc.axesTCZYX);\n  const bScale = getScale(bSrc.multiscaleMetadata.datasets[bLevel], bSrc.axesTCZYX);\n  return aboutEquals(aScale[2], bScale[2]) && aboutEquals(aScale[3], bScale[3]) && aboutEquals(aScale[4], bScale[4]);\n}\n\n/**\n * Ensures that all scale levels in `sources` are matched up by size. More precisely: enforces that, for any scale\n * level `i`, the size of zarr array `s[i]` is equal for every source `s`. We accomplish this by removing any arrays\n * (and their associated OME dataset metadata) which don't match up in all sources.\n *\n * Note that this function modifies the input `sources` array rather than returning a new value.\n *\n * Assumes all sources have scale levels ordered by size from largest to smallest. (This should always be true for\n * compliant OME-Zarr data.)\n */\nexport function matchSourceScaleLevels(sources) {\n  if (sources.length < 2) {\n    return;\n  }\n\n  // Save matching scale levels and metadata here\n  const matchedLevels = Array.from({\n    length: sources.length\n  }, () => []);\n  const matchedMetas = Array.from({\n    length: sources.length\n  }, () => []);\n\n  // Start as many index counters as we have sources\n  const scaleIndexes = new Array(sources.length).fill(0);\n  while (scaleIndexes.every((val, idx) => val < sources[idx].scaleLevels.length)) {\n    // First pass: find the smallest source / determine if all sources are equal\n    let allEqual = true;\n    let smallestIdx = 0;\n    let smallestSrc = sources[0];\n    let smallestArr = smallestSrc.scaleLevels[scaleIndexes[0]];\n    for (let currentIdx = 1; currentIdx < sources.length; currentIdx++) {\n      const currentSrc = sources[currentIdx];\n      const currentArr = currentSrc.scaleLevels[scaleIndexes[currentIdx]];\n      const ordering = compareZarrArraySize(smallestArr, smallestSrc.axesTCZYX, currentArr, currentSrc.axesTCZYX);\n      if (!ordering) {\n        // Arrays are equal, or they are uncomparable\n        if (ordering === undefined) {\n          throw new VolumeLoadError(\"Incompatible zarr arrays: pixel dimensions are mismatched\", {\n            type: VolumeLoadErrorType.INVALID_MULTI_SOURCE_ZARR\n          });\n        }\n\n        // Now we know the arrays are equal, but they may still be invalid to match up because...\n        // ...they have different scale transformations\n        if (!scaleTransformsAreEqual(smallestSrc, scaleIndexes[smallestIdx], currentSrc, scaleIndexes[currentIdx])) {\n          // today we are going to treat this as a warning.\n          // For our implementation it is enough that the xyz pixel ranges are the same.\n          // Ideally scale*arraysize=physical size is really the quantity that should be equal, for combining two volume data sets as channels.\n          console.warn(\"Incompatible zarr arrays: scale levels of equal size have different scale transformations\");\n        }\n\n        // ...they have different numbers of timesteps\n        const largestT = smallestSrc.axesTCZYX[0] > -1 ? smallestArr.shape[smallestSrc.axesTCZYX[0]] : 1;\n        const currentT = currentSrc.axesTCZYX[0] > -1 ? currentArr.shape[currentSrc.axesTCZYX[0]] : 1;\n        if (largestT !== currentT) {\n          // we also treat this as a warning.\n          // In OmeZarrLoader we will take the minimum T size of all sources\n          console.warn(`Incompatible zarr arrays: different numbers of timesteps: ${largestT} vs ${currentT}`);\n        }\n      } else {\n        allEqual = false;\n        if (ordering > 0) {\n          smallestIdx = currentIdx;\n          smallestSrc = currentSrc;\n          smallestArr = currentArr;\n        }\n      }\n    }\n    if (allEqual) {\n      // We've found a matching set of scale levels! Save it and increment all indexes\n      for (let i = 0; i < scaleIndexes.length; i++) {\n        const currentSrc = sources[i];\n        const matchedScaleLevel = scaleIndexes[i];\n        matchedLevels[i].push(currentSrc.scaleLevels[matchedScaleLevel]);\n        matchedMetas[i].push(currentSrc.multiscaleMetadata.datasets[matchedScaleLevel]);\n        scaleIndexes[i] += 1;\n      }\n    } else {\n      // Increment the indexes of the sources which are larger than the smallest\n      for (const [idx, srcIdx] of scaleIndexes.entries()) {\n        const currentSrc = sources[idx];\n        const currentArr = currentSrc.scaleLevels[srcIdx];\n        const ordering = compareZarrArraySize(smallestArr, smallestSrc.axesTCZYX, currentArr, currentSrc.axesTCZYX);\n        if (ordering !== 0) {\n          scaleIndexes[idx] += 1;\n        }\n      }\n    }\n  }\n  if (sources[0].scaleLevels.length === 0) {\n    throw new VolumeLoadError(\"Incompatible zarr arrays: no sets of scale levels found that matched in all sources\", {\n      type: VolumeLoadErrorType.INVALID_MULTI_SOURCE_ZARR\n    });\n  }\n  for (let i = 0; i < sources.length; i++) {\n    sources[i].scaleLevels = matchedLevels[i];\n    sources[i].multiscaleMetadata.datasets = matchedMetas[i];\n  }\n}","import { VolumeLoadError, VolumeLoadErrorType } from \"../VolumeLoadError.js\";\nfunction isObjectWithProp(obj, prop) {\n  return typeof obj === \"object\" && obj !== null && prop in obj;\n}\nfunction assertMetadataHasProp(obj, prop, name = \"zarr\") {\n  if (!isObjectWithProp(obj, prop)) {\n    throw new VolumeLoadError(`${name} metadata is missing required entry \"${prop}\"`, {\n      type: VolumeLoadErrorType.INVALID_METADATA\n    });\n  }\n}\nfunction assertPropIsArray(obj, prop, name = \"zarr\") {\n  if (!Array.isArray(obj[prop])) {\n    throw new VolumeLoadError(`${name} metadata entry \"${prop}\" is not an array`, {\n      type: VolumeLoadErrorType.INVALID_METADATA\n    });\n  }\n}\n\n/**\n * Validates that the `OMEZarrMetadata` record `data` has the minimal amount of data required to open a volume. Since\n * we only ever open one multiscale, we only validate the multiscale metadata record at index `multiscaleIdx` here.\n * `name` is used in error messages to identify the source of the metadata.\n */\nexport function validateOMEZarrMetadata(data, multiscaleIdx = 0, name = \"zarr\") {\n  // data is an object with a key \"multiscales\", which is an array\n  assertMetadataHasProp(data, \"multiscales\", name);\n  assertPropIsArray(data, \"multiscales\", name);\n\n  // check that a multiscale metadata entry exists at `multiscaleIdx`\n  const multiscaleMeta = data.multiscales[multiscaleIdx];\n  if (!multiscaleMeta) {\n    throw new VolumeLoadError(`${name} metadata does not have requested multiscale level ${multiscaleIdx}`, {\n      type: VolumeLoadErrorType.INVALID_METADATA\n    });\n  }\n  const multiscaleMetaName = isObjectWithProp(multiscaleMeta, \"name\") ? ` (\"${multiscaleMeta.name})` : \"\";\n  const multiscaleName = `${name} multiscale ${multiscaleIdx}${multiscaleMetaName}`;\n\n  // multiscale has a key \"axes\", which is an array. Each axis has a \"name\".\n  assertMetadataHasProp(multiscaleMeta, \"axes\", multiscaleName);\n  assertPropIsArray(multiscaleMeta, \"axes\", multiscaleName);\n  multiscaleMeta.axes.forEach((axis, i) => assertMetadataHasProp(axis, \"name\", `${multiscaleName} axis ${i}`));\n\n  // multiscale has a key \"datasets\", which is an array. Each dataset has a \"path\".\n  assertMetadataHasProp(multiscaleMeta, \"datasets\", name);\n  assertPropIsArray(multiscaleMeta, \"datasets\", name);\n  multiscaleMeta.datasets.forEach((data, i) => assertMetadataHasProp(data, \"path\", `${multiscaleName} dataset ${i}`));\n}","/** Object format used when passing multiple requests to RequestQueue at once. */\n\nexport const DEFAULT_REQUEST_CANCEL_REASON = \"request cancelled\";\n\n/**\n * Internal object interface used by RequestQueue to store request metadata and callbacks.\n */\n\n/**\n * Manages a queue of asynchronous requests with unique string keys, which can be added to or cancelled.\n * If redundant requests with the same key are issued, the request action will only be run once per key\n * while the original request is still in the queue.\n */\nexport default class RequestQueue {\n  /**\n   * The maximum number of requests that can be handled concurrently.\n   * Once reached, additional requests will be queued up to run once a running request completes.\n   */\n\n  /**\n   * The maximum number of requests that can be handled concurrently if only low-priority requests are waiting. Set\n   * lower than `concurrencyLimit` to always leave space for high-priority requests. Cannot be set higher than\n   * `concurrencyLimit`.\n   */\n\n  /** A queue of requests that are ready to be executed, in order of request time. */\n\n  /** A queue of low-priority tasks that are ready to be executed. `queue` must be empty before any of these tasks run. */\n\n  /** Stores all requests, even those that are currently active. */\n\n  /** Stores requests whose actions are currently being run. */\n\n  /**\n   * Creates a new RequestQueue.\n   * @param maxActiveRequests The maximum number of requests that will be handled concurrently. This is 10 by default.\n   * @param maxLowPriorityRequests The maximum number of low-priority requests that will be handled concurrently. Equal\n   *    to `maxActiveRequests` by default, but may be set lower to always leave space for new high-priority requests.\n   */\n  constructor(maxActiveRequests = 10, maxLowPriorityRequests = 5) {\n    this.allRequests = new Map();\n    this.activeRequests = new Set();\n    this.queue = [];\n    this.queueLowPriority = [];\n    this.maxActiveRequests = maxActiveRequests;\n    this.maxLowPriorityRequests = Math.min(maxActiveRequests, maxLowPriorityRequests);\n  }\n\n  /**\n   * Stores request metadata to the internal map of all pending requests.\n   * @param key string identifier of the request.\n   * @param requestAction callable function action of the request.\n   * @returns a reference to the new, registered RequestItem.\n   */\n  registerRequest(key, requestAction) {\n    // Create a new promise and store the resolve and reject callbacks for later.\n    // This lets us perform the actual action at a later point, when the request is at the\n    // front of the processing queue.\n    let promiseResolve, promiseReject;\n    const promise = new Promise((resolve, reject) => {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n    // Store the request data.\n    const requestItem = {\n      key: key,\n      action: requestAction,\n      resolve: promiseResolve,\n      reject: promiseReject,\n      promise\n    };\n    this.allRequests.set(key, requestItem);\n    return requestItem;\n  }\n\n  /**\n   * Moves a registered request into the processing queue, clearing any timeouts on the request.\n   * @param key string identifier of the request.\n   * @param lowPriority Whether this request should be added with low priority. False by default.\n   */\n  addRequestToQueue(key, lowPriority) {\n    // Check that this request is not cancelled.\n    if (this.allRequests.has(key)) {\n      // Clear the request timeout, if it has one, since it is being added to the queue.\n      const requestItem = this.allRequests.get(key);\n      if (requestItem && requestItem.timeoutId) {\n        clearTimeout(requestItem.timeoutId);\n        requestItem.timeoutId = undefined;\n      }\n      if (!this.queue.includes(key) && !this.queueLowPriority.includes(key)) {\n        // Add to queue and check if the request can be processed right away.\n        if (lowPriority) {\n          this.queueLowPriority.push(key);\n        } else {\n          this.queue.push(key);\n        }\n        this.dequeue();\n      }\n    }\n  }\n\n  /**\n   * Adds a request with a unique key to the queue, if it doesn't already exist.\n   * @param key The key used to track the request.\n   * @param requestAction Function that will be called to complete the request. The function\n   *  will be run only once per unique key while the request exists, and may be deferred by the\n   *  queue at any time.\n   * @param lowPriority Whether this request should be added with low priority. False by default.\n   * @param delayMs Minimum delay, in milliseconds, before this request should be executed.\n   *\n   * NOTE: Cancelling a request while the action is running WILL NOT stop the action. If this behavior is desired,\n   * actions must be responsible for checking the RequestQueue, determining if the request is still valid (e.g.\n   * using `.hasRequest()`), and stopping or returning early.\n   *\n   * @returns A promise that will resolve on completion of the request, or reject if the request is cancelled.\n   *  If multiple requests are issued with the same key, a promise for the first request will be returned\n   *  until the request is resolved or cancelled.\n   *  Note that the return type of the promise will match that of the first request's instance.\n   */\n  addRequest(key, requestAction, lowPriority = false, delayMs = 0) {\n    if (!this.allRequests.has(key)) {\n      // New request!\n      const requestItem = this.registerRequest(key, requestAction);\n      // If a delay is set, wait to add this to the queue.\n      if (delayMs > 0) {\n        const timeoutId = setTimeout(() => this.addRequestToQueue(key, lowPriority), delayMs);\n        // Save timeout information to request metadata\n        requestItem.timeoutId = timeoutId;\n      } else {\n        // No delay, add immediately\n        this.addRequestToQueue(key, lowPriority);\n      }\n    } else {\n      const lowPriorityIndex = this.queueLowPriority.indexOf(key);\n      if (lowPriorityIndex > -1 && !lowPriority) {\n        // This request is registered and queued, but is now being requested with high priority.\n        // Promote it to high priority.\n        this.queueLowPriority.splice(lowPriorityIndex, 1);\n        this.addRequestToQueue(key);\n      } else if (delayMs <= 0) {\n        // This request is registered, but is now being requested without a delay.\n        // Move into queue immediately if it's not already added, and clear any timeouts it may have.\n        this.addRequestToQueue(key, lowPriority);\n      }\n    }\n    const promise = this.allRequests.get(key)?.promise;\n    if (!promise) {\n      throw new Error(\"Found no promise to return when getting stored request data.\");\n    }\n    return promise;\n  }\n\n  /**\n   * Adds multiple requests to the queue, with an optional delay between each.\n   * @param requests An array of RequestItems, which include a key and a request action.\n   * @param lowPriority Whether these requests should be added with low priority. False by default.\n   * @param delayMs An optional minimum delay in milliseconds to be added between each request.\n   *  For example, a delay of 10 ms will cause the second request to be added to the processing queue\n   *  after 10 ms, the third to added after 20 ms, and so on. Set to 10 ms by default.\n   * @returns An array of promises corresponding to the provided requests. (i.e., the `i`th value\n   * of the returned array will be a Promise for the resolution of `requests[i]`). If a request\n   *  with a matching key is already pending, returns the promise for the initial request.\n   */\n  addRequests(requests, lowPriority = false, delayMs = 10) {\n    const promises = [];\n    for (let i = 0; i < requests.length; i++) {\n      const item = requests[i];\n      const promise = this.addRequest(item.key, item.requestAction, lowPriority, delayMs * i);\n      promises.push(promise);\n    }\n    return promises;\n  }\n\n  /**\n   * Attempts to remove and run the next queued request item, if resources are available.\n   * @returns true if a request was started, or false if there are too many\n   * requests already active.\n   */\n  async dequeue() {\n    const numRequests = this.activeRequests.size;\n    if (numRequests >= this.maxActiveRequests || this.queue.length === 0 && (numRequests >= this.maxLowPriorityRequests || this.queueLowPriority.length === 0)) {\n      return;\n    }\n    const requestKey = this.queue.shift() ?? this.queueLowPriority.shift();\n    if (!requestKey) {\n      return;\n    }\n    if (this.activeRequests.has(requestKey)) {\n      // This request is already active, try the next one instead. (this shouldn't happen)\n      this.dequeue();\n      return;\n    }\n    const requestItem = this.allRequests.get(requestKey);\n    if (!requestItem) {\n      return;\n    }\n    const key = requestItem.key;\n    // Mark that this request is active\n    this.activeRequests.add(key);\n    await requestItem.action().then(requestItem.resolve, requestItem.reject);\n    this.activeRequests.delete(key);\n    this.allRequests.delete(key);\n    this.dequeue();\n  }\n\n  /**\n   * Removes any request matching the provided key from the queue and rejects its promise.\n   * @param key The key that should be matched against.\n   * @param cancelReason A message or object that will be used as the promise rejection.\n   */\n  cancelRequest(key, cancelReason = DEFAULT_REQUEST_CANCEL_REASON) {\n    if (!this.allRequests.has(key)) {\n      return;\n    }\n    const requestItem = this.allRequests.get(key);\n    if (requestItem) {\n      if (requestItem.timeoutId) {\n        // Cancel requests that have not been queued yet.\n        clearTimeout(requestItem.timeoutId);\n      }\n      // Reject the request, then clear from the queue and known requests.\n      requestItem.reject(cancelReason);\n    }\n    const queueIndex = this.queue.indexOf(key);\n    if (queueIndex > -1) {\n      this.queue.splice(queueIndex, 1);\n    } else {\n      const lowPriorityIndex = this.queueLowPriority.indexOf(key);\n      if (lowPriorityIndex > -1) {\n        this.queueLowPriority.splice(lowPriorityIndex, 1);\n      }\n    }\n    this.allRequests.delete(key);\n    this.activeRequests.delete(key);\n  }\n\n  /**\n   * Rejects all request promises and clears the queue.\n   * @param cancelReason A message or object that will be used as the promise rejection.\n   */\n  cancelAllRequests(cancelReason = DEFAULT_REQUEST_CANCEL_REASON) {\n    // Clear the queue so we don't do extra work while filtering it\n    this.queue = [];\n    this.queueLowPriority = [];\n    for (const key of this.allRequests.keys()) {\n      this.cancelRequest(key, cancelReason);\n    }\n  }\n\n  /**\n   * Returns whether a request with the given key exists in the RequestQueue and is not cancelled.\n   * @param key the key to search for.\n   * @returns true if the request is in the RequestQueue.\n   */\n  hasRequest(key) {\n    return this.allRequests.has(key);\n  }\n\n  /**\n   * Returns whether the request with the given key is currently running (not waiting in the queue).\n   * @param key the key to search for.\n   * @returns true if the request is actively running.\n   */\n  requestRunning(key) {\n    return this.activeRequests.has(key);\n  }\n}","import RequestQueue from \"./RequestQueue.js\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * An extension of `RequestQueue` that adds a concept of \"subscribers,\" which may share references to a single request\n * or cancel their subscription without disrupting the request for other subscribers.\n */\nexport default class SubscribableRequestQueue {\n  /** The next unused subscriber ID. Increments whenever a subscriber is added. */\n\n  /**\n   * Map of subscribers keyed by ID. Subscribers store a map to all their subscriptions by request key.\n   * Subscribers are only useful as handles to cancel subscriptions early, so we only need to store rejecters here.\n   */\n\n  /** Map from \"inner\" request (managed by `queue`) to \"outer\" promises generated per-subscriber. */\n\n  /**\n   * Since `SubscribableRequestQueue` wraps `RequestQueue`, its constructor may either take the same arguments as the\n   * `RequestQueue` constructor and create a new `RequestQueue`, or it may take an existing `RequestQueue` to wrap.\n   */\n\n  constructor(maxActiveRequests, maxLowPriorityRequests) {\n    if (typeof maxActiveRequests === \"number\" || maxActiveRequests === undefined) {\n      this.queue = new RequestQueue(maxActiveRequests, maxLowPriorityRequests);\n    } else {\n      this.queue = maxActiveRequests;\n    }\n    this.nextSubscriberId = 0;\n    this.subscribers = new Map();\n    this.requests = new Map();\n  }\n\n  /** Resolves all subscriptions to request `key` with `value` */\n  resolveAll(key, value) {\n    const requests = this.requests.get(key);\n    if (requests) {\n      for (const {\n        resolve,\n        subscriberId\n      } of requests) {\n        resolve(value);\n        this.subscribers.get(subscriberId)?.delete(key);\n      }\n      this.requests.delete(key);\n    }\n  }\n\n  /** Rejects all subscriptions to request `key` with `reason` */\n  rejectAll(key, reason) {\n    const requests = this.requests.get(key);\n    if (requests) {\n      for (const {\n        reject,\n        subscriberId\n      } of requests) {\n        reject(reason);\n        this.subscribers.get(subscriberId)?.delete(key);\n      }\n      this.requests.delete(key);\n    }\n  }\n\n  /** Adds a new request subscriber. Returns a unique ID to identify this subscriber. */\n  addSubscriber() {\n    const subscriberId = this.nextSubscriberId;\n    this.nextSubscriberId++;\n    this.subscribers.set(subscriberId, new Map());\n    return subscriberId;\n  }\n\n  /**\n   * Queues a new request, or adds a subscription if the request is already queued/running.\n   *\n   * If `subscriberId` is already subscribed to the request, this rejects the existing promise and returns a new one.\n   */\n  addRequest(key, subscriberId, requestAction, lowPriority, delayMs) {\n    // Create single underlying request if it does not yet exist\n    this.queue.addRequest(key, requestAction, lowPriority, delayMs).then(value => this.resolveAll(key, value)).catch(reason => this.rejectAll(key, reason));\n    if (!this.requests.has(key)) {\n      this.requests.set(key, []);\n    }\n\n    // Validate subscriber\n    if (subscriberId >= this.nextSubscriberId || subscriberId < 0) {\n      throw new Error(`SubscribableRequestQueue: subscriber id ${subscriberId} has not been registered`);\n    }\n    const subscriber = this.subscribers.get(subscriberId);\n    if (!subscriber) {\n      throw new Error(`SubscribableRequestQueue: subscriber id ${subscriberId} has been removed`);\n    }\n\n    // Create promise and add to list of requests\n    return new Promise((resolve, reject) => {\n      this.requests.get(key)?.push({\n        resolve,\n        reject,\n        subscriberId\n      });\n      const subscriber = this.subscribers.get(subscriberId);\n      const existingRequest = subscriber?.get(key);\n      if (existingRequest) {\n        existingRequest.push(reject);\n      } else {\n        subscriber?.set(key, [reject]);\n      }\n    });\n  }\n\n  /**\n   * Rejects a subscription and removes it from the list of subscriptions for a request, then cancels the underlying\n   * request if it is no longer subscribed and is not running already.\n   */\n  rejectSubscription(key, reject, cancelReason) {\n    // Reject the outer \"subscription\" promise\n    reject(cancelReason);\n\n    // Get the list of subscriptions for this request\n    const subscriptions = this.requests.get(key);\n    if (!subscriptions) {\n      // This should never happen\n      return;\n    }\n    // Remove this request subscription by ref equality to `reject`\n    const idx = subscriptions.findIndex(sub => sub.reject === reject);\n    if (idx >= 0) {\n      subscriptions.splice(idx, 1);\n    }\n\n    // Remove the underlying request if there are no more subscribers and the request is not already running\n    if (subscriptions.length < 1 && !this.queue.requestRunning(key)) {\n      this.queue.cancelRequest(key, cancelReason);\n      this.requests.delete(key);\n    }\n  }\n\n  /** Cancels a request subscription, and cancels the underlying request if it is no longer subscribed or running. */\n  cancelRequest(key, subscriberId, cancelReason) {\n    const subscriber = this.subscribers.get(subscriberId);\n    if (!subscriber) {\n      return false;\n    }\n    const rejecters = subscriber.get(key);\n    if (!rejecters || !rejecters.length) {\n      return false;\n    }\n    for (const reject of rejecters) {\n      this.rejectSubscription(key, reject, cancelReason);\n    }\n    subscriber.delete(key);\n    return true;\n  }\n\n  /** Removes a subscriber and cancels its remaining subscriptions. */\n  removeSubscriber(subscriberId, cancelReason) {\n    const subscriptions = this.subscribers.get(subscriberId);\n    if (subscriptions) {\n      for (const [key, rejecters] of subscriptions.entries()) {\n        for (const reject of rejecters) {\n          this.rejectSubscription(key, reject, cancelReason);\n        }\n      }\n      this.subscribers.delete(subscriberId);\n    }\n  }\n\n  /** Returns whether a request with the given `key` is running or waiting in the queue */\n  hasRequest(key) {\n    return this.queue.hasRequest(key);\n  }\n\n  /** Returns whether a request with the given `key` is running */\n  requestRunning(key) {\n    return this.queue.requestRunning(key);\n  }\n\n  /** Returns whether a subscriber with the given `subscriberId` exists */\n  hasSubscriber(subscriberId) {\n    return this.subscribers.has(subscriberId);\n  }\n\n  /** Returns whether a subscriber with the given `subscriberId` is subscribed to the request with the given `key` */\n  isSubscribed(subscriberId, key) {\n    return this.subscribers.get(subscriberId)?.has(key) ?? false;\n  }\n}","/** The types of requests that can be made to the worker. Mostly corresponds to methods on `IVolumeLoader`. */\nexport let WorkerMsgType = /*#__PURE__*/function (WorkerMsgType) {\n  WorkerMsgType[WorkerMsgType[\"INIT\"] = 0] = \"INIT\";\n  WorkerMsgType[WorkerMsgType[\"CREATE_LOADER\"] = 1] = \"CREATE_LOADER\";\n  WorkerMsgType[WorkerMsgType[\"CREATE_VOLUME\"] = 2] = \"CREATE_VOLUME\";\n  WorkerMsgType[WorkerMsgType[\"LOAD_DIMS\"] = 3] = \"LOAD_DIMS\";\n  WorkerMsgType[WorkerMsgType[\"LOAD_VOLUME_DATA\"] = 4] = \"LOAD_VOLUME_DATA\";\n  WorkerMsgType[WorkerMsgType[\"SET_PREFETCH_PRIORITY_DIRECTIONS\"] = 5] = \"SET_PREFETCH_PRIORITY_DIRECTIONS\";\n  WorkerMsgType[WorkerMsgType[\"SYNCHRONIZE_MULTICHANNEL_LOADING\"] = 6] = \"SYNCHRONIZE_MULTICHANNEL_LOADING\";\n  WorkerMsgType[WorkerMsgType[\"UPDATE_FETCH_OPTIONS\"] = 7] = \"UPDATE_FETCH_OPTIONS\";\n  return WorkerMsgType;\n}({});\n\n/** The kind of response a worker can return - `SUCCESS`, `ERROR`, or `EVENT`. */\nexport let WorkerResponseResult = /*#__PURE__*/function (WorkerResponseResult) {\n  WorkerResponseResult[WorkerResponseResult[\"SUCCESS\"] = 0] = \"SUCCESS\";\n  WorkerResponseResult[WorkerResponseResult[\"ERROR\"] = 1] = \"ERROR\";\n  WorkerResponseResult[WorkerResponseResult[\"EVENT\"] = 2] = \"EVENT\";\n  return WorkerResponseResult;\n}({});\n\n/** The kind of events that can occur when loading */\nexport let WorkerEventType = /*#__PURE__*/function (WorkerEventType) {\n  WorkerEventType[WorkerEventType[\"METADATA_UPDATE\"] = 0] = \"METADATA_UPDATE\";\n  WorkerEventType[WorkerEventType[\"CHANNEL_LOAD\"] = 1] = \"CHANNEL_LOAD\";\n  return WorkerEventType;\n}({});\n\n/** All messages to/from a worker carry a `msgId`, a `type`, and a `payload` (whose type is determined by `type`). */\n\n/** Maps each `WorkerMsgType` to the type of the payload of requests of that type. */\n\n/** Maps each `WorkerMsgType` to the type of the payload of responses of that type. */\n\n/** Event for when a batch of channel data loads. */\n\n/** Event for when metadata updates. */\n\n/** All valid types of worker requests, with some `WorkerMsgType` and a matching payload type. */\n\n/** All valid types of worker responses: `SUCCESS` with a matching payload, `ERROR` with a message, or an `EVENT`. */","import { Box3, Vector3 } from \"three\";\n/** Recreates a `LoadSpec` that has just been sent to/from a worker to restore three.js object prototypes */\nexport function rebuildLoadSpec(spec) {\n  return {\n    ...spec,\n    subregion: new Box3(new Vector3().copy(spec.subregion.min), new Vector3().copy(spec.subregion.max))\n  };\n}","import { BoolArray, ByteStringArray, UnicodeStringArray, } from \"@zarrita/typedarray\";\nimport { get_strides } from \"../util.js\";\nfunction proxy(arr) {\n    if (arr instanceof BoolArray ||\n        arr instanceof ByteStringArray ||\n        arr instanceof UnicodeStringArray) {\n        return new Proxy(arr, {\n            get(target, prop) {\n                return target.get(Number(prop));\n            },\n            set(target, prop, value) {\n                target.set(Number(prop), value);\n                return true;\n            },\n        });\n    }\n    return arr;\n}\nfunction empty_like(chunk, order) {\n    let data;\n    if (chunk.data instanceof ByteStringArray ||\n        chunk.data instanceof UnicodeStringArray) {\n        data = new chunk.constructor(\n        // @ts-expect-error\n        chunk.data.length, chunk.data.chars);\n    }\n    else {\n        data = new chunk.constructor(chunk.data.length);\n    }\n    return {\n        data,\n        shape: chunk.shape,\n        stride: get_strides(chunk.shape, order),\n    };\n}\nfunction convert_array_order(src, target) {\n    let out = empty_like(src, target);\n    let n_dims = src.shape.length;\n    let size = src.data.length;\n    let index = Array(n_dims).fill(0);\n    let src_data = proxy(src.data);\n    let out_data = proxy(out.data);\n    for (let src_idx = 0; src_idx < size; src_idx++) {\n        let out_idx = 0;\n        for (let dim = 0; dim < n_dims; dim++) {\n            out_idx += index[dim] * out.stride[dim];\n        }\n        out_data[out_idx] = src_data[src_idx];\n        index[0] += 1;\n        for (let dim = 0; dim < n_dims; dim++) {\n            if (index[dim] === src.shape[dim]) {\n                if (dim + 1 === n_dims) {\n                    break;\n                }\n                index[dim] = 0;\n                index[dim + 1] += 1;\n            }\n        }\n    }\n    return out;\n}\nfunction get_order(arr) {\n    // Assume C order if no stride is given\n    if (!arr.stride)\n        return \"C\";\n    let row_major_strides = get_strides(arr.shape, \"C\");\n    return arr.stride.every((s, i) => s === row_major_strides[i]) ? \"C\" : \"F\";\n}\nexport class TransposeCodec {\n    configuration;\n    kind = \"array_to_array\";\n    constructor(configuration) {\n        this.configuration = configuration;\n    }\n    static fromConfig(configuration) {\n        return new TransposeCodec(configuration);\n    }\n    encode(arr) {\n        if (get_order(arr) === this.configuration.order) {\n            return arr;\n        }\n        return convert_array_order(arr, this.configuration.order);\n    }\n    decode(arr) {\n        return arr;\n    }\n}\n","import { byteswap_inplace, get_array_order, get_ctr, get_strides, } from \"../util.js\";\nconst LITTLE_ENDIAN_OS = system_is_little_endian();\nfunction system_is_little_endian() {\n    const a = new Uint32Array([0x12345678]);\n    const b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n    return !(b[0] === 0x12);\n}\nfunction bytes_per_element(TypedArray) {\n    if (\"BYTES_PER_ELEMENT\" in TypedArray) {\n        return TypedArray.BYTES_PER_ELEMENT;\n    }\n    // Unicode string array is backed by a Int32Array.\n    return 4;\n}\nexport class EndianCodec {\n    configuration;\n    kind = \"array_to_bytes\";\n    #strides;\n    #TypedArray;\n    #BYTES_PER_ELEMENT;\n    #shape;\n    constructor(configuration, meta) {\n        this.configuration = configuration;\n        this.#TypedArray = get_ctr(meta.data_type);\n        this.#shape = meta.shape;\n        this.#strides = get_strides(meta.shape, get_array_order(meta.codecs));\n        // TODO: fix me.\n        // hack to get bytes per element since it's dynamic for string types.\n        this.#BYTES_PER_ELEMENT = new this.#TypedArray(0).BYTES_PER_ELEMENT;\n    }\n    static fromConfig(configuration, meta) {\n        return new EndianCodec(configuration, meta);\n    }\n    encode(arr) {\n        let bytes = new Uint8Array(arr.data.buffer);\n        if (LITTLE_ENDIAN_OS && this.configuration.endian === \"big\") {\n            byteswap_inplace(bytes, bytes_per_element(this.#TypedArray));\n        }\n        return bytes;\n    }\n    decode(bytes) {\n        if (LITTLE_ENDIAN_OS && this.configuration.endian === \"big\") {\n            byteswap_inplace(bytes, bytes_per_element(this.#TypedArray));\n        }\n        return {\n            data: new this.#TypedArray(bytes.buffer, bytes.byteOffset, bytes.byteLength / this.#BYTES_PER_ELEMENT),\n            shape: this.#shape,\n            stride: this.#strides,\n        };\n    }\n}\n","export class Crc32cCodec {\n    kind = \"bytes_to_bytes\";\n    constructor() { }\n    static fromConfig() {\n        return new Crc32cCodec();\n    }\n    encode(_) {\n        throw new Error(\"Not implemented\");\n    }\n    decode(arr) {\n        return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength - 4);\n    }\n}\n","import { get_strides } from \"../util.js\";\nexport class VLenUTF8 {\n    kind = \"array_to_bytes\";\n    #shape;\n    #strides;\n    constructor(shape) {\n        this.#shape = shape;\n        this.#strides = get_strides(shape, \"C\");\n    }\n    static fromConfig(_, meta) {\n        return new VLenUTF8(meta.shape);\n    }\n    encode(_chunk) {\n        throw new Error(\"Method not implemented.\");\n    }\n    decode(bytes) {\n        let decoder = new TextDecoder();\n        let view = new DataView(bytes.buffer);\n        let data = Array(view.getUint32(0, true));\n        let pos = 4;\n        for (let i = 0; i < data.length; i++) {\n            let item_length = view.getUint32(pos, true);\n            pos += 4;\n            data[i] = decoder.decode(bytes.buffer.slice(pos, pos + item_length));\n            pos += item_length;\n        }\n        return { data, shape: this.#shape, stride: this.#strides };\n    }\n}\n","import { TransposeCodec } from \"./codecs/transpose.js\";\nimport { EndianCodec } from \"./codecs/endian.js\";\nimport { Crc32cCodec } from \"./codecs/crc32c.js\";\nimport { VLenUTF8 } from \"./codecs/vlen-utf8.js\";\nfunction create_default_registry() {\n    return new Map()\n        .set(\"blosc\", () => import(\"numcodecs/blosc\").then((m) => m.default))\n        .set(\"gzip\", () => import(\"numcodecs/gzip\").then((m) => m.default))\n        .set(\"lz4\", () => import(\"numcodecs/lz4\").then((m) => m.default))\n        .set(\"zlib\", () => import(\"numcodecs/zlib\").then((m) => m.default))\n        .set(\"zstd\", () => import(\"numcodecs/zstd\").then((m) => m.default))\n        .set(\"transpose\", () => TransposeCodec)\n        .set(\"endian\", () => EndianCodec)\n        .set(\"crc32c\", () => Crc32cCodec)\n        .set(\"vlen-utf8\", () => VLenUTF8);\n}\nexport const registry = create_default_registry();\nexport function create_codec_pipeline(chunk_metadata) {\n    let codecs;\n    return {\n        async encode(chunk) {\n            if (!codecs)\n                codecs = await load_codecs(chunk_metadata);\n            for (const codec of codecs.array_to_array) {\n                chunk = await codec.encode(chunk);\n            }\n            let bytes = await codecs.array_to_bytes.encode(chunk);\n            for (const codec of codecs.bytes_to_bytes) {\n                bytes = await codec.encode(bytes);\n            }\n            return bytes;\n        },\n        async decode(bytes) {\n            if (!codecs)\n                codecs = await load_codecs(chunk_metadata);\n            for (let i = codecs.bytes_to_bytes.length - 1; i >= 0; i--) {\n                bytes = await codecs.bytes_to_bytes[i].decode(bytes);\n            }\n            let chunk = await codecs.array_to_bytes.decode(bytes);\n            for (let i = codecs.array_to_array.length - 1; i >= 0; i--) {\n                chunk = await codecs.array_to_array[i].decode(chunk);\n            }\n            return chunk;\n        },\n    };\n}\nasync function load_codecs(chunk_meta) {\n    let promises = chunk_meta.codecs.map(async (meta) => {\n        let Codec = await registry.get(meta.name)?.();\n        if (!Codec) {\n            throw new Error(`Unknown codec: ${meta.name}`);\n        }\n        return { Codec, meta };\n    });\n    let array_to_array = [];\n    let array_to_bytes = EndianCodec.fromConfig({\n        endian: \"little\",\n    }, chunk_meta);\n    let bytes_to_bytes = [];\n    for await (let { Codec, meta } of promises) {\n        let codec = Codec.fromConfig(meta.configuration, chunk_meta);\n        switch (codec.kind) {\n            case \"array_to_array\":\n                array_to_array.push(codec);\n                break;\n            case \"array_to_bytes\":\n                array_to_bytes = codec;\n                break;\n            default:\n                bytes_to_bytes.push(codec);\n        }\n    }\n    if (!array_to_bytes) {\n    }\n    return { array_to_array, array_to_bytes, bytes_to_bytes };\n}\n","import { create_codec_pipeline } from \"../codecs.js\";\nconst MAX_BIG_UINT = 18446744073709551615n;\nexport function create_sharded_chunk_getter(location, shard_shape, encode_shard_key, sharding_config) {\n    if (location.store.getRange === undefined) {\n        throw new Error(\"Store does not support range requests\");\n    }\n    let get_range = location.store.getRange.bind(location.store);\n    let index_shape = shard_shape.map((d, i) => d / sharding_config.chunk_shape[i]);\n    let index_codec = create_codec_pipeline({\n        data_type: \"uint64\",\n        shape: [...index_shape, 2],\n        codecs: sharding_config.index_codecs,\n    });\n    let cache = {};\n    return async (chunk_coord) => {\n        let shard_coord = chunk_coord.map((d, i) => Math.floor(d / index_shape[i]));\n        let shard_path = location.resolve(encode_shard_key(shard_coord)).path;\n        let index;\n        if (shard_path in cache) {\n            index = cache[shard_path];\n        }\n        else {\n            let checksum_size = 4;\n            let index_size = 16 * index_shape.reduce((a, b) => a * b, 1);\n            let bytes = await get_range(shard_path, {\n                suffixLength: index_size + checksum_size,\n            });\n            index = cache[shard_path] = bytes\n                ? await index_codec.decode(bytes)\n                : null;\n        }\n        if (index === null) {\n            return undefined;\n        }\n        let { data, shape, stride } = index;\n        let linear_offset = chunk_coord\n            .map((d, i) => d % shape[i])\n            .reduce((acc, sel, idx) => acc + sel * stride[idx], 0);\n        let offset = data[linear_offset];\n        let length = data[linear_offset + 1];\n        // write null chunk when 2^64-1 indicates fill value\n        if (offset === MAX_BIG_UINT && length === MAX_BIG_UINT) {\n            return undefined;\n        }\n        return get_range(shard_path, {\n            offset: Number(offset),\n            length: Number(length),\n        });\n    };\n}\n","import { is_dtype, is_sharding_codec, } from \"./util.js\";\nimport { create_codec_pipeline } from \"./codecs.js\";\nimport { create_chunk_key_encoder, ensure_correct_scalar, get_array_order, get_ctr, get_strides, } from \"./util.js\";\nimport { create_sharded_chunk_getter } from \"./codecs/sharding.js\";\nexport class Location {\n    store;\n    path;\n    constructor(store, path = \"/\") {\n        this.store = store;\n        this.path = path;\n    }\n    resolve(path) {\n        // reuse URL resolution logic built into the browser\n        // handles relative paths, absolute paths, etc.\n        let root = new URL(`file://${this.path.endsWith(\"/\") ? this.path : `${this.path}/`}`);\n        return new Location(this.store, new URL(path, root).pathname);\n    }\n}\nexport function root(store) {\n    return new Location(store ?? new Map());\n}\nexport class Group extends Location {\n    kind = \"group\";\n    #metadata;\n    constructor(store, path, metadata) {\n        super(store, path);\n        this.#metadata = metadata;\n    }\n    get attrs() {\n        return this.#metadata.attributes;\n    }\n}\nconst CONTEXT_MARKER = Symbol(\"zarrita.context\");\nexport function get_context(obj) {\n    return obj[CONTEXT_MARKER];\n}\nfunction create_context(location, metadata) {\n    let { configuration } = metadata.codecs.find(is_sharding_codec) ?? {};\n    let shared_context = {\n        encode_chunk_key: create_chunk_key_encoder(metadata.chunk_key_encoding),\n        TypedArray: get_ctr(metadata.data_type),\n        fill_value: metadata.fill_value,\n    };\n    if (configuration) {\n        let native_order = get_array_order(configuration.codecs);\n        return {\n            ...shared_context,\n            kind: \"sharded\",\n            chunk_shape: configuration.chunk_shape,\n            codec: create_codec_pipeline({\n                data_type: metadata.data_type,\n                shape: configuration.chunk_shape,\n                codecs: configuration.codecs,\n            }),\n            get_strides(shape, order) {\n                return get_strides(shape, order ?? native_order);\n            },\n            get_chunk_bytes: create_sharded_chunk_getter(location, metadata.chunk_grid.configuration.chunk_shape, shared_context.encode_chunk_key, configuration),\n        };\n    }\n    let native_order = get_array_order(metadata.codecs);\n    return {\n        ...shared_context,\n        kind: \"regular\",\n        chunk_shape: metadata.chunk_grid.configuration.chunk_shape,\n        codec: create_codec_pipeline({\n            data_type: metadata.data_type,\n            shape: metadata.chunk_grid.configuration.chunk_shape,\n            codecs: metadata.codecs,\n        }),\n        get_strides(shape, order) {\n            return get_strides(shape, order ?? native_order);\n        },\n        async get_chunk_bytes(chunk_coords, options) {\n            let chunk_key = shared_context.encode_chunk_key(chunk_coords);\n            let chunk_path = location.resolve(chunk_key).path;\n            return location.store.get(chunk_path, options);\n        },\n    };\n}\nexport class Array extends Location {\n    kind = \"array\";\n    #metadata;\n    [CONTEXT_MARKER];\n    constructor(store, path, metadata) {\n        super(store, path);\n        this.#metadata = {\n            ...metadata,\n            fill_value: ensure_correct_scalar(metadata),\n        };\n        this[CONTEXT_MARKER] = create_context(this, metadata);\n    }\n    get attrs() {\n        return this.#metadata.attributes;\n    }\n    get shape() {\n        return this.#metadata.shape;\n    }\n    get chunks() {\n        return this[CONTEXT_MARKER].chunk_shape;\n    }\n    get dtype() {\n        return this.#metadata.data_type;\n    }\n    async getChunk(chunk_coords, options) {\n        let context = this[CONTEXT_MARKER];\n        let maybe_bytes = await context.get_chunk_bytes(chunk_coords, options);\n        if (!maybe_bytes) {\n            let size = context.chunk_shape.reduce((a, b) => a * b, 1);\n            let data = new context.TypedArray(size);\n            data.fill(context.fill_value);\n            return {\n                data,\n                shape: context.chunk_shape,\n                stride: context.get_strides(context.chunk_shape),\n            };\n        }\n        return context.codec.decode(maybe_bytes);\n    }\n    /**\n     * A helper method to narrow `zarr.Array` Dtype.\n     *\n     * ```typescript\n     * let arr: zarr.Array<DataType, FetchStore> = zarr.open(store, { kind: \"array\" });\n     *\n     * // Option 1: narrow by scalar type (e.g. \"bool\", \"raw\", \"bigint\", \"number\")\n     * if (arr.is(\"bigint\")) {\n     *   // zarr.Array<\"int64\" | \"uint64\", FetchStore>\n     * }\n     *\n     * // Option 3: exact match\n     * if (arr.is(\"float32\")) {\n     *   // zarr.Array<\"float32\", FetchStore, \"/\">\n     * }\n     * ```\n     */\n    is(query) {\n        return is_dtype(this.dtype, query);\n    }\n}\n","import { Array, Group, Location } from \"./hierarchy.js\";\nimport { NodeNotFoundError } from \"./errors.js\";\nimport { json_decode_object, v2_to_v3_array_metadata, v2_to_v3_group_metadata, } from \"./util.js\";\nasync function load_attrs(location) {\n    let meta_bytes = await location.store.get(location.resolve(\".zattrs\").path);\n    if (!meta_bytes)\n        return {};\n    return json_decode_object(meta_bytes);\n}\nasync function open_v2(location, options = {}) {\n    let loc = \"store\" in location ? location : new Location(location);\n    let attrs = {};\n    if (options.attrs ?? true)\n        attrs = await load_attrs(loc);\n    if (options.kind === \"array\")\n        return open_array_v2(loc, attrs);\n    if (options.kind === \"group\")\n        return open_group_v2(loc, attrs);\n    return open_array_v2(loc, attrs).catch((err) => {\n        if (err instanceof NodeNotFoundError)\n            return open_group_v2(loc, attrs);\n        throw err;\n    });\n}\nasync function open_array_v2(location, attrs) {\n    let { path } = location.resolve(\".zarray\");\n    let meta = await location.store.get(path);\n    if (!meta) {\n        throw new NodeNotFoundError(path);\n    }\n    return new Array(location.store, location.path, v2_to_v3_array_metadata(json_decode_object(meta), attrs));\n}\nasync function open_group_v2(location, attrs) {\n    let { path } = location.resolve(\".zgroup\");\n    let meta = await location.store.get(path);\n    if (!meta) {\n        throw new NodeNotFoundError(path);\n    }\n    return new Group(location.store, location.path, v2_to_v3_group_metadata(json_decode_object(meta), attrs));\n}\nasync function _open_v3(location) {\n    let { store, path } = location.resolve(\"zarr.json\");\n    let meta = await location.store.get(path);\n    if (!meta) {\n        throw new NodeNotFoundError(path);\n    }\n    let meta_doc = json_decode_object(meta);\n    if (meta_doc.node_type === \"array\" &&\n        (meta_doc.data_type === \"uint64\" || meta_doc.data_type === \"int64\") &&\n        meta_doc.fill_value != undefined) {\n        meta_doc.fill_value = BigInt(meta_doc.fill_value);\n    }\n    return meta_doc.node_type === \"array\"\n        ? new Array(store, location.path, meta_doc)\n        : new Group(store, location.path, meta_doc);\n}\nasync function open_v3(location, options = {}) {\n    let loc = \"store\" in location ? location : new Location(location);\n    let node = await _open_v3(loc);\n    if (options.kind === undefined)\n        return node;\n    if (options.kind === \"array\" && node instanceof Array)\n        return node;\n    if (options.kind === \"group\" && node instanceof Group)\n        return node;\n    let kind = node instanceof Array ? \"array\" : \"group\";\n    throw new Error(`Expected node of kind ${options.kind}, found ${kind}.`);\n}\nexport async function open(location, options = {}) {\n    return open_v3(location, options).catch((err) => {\n        if (err instanceof NodeNotFoundError) {\n            return open_v2(location, options);\n        }\n        throw err;\n    });\n}\nopen.v2 = open_v2;\nopen.v3 = open_v3;\n","import { BoolArray, ByteStringArray, UnicodeStringArray, } from \"@zarrita/typedarray\";\nexport function json_encode_object(o) {\n    const str = JSON.stringify(o, null, 2);\n    return new TextEncoder().encode(str);\n}\nexport function json_decode_object(bytes) {\n    const str = new TextDecoder().decode(bytes);\n    return JSON.parse(str);\n}\nexport function byteswap_inplace(view, bytes_per_element) {\n    const numFlips = bytes_per_element / 2;\n    const endByteIndex = bytes_per_element - 1;\n    let t = 0;\n    for (let i = 0; i < view.length; i += bytes_per_element) {\n        for (let j = 0; j < numFlips; j += 1) {\n            t = view[i + j];\n            view[i + j] = view[i + endByteIndex - j];\n            view[i + endByteIndex - j] = t;\n        }\n    }\n}\nconst CONSTRUCTORS = {\n    int8: Int8Array,\n    int16: Int16Array,\n    int32: Int32Array,\n    int64: globalThis.BigInt64Array,\n    uint8: Uint8Array,\n    uint16: Uint16Array,\n    uint32: Uint32Array,\n    uint64: globalThis.BigUint64Array,\n    float32: Float32Array,\n    float64: Float64Array,\n    bool: BoolArray,\n};\nconst V2_STRING_REGEX = /v2:([US])(\\d+)/;\nexport function get_ctr(data_type) {\n    if (data_type === \"v2:object\") {\n        return globalThis.Array;\n    }\n    let match = data_type.match(V2_STRING_REGEX);\n    if (match) {\n        let [, kind, chars] = match;\n        // @ts-expect-error\n        return (kind === \"U\" ? UnicodeStringArray : ByteStringArray).bind(null, Number(chars));\n    }\n    let ctr = CONSTRUCTORS[data_type];\n    if (!ctr) {\n        throw new Error(`Unknown or unsupported data_type: ${data_type}`);\n    }\n    return ctr;\n}\n/** Compute strides for 'C' or 'F' ordered array from shape */\nexport function get_strides(shape, order) {\n    return (order === \"C\" ? row_major_stride : col_major_stride)(shape);\n}\nfunction row_major_stride(shape) {\n    const ndim = shape.length;\n    const stride = globalThis.Array(ndim);\n    for (let i = ndim - 1, step = 1; i >= 0; i--) {\n        stride[i] = step;\n        step *= shape[i];\n    }\n    return stride;\n}\nfunction col_major_stride(shape) {\n    const ndim = shape.length;\n    const stride = globalThis.Array(ndim);\n    for (let i = 0, step = 1; i < ndim; i++) {\n        stride[i] = step;\n        step *= shape[i];\n    }\n    return stride;\n}\nexport function create_chunk_key_encoder({ name, configuration }) {\n    if (name === \"default\") {\n        return (chunk_coords) => [\"c\", ...chunk_coords].join(configuration.separator);\n    }\n    if (name === \"v2\") {\n        return (chunk_coords) => chunk_coords.join(configuration.separator) || \"0\";\n    }\n    throw new Error(`Unknown chunk key encoding: ${name}`);\n}\nexport function get_array_order(codecs) {\n    const maybe_transpose_codec = codecs.find((c) => c.name === \"transpose\");\n    return maybe_transpose_codec?.configuration?.order === \"F\" ? \"F\" : \"C\";\n}\nconst endian_regex = /^([<|>])(.*)$/;\nfunction coerce_dtype(dtype) {\n    if (dtype === \"|O\") {\n        return { data_type: \"v2:object\" };\n    }\n    let match = dtype.match(endian_regex);\n    if (!match) {\n        throw new Error(`Invalid dtype: ${dtype}`);\n    }\n    let [, endian, rest] = match;\n    let data_type = {\n        \"b1\": \"bool\",\n        \"i1\": \"int8\",\n        \"u1\": \"uint8\",\n        \"i2\": \"int16\",\n        \"u2\": \"uint16\",\n        \"i4\": \"int32\",\n        \"u4\": \"uint32\",\n        \"i8\": \"int64\",\n        \"u8\": \"uint64\",\n        \"f4\": \"float32\",\n        \"f8\": \"float64\",\n    }[rest] ??\n        (rest.startsWith(\"S\") || rest.startsWith(\"U\") ? `v2:${rest}` : undefined);\n    if (!data_type) {\n        throw new Error(`Unsupported or unknown dtype: ${dtype}`);\n    }\n    if (endian === \"|\") {\n        return { data_type };\n    }\n    return { data_type, endian: endian === \"<\" ? \"little\" : \"big\" };\n}\nexport const v2_marker = Symbol(\"v2\");\nexport function v2_to_v3_array_metadata(meta, attributes = {}) {\n    let codecs = [];\n    let dtype = coerce_dtype(meta.dtype);\n    if (meta.order === \"F\") {\n        codecs.push({ name: \"transpose\", configuration: { order: \"F\" } });\n    }\n    if (\"endian\" in dtype && dtype.endian === \"big\") {\n        codecs.push({ name: \"endian\", configuration: { endian: \"big\" } });\n    }\n    for (let { id, ...configuration } of meta.filters ?? []) {\n        codecs.push({ name: id, configuration });\n    }\n    if (meta.compressor) {\n        let { id, ...configuration } = meta.compressor;\n        codecs.push({ name: id, configuration });\n    }\n    return {\n        zarr_format: 3,\n        node_type: \"array\",\n        shape: meta.shape,\n        data_type: dtype.data_type,\n        chunk_grid: {\n            name: \"regular\",\n            configuration: {\n                chunk_shape: meta.chunks,\n            },\n        },\n        chunk_key_encoding: {\n            name: \"v2\",\n            configuration: {\n                separator: meta.dimension_separator ?? \".\",\n            },\n        },\n        codecs,\n        fill_value: meta.fill_value,\n        attributes,\n    };\n}\nexport function v2_to_v3_group_metadata(_meta, attributes = {}) {\n    return {\n        zarr_format: 3,\n        node_type: \"group\",\n        attributes,\n    };\n}\nexport function is_dtype(dtype, query) {\n    if (query !== \"number\" &&\n        query !== \"bigint\" &&\n        query !== \"boolean\" &&\n        query !== \"object\" &&\n        query !== \"string\") {\n        return dtype === query;\n    }\n    let is_boolean = dtype === \"bool\";\n    if (query === \"boolean\")\n        return is_boolean;\n    let is_string = dtype.startsWith(\"v2:U\") || dtype.startsWith(\"v2:S\");\n    if (query === \"string\")\n        return is_string;\n    let is_bigint = dtype === \"int64\" || dtype === \"uint64\";\n    if (query === \"bigint\")\n        return is_bigint;\n    let is_object = dtype === \"v2:object\";\n    if (query === \"object\")\n        return is_object;\n    return !is_string && !is_bigint && !is_boolean && !is_object;\n}\nexport function is_sharding_codec(codec) {\n    return codec?.name === \"sharding_indexed\";\n}\nexport function ensure_correct_scalar(metadata) {\n    if ((metadata.data_type === \"uint64\" || metadata.data_type === \"int64\") &&\n        metadata.fill_value != undefined) {\n        return BigInt(metadata.fill_value);\n    }\n    return metadata.fill_value;\n}\n","import { product, range, slice } from \"./util.js\";\nexport class IndexError extends Error {\n    constructor(msg) {\n        super(msg);\n        this.name = \"IndexError\";\n    }\n}\nfunction err_too_many_indices(selection, shape) {\n    throw new IndexError(`too many indicies for array; expected ${shape.length}, got ${selection.length}`);\n}\nfunction err_boundscheck(dim_len) {\n    throw new IndexError(`index out of bounds for dimension with length ${dim_len}`);\n}\nfunction err_negative_step() {\n    throw new IndexError(\"only slices with step >= 1 are supported\");\n}\nfunction check_selection_length(selection, shape) {\n    if (selection.length > shape.length) {\n        err_too_many_indices(selection, shape);\n    }\n}\nexport function normalize_integer_selection(dim_sel, dim_len) {\n    // normalize type to int\n    dim_sel = Math.trunc(dim_sel);\n    // handle wraparound\n    if (dim_sel < 0) {\n        dim_sel = dim_len + dim_sel;\n    }\n    // handle out of bounds\n    if (dim_sel >= dim_len || dim_sel < 0) {\n        err_boundscheck(dim_len);\n    }\n    return dim_sel;\n}\nclass IntDimIndexer {\n    dim_sel;\n    dim_len;\n    dim_chunk_len;\n    nitems;\n    constructor({ dim_sel, dim_len, dim_chunk_len }) {\n        // normalize\n        dim_sel = normalize_integer_selection(dim_sel, dim_len);\n        // store properties\n        this.dim_sel = dim_sel;\n        this.dim_len = dim_len;\n        this.dim_chunk_len = dim_chunk_len;\n        this.nitems = 1;\n    }\n    *[Symbol.iterator]() {\n        const dim_chunk_ix = Math.floor(this.dim_sel / this.dim_chunk_len);\n        const dim_offset = dim_chunk_ix * this.dim_chunk_len;\n        const dim_chunk_sel = this.dim_sel - dim_offset;\n        yield { dim_chunk_ix, dim_chunk_sel };\n    }\n}\nclass SliceDimIndexer {\n    start;\n    stop;\n    step;\n    dim_len;\n    dim_chunk_len;\n    nitems;\n    nchunks;\n    constructor({ dim_sel, dim_len, dim_chunk_len }) {\n        // normalize\n        const [start, stop, step] = dim_sel.indices(dim_len);\n        this.start = start;\n        this.stop = stop;\n        this.step = step;\n        if (this.step < 1)\n            err_negative_step();\n        // store properties\n        this.dim_len = dim_len;\n        this.dim_chunk_len = dim_chunk_len;\n        this.nitems = Math.max(0, Math.ceil((this.stop - this.start) / this.step));\n        this.nchunks = Math.ceil(this.dim_len / this.dim_chunk_len);\n    }\n    *[Symbol.iterator]() {\n        // figure out the range of chunks we need to visit\n        const dim_chunk_ix_from = Math.floor(this.start / this.dim_chunk_len);\n        const dim_chunk_ix_to = Math.ceil(this.stop / this.dim_chunk_len);\n        for (const dim_chunk_ix of range(dim_chunk_ix_from, dim_chunk_ix_to)) {\n            // compute offsets for chunk within overall array\n            const dim_offset = dim_chunk_ix * this.dim_chunk_len;\n            const dim_limit = Math.min(this.dim_len, (dim_chunk_ix + 1) * this.dim_chunk_len);\n            // determine chunk length, accounting for trailing chunk\n            const dim_chunk_len = dim_limit - dim_offset;\n            let dim_out_offset = 0;\n            let dim_chunk_sel_start = 0;\n            if (this.start < dim_offset) {\n                // selection start before current chunk\n                const remainder = (dim_offset - this.start) % this.step;\n                if (remainder)\n                    dim_chunk_sel_start += this.step - remainder;\n                // compute number of previous items, provides offset into output array\n                dim_out_offset = Math.ceil((dim_offset - this.start) / this.step);\n            }\n            else {\n                // selection starts within current chunk\n                dim_chunk_sel_start = this.start - dim_offset;\n            }\n            // selection starts within current chunk if true,\n            // otherwise selection ends after current chunk.\n            const dim_chunk_sel_stop = this.stop > dim_limit\n                ? dim_chunk_len\n                : this.stop - dim_offset;\n            const dim_chunk_sel = [\n                dim_chunk_sel_start,\n                dim_chunk_sel_stop,\n                this.step,\n            ];\n            const dim_chunk_nitems = Math.ceil((dim_chunk_sel_stop - dim_chunk_sel_start) / this.step);\n            const dim_out_sel = [\n                dim_out_offset,\n                dim_out_offset + dim_chunk_nitems,\n                1,\n            ];\n            yield { dim_chunk_ix, dim_chunk_sel, dim_out_sel };\n        }\n    }\n}\nexport function normalize_selection(selection, shape) {\n    let normalized = [];\n    if (selection === null) {\n        normalized = shape.map((_) => slice(null));\n    }\n    else if (Array.isArray(selection)) {\n        normalized = selection.map((s) => s ?? slice(null));\n    }\n    check_selection_length(normalized, shape);\n    return normalized;\n}\nexport class BasicIndexer {\n    dim_indexers;\n    shape;\n    constructor({ selection, shape, chunk_shape }) {\n        // setup per-dimension indexers\n        this.dim_indexers = normalize_selection(selection, shape).map((dim_sel, i) => {\n            return new (typeof dim_sel === \"number\"\n                ? IntDimIndexer\n                : SliceDimIndexer)({\n                // @ts-expect-error ts inference not strong enough to know correct chunk\n                dim_sel: dim_sel,\n                dim_len: shape[i],\n                dim_chunk_len: chunk_shape[i],\n            });\n        });\n        this.shape = this.dim_indexers\n            .filter((ixr) => ixr instanceof SliceDimIndexer)\n            .map((sixr) => sixr.nitems);\n    }\n    *[Symbol.iterator]() {\n        for (const dim_projections of product(...this.dim_indexers)) {\n            const chunk_coords = dim_projections.map((p) => p.dim_chunk_ix);\n            const mapping = dim_projections.map((p) => {\n                if (\"dim_out_sel\" in p) {\n                    return { from: p.dim_chunk_sel, to: p.dim_out_sel };\n                }\n                return { from: p.dim_chunk_sel, to: null };\n            });\n            yield { chunk_coords, mapping };\n        }\n    }\n}\n","import { BoolArray, ByteStringArray, UnicodeStringArray, } from \"@zarrita/typedarray\";\nimport { get as get_with_setter } from \"./get.js\";\nimport { set as set_with_setter } from \"./set.js\";\nfunction object_array_proxy(arr, offset = 0, lengthArg) {\n    let length = lengthArg ?? arr.length - offset;\n    return new Proxy(arr, {\n        get(target, prop) {\n            let idx = +prop;\n            if (!Number.isNaN(idx)) {\n                return target[offset + idx];\n            }\n            if (prop === \"subarray\") {\n                return (from, to = length) => {\n                    return object_array_proxy(target, offset + from, to - from);\n                };\n            }\n            if (prop === \"set\") {\n                return (source, start) => {\n                    for (let i = 0; i < source.length; i++) {\n                        target[offset + start + i] = source[i];\n                    }\n                };\n            }\n            return Reflect.get(target, prop);\n        },\n        set(target, idx, value) {\n            target[offset + Number(idx)] = value;\n            return true;\n        },\n    });\n}\nfunction string_array_proxy(arr) {\n    const StringArrayConstructor = arr.constructor.bind(null, arr.chars);\n    return new Proxy(arr, {\n        get(target, prop) {\n            let idx = +prop;\n            if (!Number.isNaN(idx)) {\n                return target.get(idx);\n            }\n            if (prop === \"subarray\") {\n                return (from, to = arr.length) => {\n                    return string_array_proxy(new StringArrayConstructor(target.buffer, target.byteOffset + arr.BYTES_PER_ELEMENT * from, to - from));\n                };\n            }\n            if (prop === \"set\") {\n                return (source, offset) => {\n                    for (let i = 0; i < source.length; i++) {\n                        target.set(offset + i, source.get(i));\n                    }\n                };\n            }\n            if (prop === \"fill\") {\n                return (value, start, end) => {\n                    for (let i = start; i < end; i++) {\n                        target.set(i, value);\n                    }\n                };\n            }\n            return Reflect.get(target, prop);\n        },\n        set(target, idx, value) {\n            target.set(Number(idx), value);\n            return true;\n        },\n    });\n}\nfunction compat(arr) {\n    let data = arr.data;\n    if (arr.data instanceof BoolArray) {\n        data = new Uint8Array(arr.data.buffer);\n    }\n    else if (arr.data instanceof ByteStringArray ||\n        arr.data instanceof UnicodeStringArray) {\n        data = string_array_proxy(arr.data);\n    }\n    else if (arr.data instanceof globalThis.Array) {\n        data = object_array_proxy(arr.data);\n    }\n    return {\n        data,\n        stride: arr.stride,\n    };\n}\nfunction cast_scalar(arr, value) {\n    if (arr.data instanceof BoolArray) {\n        return (value ? 1 : 0);\n    }\n    return value;\n}\nexport const setter = {\n    prepare(data, shape, stride) {\n        return { data, shape, stride };\n    },\n    set_scalar(dest, sel, value) {\n        set_scalar(compat(dest), sel, cast_scalar(dest, value));\n    },\n    set_from_chunk(dest, src, mapping) {\n        set_from_chunk(compat(dest), compat(src), mapping);\n    },\n};\n/** @category Utility */\nexport async function get(arr, selection = null, opts = {}) {\n    return get_with_setter(arr, selection, opts, setter);\n}\n/** @category Utility */\nexport async function set(arr, selection, value, opts = {}) {\n    return set_with_setter(arr, selection, value, opts, setter);\n}\nfunction indices_len(start, stop, step) {\n    if (step < 0 && stop < start) {\n        return Math.floor((start - stop - 1) / -step) + 1;\n    }\n    if (start < stop)\n        return Math.floor((stop - start - 1) / step) + 1;\n    return 0;\n}\nfunction set_scalar(out, out_selection, value) {\n    if (out_selection.length === 0) {\n        out.data[0] = value;\n        return;\n    }\n    const [slice, ...slices] = out_selection;\n    const [curr_stride, ...stride] = out.stride;\n    if (typeof slice === \"number\") {\n        const data = out.data.subarray(curr_stride * slice);\n        set_scalar({ data, stride }, slices, value);\n        return;\n    }\n    const [from, to, step] = slice;\n    const len = indices_len(from, to, step);\n    if (slices.length === 0) {\n        if (step === 1 && curr_stride === 1) {\n            out.data.fill(value, from, from + len);\n        }\n        else {\n            for (let i = 0; i < len; i++) {\n                out.data[curr_stride * (from + step * i)] = value;\n            }\n        }\n        return;\n    }\n    for (let i = 0; i < len; i++) {\n        const data = out.data.subarray(curr_stride * (from + step * i));\n        set_scalar({ data, stride }, slices, value);\n    }\n}\nfunction set_from_chunk(dest, src, projections) {\n    const [proj, ...projs] = projections;\n    const [dstride, ...dstrides] = dest.stride;\n    const [sstride, ...sstrides] = src.stride;\n    if (proj.from === null) {\n        if (projs.length === 0) {\n            dest.data[proj.to] = src.data[0];\n            return;\n        }\n        set_from_chunk({\n            data: dest.data.subarray(dstride * proj.to),\n            stride: dstrides,\n        }, src, projs);\n        return;\n    }\n    if (proj.to === null) {\n        if (projs.length === 0) {\n            dest.data[0] = src.data[proj.from];\n            return;\n        }\n        let view = {\n            data: src.data.subarray(sstride * proj.from),\n            stride: sstrides,\n        };\n        set_from_chunk(dest, view, projs);\n        return;\n    }\n    const [from, to, step] = proj.to;\n    const [sfrom, _, sstep] = proj.from;\n    const len = indices_len(from, to, step);\n    if (projs.length === 0) {\n        if (step === 1 && sstep === 1 && dstride === 1 && sstride === 1) {\n            dest.data.set(src.data.subarray(sfrom, sfrom + len), from);\n        }\n        else {\n            for (let i = 0; i < len; i++) {\n                dest.data[dstride * (from + step * i)] =\n                    src.data[sstride * (sfrom + sstep * i)];\n            }\n        }\n        return;\n    }\n    for (let i = 0; i < len; i++) {\n        set_from_chunk({\n            data: dest.data.subarray(dstride * (from + i * step)),\n            stride: dstrides,\n        }, {\n            data: src.data.subarray(sstride * (sfrom + i * sstep)),\n            stride: sstrides,\n        }, projs);\n    }\n}\n","import { _internal_get_array_context, KeyError } from \"@zarrita/core\";\nimport { BasicIndexer } from \"./indexer.js\";\nimport { create_queue } from \"./util.js\";\nfunction unwrap(arr, idx) {\n    return \"get\" in arr ? arr.get(idx) : arr[idx];\n}\nexport async function get(arr, selection, opts, setter) {\n    const context = _internal_get_array_context(arr);\n    const indexer = new BasicIndexer({\n        selection,\n        shape: arr.shape,\n        chunk_shape: arr.chunks,\n    });\n    const out = setter.prepare(new context.TypedArray(indexer.shape.reduce((a, b) => a * b, 1)), indexer.shape, context.get_strides(indexer.shape, opts.order));\n    const queue = opts.create_queue?.() ?? create_queue();\n    for (const { chunk_coords, mapping } of indexer) {\n        queue.add(() => arr.getChunk(chunk_coords, opts.opts)\n            .then(({ data, shape, stride }) => {\n            const chunk = setter.prepare(data, shape, stride);\n            setter.set_from_chunk(out, chunk, mapping);\n        })\n            .catch((err) => {\n            // re-throw error if not a missing chunk\n            if (!(err instanceof KeyError))\n                throw err;\n            // KeyError, we need to fill the corresponding array\n            if (context.fill_value) {\n                setter.set_scalar(out, mapping\n                    .map((m) => m.to)\n                    .filter((s) => s !== null), context.fill_value);\n            }\n        }));\n    }\n    await queue.onIdle();\n    // If the final out shape is empty, we just return a scalar.\n    return indexer.shape.length === 0 ? unwrap(out.data, 0) : out;\n}\n","/** Similar to python's `range` function. Supports positive ranges only. */\nexport function* range(start, stop, step = 1) {\n    if (stop === undefined) {\n        stop = start;\n        start = 0;\n    }\n    for (let i = start; i < stop; i += step) {\n        yield i;\n    }\n}\n/**\n * python-like itertools.product generator\n * https://gist.github.com/cybercase/db7dde901d7070c98c48\n */\nexport function* product(...iterables) {\n    if (iterables.length === 0) {\n        return;\n    }\n    // make a list of iterators from the iterables\n    const iterators = iterables.map((it) => it[Symbol.iterator]());\n    const results = iterators.map((it) => it.next());\n    if (results.some((r) => r.done)) {\n        throw new Error(\"Input contains an empty iterator.\");\n    }\n    for (let i = 0;;) {\n        if (results[i].done) {\n            // reset the current iterator\n            iterators[i] = iterables[i][Symbol.iterator]();\n            results[i] = iterators[i].next();\n            // advance, and exit if we've reached the end\n            if (++i >= iterators.length) {\n                return;\n            }\n        }\n        else {\n            yield results.map(({ value }) => value);\n            i = 0;\n        }\n        results[i] = iterators[i].next();\n    }\n}\n// https://github.com/python/cpython/blob/263c0dd16017613c5ea2fbfc270be4de2b41b5ad/Objects/sliceobject.c#L376-L519\nfunction slice_indices(start, stop, step, length) {\n    if (step === 0) {\n        throw new Error(\"slice step cannot be zero\");\n    }\n    step = step ?? 1;\n    const step_is_negative = step < 0;\n    /* Find lower and upper bounds for start and stop. */\n    const [lower, upper] = step_is_negative ? [-1, length - 1] : [0, length];\n    /* Compute start. */\n    if (start === null) {\n        start = step_is_negative ? upper : lower;\n    }\n    else {\n        if (start < 0) {\n            start += length;\n            if (start < lower) {\n                start = lower;\n            }\n        }\n        else if (start > upper) {\n            start = upper;\n        }\n    }\n    /* Compute stop. */\n    if (stop === null) {\n        stop = step_is_negative ? lower : upper;\n    }\n    else {\n        if (stop < 0) {\n            stop += length;\n            if (stop < lower) {\n                stop = lower;\n            }\n        }\n        else if (stop > upper) {\n            stop = upper;\n        }\n    }\n    return [start, stop, step];\n}\nexport function slice(start, stop, step = null) {\n    if (stop === undefined) {\n        stop = start;\n        start = null;\n    }\n    return {\n        start,\n        stop,\n        step,\n        indices(length) {\n            return slice_indices(this.start, this.stop, this.step, length);\n        },\n    };\n}\n/** Built-in \"queue\" for awaiting promises. */\nexport function create_queue() {\n    const promises = [];\n    return {\n        add: (fn) => promises.push(fn()),\n        onIdle: () => Promise.all(promises),\n    };\n}\n","export function strip_prefix(path) {\n    return path.slice(1);\n}\nexport function uri2href(url) {\n    let [protocol, rest] = (typeof url === \"string\" ? url : url.href).split(\"://\");\n    if (protocol === \"https\" || protocol === \"http\") {\n        return url;\n    }\n    if (protocol === \"gc\") {\n        return `https://storage.googleapis.com/${rest}`;\n    }\n    if (protocol === \"s3\") {\n        return `https://s3.amazonaws.com/${rest}`;\n    }\n    throw Error(\"Protocol not supported, got: \" + JSON.stringify(protocol));\n}\nexport function fetch_range(url, offset, length, opts = {}) {\n    if (offset !== undefined && length !== undefined) {\n        // merge request opts\n        opts = {\n            ...opts,\n            headers: {\n                ...opts.headers,\n                Range: `bytes=${offset}-${offset + length - 1}`,\n            },\n        };\n    }\n    return fetch(url, opts);\n}\n","import { fetch_range } from \"./util.js\";\nfunction resolve(root, path) {\n    const base = typeof root === \"string\" ? new URL(root) : root;\n    if (!base.pathname.endsWith(\"/\")) {\n        // ensure trailing slash so that base is resolved as _directory_\n        base.pathname += \"/\";\n    }\n    const resolved = new URL(path.slice(1), base);\n    // copy search params to new URL\n    resolved.search = base.search;\n    return resolved;\n}\nasync function handle_response(response) {\n    if (response.status === 404 || response.status === 403) {\n        return undefined;\n    }\n    if (response.status == 200 || response.status == 206) {\n        return new Uint8Array(await response.arrayBuffer());\n    }\n    throw new Error(`Unexpected response status ${response.status} ${response.statusText}`);\n}\nasync function fetch_suffix(url, suffix_length, init, use_suffix_request) {\n    if (use_suffix_request) {\n        return fetch(url, {\n            ...init,\n            headers: { ...init.headers, Range: `bytes=-${suffix_length}` },\n        });\n    }\n    let response = await fetch(url, { ...init, method: \"HEAD\" });\n    if (!response.ok) {\n        // will be picked up by handle_response\n        return response;\n    }\n    let content_length = response.headers.get(\"Content-Length\");\n    let length = Number(content_length);\n    return fetch_range(url, length - suffix_length, length, init);\n}\n/**\n * Readonly store based in the [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).\n * Must polyfill `fetch` for use in Node.js.\n *\n * ```typescript\n * import * as zarr from \"@zarrita/core\";\n * const store = new FetchStore(\"http://localhost:8080/data.zarr\");\n * const arr = await zarr.get(store, { kind: \"array\" });\n * ```\n */\nclass FetchStore {\n    url;\n    #overrides;\n    #use_suffix_request;\n    constructor(url, options = {}) {\n        this.url = url;\n        this.#overrides = options.overrides ?? {};\n        this.#use_suffix_request = options.useSuffixRequest ?? false;\n    }\n    #merge_init(overrides) {\n        return {\n            ...this.#overrides,\n            ...overrides,\n            headers: {\n                ...this.#overrides.headers,\n                ...overrides.headers,\n            },\n        };\n    }\n    async get(key, options = {}) {\n        let href = resolve(this.url, key).href;\n        let response = await fetch(href, this.#merge_init(options));\n        return handle_response(response);\n    }\n    async getRange(key, range, options = {}) {\n        let url = resolve(this.url, key);\n        let init = this.#merge_init(options);\n        let response;\n        if (\"suffixLength\" in range) {\n            response = await fetch_suffix(url, range.suffixLength, init, this.#use_suffix_request);\n        }\n        else {\n            response = await fetch_range(url, range.offset, range.length, init);\n        }\n        return handle_response(response);\n    }\n}\nexport default FetchStore;\n","export class BoolArray {\n\t/** @type {Uint8Array} */\n\t#bytes;\n\n\t/**\n\t * @constructor\n\t * @overload\n\t * @param {number} size\n\t *\n\t * @constructor\n\t * @overload\n\t * @param {ArrayBuffer} buffer\n\t * @param {number=} byteOffset\n\t * @param {number=} length\n\t *\n\t * @constructor\n\t * @overload\n\t * @param {Iterable<boolean>} arr\n\t *\n\t * @constructor\n\t * @param {number | Iterable<boolean> | ArrayBuffer} x\n\t * @param {number} [byteOffset]\n\t * @param {number} [length]\n\t */\n\tconstructor(x, byteOffset, length) {\n\t\tif (typeof x === \"number\") {\n\t\t\tthis.#bytes = new Uint8Array(x);\n\t\t} else if (x instanceof ArrayBuffer) {\n\t\t\tthis.#bytes = new Uint8Array(x, byteOffset, length);\n\t\t} else {\n\t\t\tthis.#bytes = new Uint8Array(Array.from(x, (v) => (v ? 1 : 0)));\n\t\t}\n\t}\n\n\tget BYTES_PER_ELEMENT() {\n\t\treturn 1;\n\t}\n\n\tget byteOffset() {\n\t\treturn this.#bytes.byteOffset;\n\t}\n\n\tget byteLength() {\n\t\treturn this.#bytes.byteLength;\n\t}\n\n\t/** @type {ArrayBuffer} */\n\tget buffer() {\n\t\treturn this.#bytes.buffer;\n\t}\n\n\t/** @type {number} */\n\tget length() {\n\t\treturn this.#bytes.length;\n\t}\n\n\t/**\n\t * @param {number} idx\n\t * @returns {boolean}\n\t */\n\tget(idx) {\n\t\tlet value = this.#bytes[idx];\n\t\treturn typeof value === \"number\" ? value !== 0 : value;\n\t}\n\n\t/**\n\t * @param {number} idx\n\t * @param {boolean} value\n\t * @returns {void}\n\t */\n\tset(idx, value) {\n\t\tthis.#bytes[idx] = value ? 1 : 0;\n\t}\n\n\t/**\n\t * @param {boolean} value\n\t * @returns {void}\n\t */\n\tfill(value) {\n\t\tthis.#bytes.fill(value ? 1 : 0);\n\t}\n\n\t/**\n\t * @returns {IterableIterator<boolean>}\n\t */\n\t*[Symbol.iterator]() {\n\t\tfor (let i = 0; i < this.length; i++) {\n\t\t\tyield this.get(i);\n\t\t}\n\t}\n}\n\nexport class ByteStringArray {\n\t/** @type {Uint8Array} */\n\t_data;\n\n\t/**\n\t * @constructor\n\t * @overload\n\t * @param {number} chars\n\t * @param {number} size\n\t *\n\t * @constructor\n\t * @overload\n\t * @param {number} chars\n\t * @param {ArrayBuffer} buffer\n\t * @param {number=} byteOffset\n\t * @param {number=} length\n\t *\n\t * @constructor\n\t * @overload\n\t * @param {number} chars\n\t * @param {Iterable<string>} arr\n\t *\n\t * @constructor\n\t * @param {number} chars\n\t * @param {number | ArrayBuffer | Iterable<string>} x\n\t * @param {number=} byteOffset\n\t * @param {number=} length\n\t */\n\tconstructor(chars, x, byteOffset, length) {\n\t\tthis.chars = chars;\n\t\tif (typeof x === \"number\") {\n\t\t\tthis._data = new Uint8Array(x * chars);\n\t\t} else if (x instanceof ArrayBuffer) {\n\t\t\tif (length) length = length * chars;\n\t\t\tthis._data = new Uint8Array(x, byteOffset, length);\n\t\t} else {\n\t\t\tlet values = Array.from(x);\n\t\t\tthis._data = new Uint8Array(values.length * chars);\n\t\t\tfor (let i = 0; i < values.length; i++) {\n\t\t\t\tthis.set(i, values[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tget BYTES_PER_ELEMENT() {\n\t\treturn this.chars;\n\t}\n\n\tget byteOffset() {\n\t\treturn this._data.byteOffset;\n\t}\n\n\tget byteLength() {\n\t\treturn this._data.byteLength;\n\t}\n\n\t/** @type {ArrayBuffer} */\n\tget buffer() {\n\t\treturn this._data.buffer;\n\t}\n\n\t/** @type {number} */\n\tget length() {\n\t\treturn this.byteLength / this.BYTES_PER_ELEMENT;\n\t}\n\n\t/**\n\t * @param {number} idx\n\t * @returns {string}\n\t */\n\tget(idx) {\n\t\tconst view = new Uint8Array(\n\t\t\tthis.buffer,\n\t\t\tthis.byteOffset + this.chars * idx,\n\t\t\tthis.chars,\n\t\t);\n\t\treturn new TextDecoder().decode(view).replace(/\\x00/g, \"\");\n\t}\n\n\t/**\n\t * @private\n\t *\n\t * @param {string} s\n\t * @returns {Uint8Array}\n\t */\n\t_encode(s) {\n\t\treturn new TextEncoder().encode(s);\n\t}\n\n\t/**\n\t * @param {number} idx\n\t * @param {string} value\n\t * @returns {void}\n\t */\n\tset(idx, value) {\n\t\tconst view = new Uint8Array(\n\t\t\tthis.buffer,\n\t\t\tthis.byteOffset + this.chars * idx,\n\t\t\tthis.chars,\n\t\t);\n\t\tview.fill(0); // clear current\n\t\tview.set(this._encode(value));\n\t}\n\n\t/**\n\t * @param {string} value\n\t * @returns {void}\n\t */\n\tfill(value) {\n\t\tconst encoded = this._encode(value);\n\t\tfor (let i = 0; i < this.length; i++) {\n\t\t\tthis._data.set(encoded, i * this.chars);\n\t\t}\n\t}\n\n\t/** @returns {IterableIterator<string>} */\n\t*[Symbol.iterator]() {\n\t\tfor (let i = 0; i < this.length; i++) {\n\t\t\tyield this.get(i);\n\t\t}\n\t}\n}\n\nexport class UnicodeStringArray {\n\t/** @type {Int32Array} */\n\t_data;\n\n\t/**\n\t * @constructor\n\t * @overload\n\t * @param {number} chars\n\t * @param {number} size\n\t *\n\t * @constructor\n\t * @overload\n\t * @param {number} chars\n\t * @param {ArrayBuffer} buffer\n\t * @param {number=} byteOffset\n\t * @param {number=} length\n\t *\n\t * @constructor\n\t * @overload\n\t * @param {number} chars\n\t * @param {Iterable<string>} arr\n\t *\n\t * @constructor\n\t * @param {number} chars\n\t * @param {number | ArrayBuffer | Iterable<string>} x\n\t * @param {number} [byteOffset]\n\t * @param {number} [length]\n\t */\n\tconstructor(chars, x, byteOffset, length) {\n\t\tthis.chars = chars;\n\t\tif (typeof x === \"number\") {\n\t\t\tthis._data = new Int32Array(x * chars);\n\t\t} else if (x instanceof ArrayBuffer) {\n\t\t\tif (length) length *= chars;\n\t\t\tthis._data = new Int32Array(x, byteOffset, length);\n\t\t} else {\n\t\t\tconst values = x;\n\t\t\tconst encode = this._encode.bind(this);\n\t\t\tthis._data = new Int32Array((function* () {\n\t\t\t\tfor (let str of values) {\n\t\t\t\t\tlet int32 = encode(str);\n\t\t\t\t\tyield* int32;\n\t\t\t\t}\n\t\t\t})());\n\t\t}\n\t}\n\n\tget BYTES_PER_ELEMENT() {\n\t\treturn this._data.BYTES_PER_ELEMENT * this.chars;\n\t}\n\n\tget byteLength() {\n\t\treturn this._data.byteLength;\n\t}\n\n\tget byteOffset() {\n\t\treturn this._data.byteOffset;\n\t}\n\n\t/** @type {ArrayBuffer} */\n\tget buffer() {\n\t\treturn this._data.buffer;\n\t}\n\n\t/** @type {number} */\n\tget length() {\n\t\treturn this._data.length / this.chars;\n\t}\n\n\t/**\n\t * @private\n\t *\n\t * @param {string} s\n\t * @returns {Int32Array}\n\t */\n\t_encode(s) {\n\t\tlet out = new Int32Array(this.chars);\n\t\tfor (let i = 0; i < this.chars; i++) {\n\t\t\tout[i] = s.codePointAt(i) ?? 0;\n\t\t}\n\t\treturn out;\n\t}\n\n\t/**\n\t * @param {number} idx\n\t * @returns {string}\n\t */\n\tget(idx) {\n\t\tconst offset = this.chars * idx;\n\t\tlet result = \"\";\n\t\tfor (let i = 0; i < this.chars; i++) {\n\t\t\tresult += String.fromCodePoint(this._data[offset + i]);\n\t\t}\n\t\treturn result.replace(/\\u0000/g, \"\");\n\t}\n\n\t/**\n\t * @param {number} idx\n\t * @param {string} value\n\t * @returns {void}\n\t */\n\tset(idx, value) {\n\t\tconst offset = this.chars * idx;\n\t\tconst view = this._data.subarray(offset, offset + this.chars);\n\t\tview.fill(0); // clear current\n\t\tview.set(this._encode(value));\n\t}\n\n\t/**\n\t * @param {string} value\n\t * @returns {void}\n\t */\n\tfill(value) {\n\t\tconst encoded = this._encode(value);\n\t\tfor (let i = 0; i < this.length; i++) {\n\t\t\tthis._data.set(encoded, i * this.chars);\n\t\t}\n\t}\n\n\t/** @returns {IterableIterator<string>} */\n\t*[Symbol.iterator]() {\n\t\tfor (let i = 0; i < this.length; i++) {\n\t\t\tyield this.get(i);\n\t\t}\n\t}\n}\n"],"names":["Histogram","constructor","data","this","dataMinBin","dataMaxBin","maxBin","bins","Uint32Array","min","max","binSize","hinfo","calculateHistogram","i","length","pixelCount","findBin","dataValue","dataMin","numBins","binIndex","Math","floor","findBinOfValue","value","getDataMin","getDataMax","getMin","getMax","getNumBins","getBin","getBinRange","findBinOfPercentile","pct","limit","count","findBestFitBins","hmin","findAutoIJBins","pixcount","threshold","hmax","findAutoMinMax","th","b","e","x","arr","fill","item","volumeSize","volumeDims","shape","defaultImageInfo","name","atlasTileDims","subregionSize","subregionOffset","combinedNumChannels","channelNames","channelColors","multiscaleLevel","multiscaleLevelDims","spacing","spaceUnit","timeUnit","dataType","transform","translation","rotation","scale","CImageInfo","imageInfo","currentLevelDims","numChannels","originalSize","physicalPixelSize","spatialUnit","times","timeScale","numMultiscaleLevels","computeAtlasSize","volDims","allEqual","every","v","pushN","val","n","push","directionToIndex","dir","absDir","Number","updateMinMax","minmax","ChunkPrefetchIterator","chunks","tzyxMaxPrefetchOffset","tczyxChunksPerSource","priorityDirections","onlyPriorityDirections","extrema","Infinity","chunk","directionStates","priorityDirectionStates","direction","start","flat","entries","dimension","tczyxIndex","end","endsPerSource","map","chunkDims","sourceEnd","directionState","includes","iterateDirections","directions","offset","filter","Array","isArray","offsetDir","newChunk","slice","Symbol","iterator","baseStore","cache","queue","set","_key","_value","Promise","resolve","getAndCache","key","cacheKey","opts","result","get","insert","some","s","endsWith","options","reportKey","subscriber","keyPrefix","url","URL","fullKey","cacheResult","Uint8Array","addRequest","isPrefetch","getSourceChannelNames","src","omeroMetadata","channels","label","idx","channelOffset","scaleLevels","axesTCZYX","from","_","getDimensionCount","t","c","z","remapAxesToTCZYX","axes","axisNames","forEach","axis","axisIdx","indexOf","type","INVALID_METADATA","noXAxis","orderByDimension","valsTCZYX","orderTCZYX","specLen","orderByTCZYX","valsDimension","defaultValue","getScale","dataset","transforms","coordinateTransformations","undefined","console","warn","scaleTransform","find","compareZarrArraySize","aArr","aTCZYX","bArr","bTCZYX","diffZ","diffY","diffX","aboutEquals","a","abs","scaleTransformsAreEqual","aSrc","aLevel","bSrc","bLevel","aScale","multiscaleMetadata","datasets","bScale","matchSourceScaleLevels","sources","matchedLevels","matchedMetas","scaleIndexes","smallestIdx","smallestSrc","smallestArr","currentIdx","currentSrc","currentArr","ordering","INVALID_MULTI_SOURCE_ZARR","largestT","currentT","matchedScaleLevel","srcIdx","isObjectWithProp","obj","prop","assertMetadataHasProp","assertPropIsArray","validateOMEZarrMetadata","multiscaleIdx","multiscaleMeta","multiscales","multiscaleName","DEFAULT_REQUEST_CANCEL_REASON","RequestQueue","maxActiveRequests","maxLowPriorityRequests","allRequests","Map","activeRequests","Set","queueLowPriority","registerRequest","requestAction","promiseResolve","promiseReject","promise","reject","requestItem","action","addRequestToQueue","lowPriority","has","timeoutId","clearTimeout","dequeue","delayMs","lowPriorityIndex","splice","setTimeout","Error","addRequests","requests","promises","numRequests","size","requestKey","shift","add","then","delete","cancelRequest","cancelReason","queueIndex","cancelAllRequests","keys","hasRequest","requestRunning","SubscribableRequestQueue","nextSubscriberId","subscribers","resolveAll","subscriberId","rejectAll","reason","addSubscriber","catch","existingRequest","rejectSubscription","subscriptions","findIndex","sub","rejecters","removeSubscriber","hasSubscriber","isSubscribed","WorkerMsgType","WorkerResponseResult","WorkerEventType","rebuildLoadSpec","spec","subregion","copy","proxy","Proxy","target","TransposeCodec","configuration","kind","fromConfig","encode","stride","row_major_strides","get_order","order","out","chars","empty_like","n_dims","index","src_data","out_data","src_idx","out_idx","dim","convert_array_order","decode","LITTLE_ENDIAN_OS","buffer","byteOffset","byteLength","system_is_little_endian","bytes_per_element","TypedArray","BYTES_PER_ELEMENT","EndianCodec","meta","data_type","codecs","bytes","endian","Crc32cCodec","VLenUTF8","_chunk","decoder","TextDecoder","view","DataView","getUint32","pos","item_length","registry","m","default","create_codec_pipeline","chunk_metadata","load_codecs","codec","array_to_array","array_to_bytes","bytes_to_bytes","async","chunk_meta","Codec","MAX_BIG_UINT","create_sharded_chunk_getter","location","shard_shape","encode_shard_key","sharding_config","store","getRange","get_range","bind","index_shape","d","chunk_shape","index_codec","index_codecs","chunk_coord","shard_coord","shard_path","path","checksum_size","index_size","reduce","suffixLength","linear_offset","acc","sel","Location","root","pathname","Group","metadata","super","attrs","attributes","CONTEXT_MARKER","get_context","fill_value","shared_context","encode_chunk_key","chunk_key_encoding","native_order","get_strides","get_chunk_bytes","chunk_grid","chunk_coords","chunk_key","chunk_path","create_context","dtype","getChunk","context","maybe_bytes","is","query","open_v2","loc","meta_bytes","load_attrs","open_array_v2","open_group_v2","err","open_v3","node","meta_doc","node_type","BigInt","_open_v3","open","v2","v3","json_decode_object","str","JSON","parse","byteswap_inplace","numFlips","endByteIndex","j","CONSTRUCTORS","int8","Int8Array","int16","Int16Array","int32","Int32Array","int64","globalThis","BigInt64Array","uint8","uint16","Uint16Array","uint32","uint64","BigUint64Array","float32","Float32Array","float64","Float64Array","bool","V2_STRING_REGEX","get_ctr","match","ctr","row_major_stride","col_major_stride","ndim","step","create_chunk_key_encoder","join","separator","get_array_order","maybe_transpose_codec","endian_regex","v2_to_v3_array_metadata","rest","startsWith","coerce_dtype","id","filters","compressor","zarr_format","dimension_separator","v2_to_v3_group_metadata","_meta","is_dtype","is_boolean","is_string","is_bigint","is_object","is_sharding_codec","ensure_correct_scalar","IndexError","msg","IntDimIndexer","dim_sel","dim_len","dim_chunk_len","nitems","trunc","err_boundscheck","normalize_integer_selection","dim_chunk_ix","dim_offset","dim_chunk_sel","SliceDimIndexer","stop","nchunks","indices","err_negative_step","ceil","dim_chunk_ix_from","dim_chunk_ix_to","dim_limit","dim_out_offset","dim_chunk_sel_start","remainder","dim_chunk_sel_stop","dim_out_sel","BasicIndexer","dim_indexers","selection","normalized","err_too_many_indices","check_selection_length","normalize_selection","ixr","sixr","dim_projections","p","mapping","to","object_array_proxy","lengthArg","isNaN","source","Reflect","string_array_proxy","StringArrayConstructor","compat","setter","prepare","set_scalar","dest","cast_scalar","set_from_chunk","indexer","create_queue","onIdle","unwrap","indices_len","out_selection","slices","curr_stride","subarray","len","projections","proj","projs","dstride","dstrides","sstride","sstrides","sfrom","sstep","range","product","iterables","iterators","it","results","next","r","done","step_is_negative","lower","upper","slice_indices","fn","all","fetch_range","headers","Range","fetch","base","resolved","search","handle_response","response","status","arrayBuffer","statusText","overrides","useSuffixRequest","href","init","suffix_length","use_suffix_request","method","ok","content_length","fetch_suffix","BoolArray","ArrayBuffer","ByteStringArray","_data","values","replace","_encode","TextEncoder","encoded","UnicodeStringArray","codePointAt","String","fromCodePoint"],"sourceRoot":""}