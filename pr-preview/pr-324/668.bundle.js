(()=>{var __webpack_modules__={8625:()=>{eval("/* (ignored) */\n\n//# sourceURL=webpack://@aics/web-3d-viewer/http_(ignored)?")},6504:()=>{eval("/* (ignored) */\n\n//# sourceURL=webpack://@aics/web-3d-viewer/https_(ignored)?")},6580:()=>{eval("/* (ignored) */\n\n//# sourceURL=webpack://@aics/web-3d-viewer/url_(ignored)?")},6082:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval("\n// EXTERNAL MODULE: ./node_modules/geotiff/dist-module/geotiff.js\nvar geotiff = __webpack_require__(4276);\n// EXTERNAL MODULE: ./node_modules/serialize-error/error-constructors.js\nvar error_constructors = __webpack_require__(205);\n;// CONCATENATED MODULE: ./node_modules/serialize-error/index.js\n\n\nclass NonError extends Error {\n\tname = 'NonError';\n\n\tconstructor(message) {\n\t\tsuper(NonError._prepareSuperMessage(message));\n\t}\n\n\tstatic _prepareSuperMessage(message) {\n\t\ttry {\n\t\t\treturn JSON.stringify(message);\n\t\t} catch {\n\t\t\treturn String(message);\n\t\t}\n\t}\n}\n\nconst commonProperties = [\n\t{\n\t\tproperty: 'name',\n\t\tenumerable: false,\n\t},\n\t{\n\t\tproperty: 'message',\n\t\tenumerable: false,\n\t},\n\t{\n\t\tproperty: 'stack',\n\t\tenumerable: false,\n\t},\n\t{\n\t\tproperty: 'code',\n\t\tenumerable: true,\n\t},\n\t{\n\t\tproperty: 'cause',\n\t\tenumerable: false,\n\t},\n];\n\nconst toJsonWasCalled = new WeakSet();\n\nconst toJSON = from => {\n\ttoJsonWasCalled.add(from);\n\tconst json = from.toJSON();\n\ttoJsonWasCalled.delete(from);\n\treturn json;\n};\n\nconst getErrorConstructor = name => error_constructors/* default */.A.get(name) ?? Error;\n\n// eslint-disable-next-line complexity\nconst destroyCircular = ({\n\tfrom,\n\tseen,\n\tto,\n\tforceEnumerable,\n\tmaxDepth,\n\tdepth,\n\tuseToJSON,\n\tserialize,\n}) => {\n\tif (!to) {\n\t\tif (Array.isArray(from)) {\n\t\t\tto = [];\n\t\t} else if (!serialize && isErrorLike(from)) {\n\t\t\tconst Error = getErrorConstructor(from.name);\n\t\t\tto = new Error();\n\t\t} else {\n\t\t\tto = {};\n\t\t}\n\t}\n\n\tseen.push(from);\n\n\tif (depth >= maxDepth) {\n\t\treturn to;\n\t}\n\n\tif (useToJSON && typeof from.toJSON === 'function' && !toJsonWasCalled.has(from)) {\n\t\treturn toJSON(from);\n\t}\n\n\tconst continueDestroyCircular = value => destroyCircular({\n\t\tfrom: value,\n\t\tseen: [...seen],\n\t\tforceEnumerable,\n\t\tmaxDepth,\n\t\tdepth,\n\t\tuseToJSON,\n\t\tserialize,\n\t});\n\n\tfor (const [key, value] of Object.entries(from)) {\n\t\tif (value && value instanceof Uint8Array && value.constructor.name === 'Buffer') {\n\t\t\tto[key] = '[object Buffer]';\n\t\t\tcontinue;\n\t\t}\n\n\t\t// TODO: Use `stream.isReadable()` when targeting Node.js 18.\n\t\tif (value !== null && typeof value === 'object' && typeof value.pipe === 'function') {\n\t\t\tto[key] = '[object Stream]';\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (typeof value === 'function') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!value || typeof value !== 'object') {\n\t\t\t// Gracefully handle non-configurable errors like `DOMException`.\n\t\t\ttry {\n\t\t\t\tto[key] = value;\n\t\t\t} catch {}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!seen.includes(from[key])) {\n\t\t\tdepth++;\n\t\t\tto[key] = continueDestroyCircular(from[key]);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tto[key] = '[Circular]';\n\t}\n\n\tfor (const {property, enumerable} of commonProperties) {\n\t\tif (typeof from[property] !== 'undefined' && from[property] !== null) {\n\t\t\tObject.defineProperty(to, property, {\n\t\t\t\tvalue: isErrorLike(from[property]) ? continueDestroyCircular(from[property]) : from[property],\n\t\t\t\tenumerable: forceEnumerable ? true : enumerable,\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t});\n\t\t}\n\t}\n\n\treturn to;\n};\n\nfunction serializeError(value, options = {}) {\n\tconst {\n\t\tmaxDepth = Number.POSITIVE_INFINITY,\n\t\tuseToJSON = true,\n\t} = options;\n\n\tif (typeof value === 'object' && value !== null) {\n\t\treturn destroyCircular({\n\t\t\tfrom: value,\n\t\t\tseen: [],\n\t\t\tforceEnumerable: true,\n\t\t\tmaxDepth,\n\t\t\tdepth: 0,\n\t\t\tuseToJSON,\n\t\t\tserialize: true,\n\t\t});\n\t}\n\n\t// People sometimes throw things besides Error objectsâ€¦\n\tif (typeof value === 'function') {\n\t\t// `JSON.stringify()` discards functions. We do too, unless a function is thrown directly.\n\t\t// We intentionally use `||` because `.name` is an empty string for anonymous functions.\n\t\treturn `[Function: ${value.name || 'anonymous'}]`;\n\t}\n\n\treturn value;\n}\n\nfunction deserializeError(value, options = {}) {\n\tconst {maxDepth = Number.POSITIVE_INFINITY} = options;\n\n\tif (value instanceof Error) {\n\t\treturn value;\n\t}\n\n\tif (isMinimumViableSerializedError(value)) {\n\t\tconst Error = getErrorConstructor(value.name);\n\t\treturn destroyCircular({\n\t\t\tfrom: value,\n\t\t\tseen: [],\n\t\t\tto: new Error(),\n\t\t\tmaxDepth,\n\t\t\tdepth: 0,\n\t\t\tserialize: false,\n\t\t});\n\t}\n\n\treturn new NonError(value);\n}\n\nfunction isErrorLike(value) {\n\treturn Boolean(value)\n\t&& typeof value === 'object'\n\t&& 'name' in value\n\t&& 'message' in value\n\t&& 'stack' in value;\n}\n\nfunction isMinimumViableSerializedError(value) {\n\treturn Boolean(value)\n\t&& typeof value === 'object'\n\t&& 'message' in value\n\t&& !Array.isArray(value);\n}\n\n\n\n// EXTERNAL MODULE: ./node_modules/@zarrita/core/dist/src/errors.js\nvar errors = __webpack_require__(9698);\n;// CONCATENATED MODULE: ./node_modules/@aics/volume-viewer/es/loaders/VolumeLoadError.js\n\n\n// geotiff doesn't export its error types...\n\n/** Groups possible load errors into a few broad categories which we can give similar guidance to the user about. */\nlet VolumeLoadErrorType = /*#__PURE__*/function (VolumeLoadErrorType) {\n  VolumeLoadErrorType[\"UNKNOWN\"] = \"unknown\";\n  VolumeLoadErrorType[\"NOT_FOUND\"] = \"not_found\";\n  VolumeLoadErrorType[\"TOO_LARGE\"] = \"too_large\";\n  VolumeLoadErrorType[\"LOAD_DATA_FAILED\"] = \"load_data_failed\";\n  VolumeLoadErrorType[\"INVALID_METADATA\"] = \"invalid_metadata\";\n  VolumeLoadErrorType[\"INVALID_MULTI_SOURCE_ZARR\"] = \"invalid_multi_source_zarr\";\n  return VolumeLoadErrorType;\n}({});\nclass VolumeLoadError extends Error {\n  constructor(message, options) {\n    super(message, options);\n    this.name = \"VolumeLoadError\";\n    this.type = options?.type ?? VolumeLoadErrorType.UNKNOWN;\n  }\n}\n\n// serialize-error only ever calls an error constructor with zero arguments. The required `ErrorConstructor`\n// type is a bit too restrictive - as long as the constructor can be called with no arguments it's fine.\nerror_constructors/* default */.A.set(\"NodeNotFoundError\", errors/* NodeNotFoundError */._);\nerror_constructors/* default */.A.set(\"KeyError\", errors/* KeyError */.e);\nerror_constructors/* default */.A.set(\"VolumeLoadError\", VolumeLoadError);\n\n/** Curried function to re-throw an error wrapped in a `VolumeLoadError` with the given `message` and `type`. */\nfunction wrapVolumeLoadError(message = \"Unknown error occurred while loading volume data\", type = VolumeLoadErrorType.UNKNOWN, ignore) {\n  return e => {\n    if (ignore !== undefined && e === ignore) {\n      return e;\n    }\n    if (e instanceof VolumeLoadError) {\n      throw e;\n    }\n    console.log(`Error loading volume data: ${e}`);\n    throw new VolumeLoadError(message, {\n      type,\n      cause: e\n    });\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/@aics/volume-viewer/es/workers/FetchTiffWorker.js\n\n\n\n// from TIFF\nconst SAMPLEFORMAT_UINT = 1;\nconst SAMPLEFORMAT_INT = 2;\nconst SAMPLEFORMAT_IEEEFP = 3;\nfunction castToArray(buf, bytesPerPixel, sampleFormat) {\n  if (sampleFormat === SAMPLEFORMAT_IEEEFP) {\n    if (bytesPerPixel === 4) {\n      return new Float32Array(buf);\n    }\n  } else if (sampleFormat === SAMPLEFORMAT_INT) {\n    if (bytesPerPixel === 1) {\n      return new Int8Array(buf);\n    } else if (bytesPerPixel === 2) {\n      return new Int16Array(buf);\n    } else if (bytesPerPixel === 4) {\n      return new Int32Array(buf);\n    }\n  } else if (sampleFormat === SAMPLEFORMAT_UINT) {\n    if (bytesPerPixel === 1) {\n      return new Uint8Array(buf);\n    } else if (bytesPerPixel === 2) {\n      return new Uint16Array(buf);\n    } else if (bytesPerPixel === 4) {\n      return new Uint32Array(buf);\n    }\n  }\n  console.error(`TIFF Worker: unsupported sample format ${sampleFormat} and bytes per pixel ${bytesPerPixel}`);\n  return new Uint8Array(buf);\n}\nasync function loadTiffChannel(e) {\n  // TODO index images by time\n  // const time = e.data.time;\n\n  const channelIndex = e.data.channel;\n  const tilesizex = e.data.tilesizex;\n  const tilesizey = e.data.tilesizey;\n  const sizez = e.data.sizez;\n  const sizec = e.data.sizec;\n  const dimensionOrder = e.data.dimensionOrder;\n  const bytesPerSample = e.data.bytesPerSample;\n  const tiff = await (0,geotiff/* fromUrl */.uz)(e.data.url, {\n    allowFullFile: true\n  });\n\n  // load the images of this channel from the tiff\n  // today assume TCZYX so the slices are already in order.\n  let startindex = 0;\n  let incrementz = 1;\n  if (dimensionOrder === \"XYZCT\") {\n    // we have XYZCT which is the \"good\" case\n    // TCZYX\n    startindex = sizez * channelIndex;\n    incrementz = 1;\n  } else if (dimensionOrder === \"XYCZT\") {\n    // we have to loop differently to increment channels\n    // TZCYX\n    startindex = channelIndex;\n    incrementz = sizec;\n  }\n\n  // huge assumption: planes are in a particular order relative to z and c\n\n  // get first plane, to get some details about the image\n  const image = await tiff.getImage(startindex);\n  // on first image, set up some stuff:\n  const sampleFormat = image.getSampleFormat();\n  const bytesPerPixel = image.getBytesPerPixel();\n  // allocate a buffer for one channel\n  const buffer = new ArrayBuffer(tilesizex * tilesizey * sizez * bytesPerPixel);\n  const u8 = new Uint8Array(buffer);\n  for (let imageIndex = startindex, zslice = 0; zslice < sizez; imageIndex += incrementz, ++zslice) {\n    const image = await tiff.getImage(imageIndex);\n    // download and downsample on client\n    const result = await image.readRasters({\n      width: tilesizex,\n      height: tilesizey\n    });\n    const arrayresult = Array.isArray(result) ? result[0] : result;\n    // deposit in full channel array in the right place\n    const offset = zslice * tilesizex * tilesizey;\n    if (arrayresult.BYTES_PER_ELEMENT > 4) {\n      throw new VolumeLoadError(\"byte size not supported yet: \" + arrayresult.BYTES_PER_ELEMENT, {\n        type: VolumeLoadErrorType.INVALID_METADATA\n      });\n    } else if (arrayresult.BYTES_PER_ELEMENT !== bytesPerSample) {\n      throw new VolumeLoadError(\"tiff bytes per element mismatch with OME metadata\", {\n        type: VolumeLoadErrorType.INVALID_METADATA\n      });\n    } else {\n      u8.set(new Uint8Array(arrayresult.buffer), offset * arrayresult.BYTES_PER_ELEMENT);\n    }\n  }\n  // all slices collected, now resample to 8 bits full data range\n  const src = castToArray(buffer, bytesPerPixel, sampleFormat);\n  let chmin = src[0];\n  let chmax = src[0];\n  for (let j = 0; j < src.length; ++j) {\n    const val = src[j];\n    if (val < chmin) {\n      chmin = val;\n    }\n    if (val > chmax) {\n      chmax = val;\n    }\n  }\n  const out = new Uint8Array(src.length);\n  for (let j = 0; j < src.length; ++j) {\n    out[j] = (src[j] - chmin) / (chmax - chmin) * 255;\n  }\n  return {\n    data: out,\n    channel: channelIndex,\n    range: [chmin, chmax],\n    isError: false\n  };\n}\nself.onmessage = async e => {\n  try {\n    const result = await loadTiffChannel(e);\n    self.postMessage(result, [result.data.buffer]);\n  } catch (err) {\n    self.postMessage({\n      isError: true,\n      error: serializeError(err)\n    });\n  }\n};\n\n//# sourceURL=webpack://@aics/web-3d-viewer/./node_modules/@aics/volume-viewer/es/workers/FetchTiffWorker.js_+_2_modules?")}},__webpack_module_cache__={},deferred,next;function __webpack_require__(e){var r=__webpack_module_cache__[e];if(void 0!==r)return r.exports;var n=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e](n,n.exports,__webpack_require__),n.exports}__webpack_require__.m=__webpack_modules__,__webpack_require__.x=()=>{var e=__webpack_require__.O(void 0,[961],(()=>__webpack_require__(6082)));return __webpack_require__.O(e)},deferred=[],__webpack_require__.O=(e,r,n,t)=>{if(!r){var o=1/0;for(l=0;l<deferred.length;l++){for(var[r,n,t]=deferred[l],a=!0,s=0;s<r.length;s++)(!1&t||o>=t)&&Object.keys(__webpack_require__.O).every((e=>__webpack_require__.O[e](r[s])))?r.splice(s--,1):(a=!1,t<o&&(o=t));if(a){deferred.splice(l--,1);var i=n();void 0!==i&&(e=i)}}return e}t=t||0;for(var l=deferred.length;l>0&&deferred[l-1][2]>t;l--)deferred[l]=deferred[l-1];deferred[l]=[r,n,t]},__webpack_require__.d=(e,r)=>{for(var n in r)__webpack_require__.o(r,n)&&!__webpack_require__.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:r[n]})},__webpack_require__.f={},__webpack_require__.e=e=>Promise.all(Object.keys(__webpack_require__.f).reduce(((r,n)=>(__webpack_require__.f[n](e,r),r)),[])),__webpack_require__.u=e=>e+".bundle.js",__webpack_require__.miniCssF=e=>{},__webpack_require__.o=(e,r)=>Object.prototype.hasOwnProperty.call(e,r),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},__webpack_require__.p="/website-3d-cell-viewer/pr-preview/pr-324/",(()=>{var e={668:1,283:1};__webpack_require__.f.i=(r,n)=>{e[r]||importScripts(__webpack_require__.p+__webpack_require__.u(r))};var r=self.webpackChunk_aics_web_3d_viewer=self.webpackChunk_aics_web_3d_viewer||[],n=r.push.bind(r);r.push=r=>{var[t,o,a]=r;for(var s in o)__webpack_require__.o(o,s)&&(__webpack_require__.m[s]=o[s]);for(a&&a(__webpack_require__);t.length;)e[t.pop()]=1;n(r)}})(),next=__webpack_require__.x,__webpack_require__.x=()=>__webpack_require__.e(961).then(next);var __webpack_exports__=__webpack_require__.x()})();