{"version":3,"file":"423.bundle.js","mappings":"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M,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,MASzgD,SAASC,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","sources":["webpack://@aics/vole-app/./node_modules/serialize-error/index.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/VolumeCache.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/node_modules/three/build/three.core.js","webpack://@aics/vole-app/./node_modules/@zarrita/typedarray/index.js","webpack://@aics/vole-app/./node_modules/@zarrita/core/dist/src/util.js","webpack://@aics/vole-app/./node_modules/@zarrita/core/dist/src/codecs/transpose.js","webpack://@aics/vole-app/./node_modules/@zarrita/core/dist/src/codecs/endian.js","webpack://@aics/vole-app/./node_modules/@zarrita/core/dist/src/codecs/crc32c.js","webpack://@aics/vole-app/./node_modules/@zarrita/core/dist/src/codecs/vlen-utf8.js","webpack://@aics/vole-app/./node_modules/@zarrita/core/dist/src/codecs.js","webpack://@aics/vole-app/./node_modules/@zarrita/core/dist/src/codecs/sharding.js","webpack://@aics/vole-app/./node_modules/@zarrita/core/dist/src/hierarchy.js","webpack://@aics/vole-app/./node_modules/@zarrita/core/dist/src/open.js","webpack://@aics/vole-app/./node_modules/@zarrita/indexing/dist/src/util.js","webpack://@aics/vole-app/./node_modules/@zarrita/indexing/dist/src/indexer.js","webpack://@aics/vole-app/./node_modules/@zarrita/indexing/dist/src/ops.js","webpack://@aics/vole-app/./node_modules/@zarrita/storage/dist/src/util.js","webpack://@aics/vole-app/./node_modules/@zarrita/storage/dist/src/fetch.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/utils/RequestQueue.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/utils/SubscribableRequestQueue.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/Histogram.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/constants/colors.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/Lut.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/types.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/Channel.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/VolumeDims.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/ImageInfo.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/loaders/VolumeLoaderUtils.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/Volume.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/loaders/IVolumeLoader.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/loaders/zarr_utils/ChunkPrefetchIterator.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/loaders/zarr_utils/WrappedStore.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/loaders/VolumeLoadError.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/loaders/zarr_utils/utils.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/loaders/zarr_utils/validation.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/loaders/OmeZarrLoader.js","webpack://@aics/vole-app/./node_modules/@zarrita/indexing/dist/src/get.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/constants/time.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/utils/num_utils.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/loaders/JsonImageInfoLoader.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/loaders/RawArrayLoader.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/loaders/TiffLoader.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/loaders/zarr_utils/types.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/loaders/index.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/workers/types.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/workers/VolumeLoadWorker.js","webpack://@aics/vole-app/./node_modules/@aics/vole-core/es/workers/util.js"],"sourcesContent":["import errorConstructors from './error-constructors.js';\n\nexport class NonError extends Error {\n\tname = 'NonError';\n\n\tconstructor(message) {\n\t\tsuper(NonError._prepareSuperMessage(message));\n\t}\n\n\tstatic _prepareSuperMessage(message) {\n\t\ttry {\n\t\t\treturn JSON.stringify(message);\n\t\t} catch {\n\t\t\treturn String(message);\n\t\t}\n\t}\n}\n\nconst commonProperties = [\n\t{\n\t\tproperty: 'name',\n\t\tenumerable: false,\n\t},\n\t{\n\t\tproperty: 'message',\n\t\tenumerable: false,\n\t},\n\t{\n\t\tproperty: 'stack',\n\t\tenumerable: false,\n\t},\n\t{\n\t\tproperty: 'code',\n\t\tenumerable: true,\n\t},\n\t{\n\t\tproperty: 'cause',\n\t\tenumerable: false,\n\t},\n];\n\nconst toJsonWasCalled = new WeakSet();\n\nconst toJSON = from => {\n\ttoJsonWasCalled.add(from);\n\tconst json = from.toJSON();\n\ttoJsonWasCalled.delete(from);\n\treturn json;\n};\n\nconst getErrorConstructor = name => errorConstructors.get(name) ?? Error;\n\n// eslint-disable-next-line complexity\nconst destroyCircular = ({\n\tfrom,\n\tseen,\n\tto,\n\tforceEnumerable,\n\tmaxDepth,\n\tdepth,\n\tuseToJSON,\n\tserialize,\n}) => {\n\tif (!to) {\n\t\tif (Array.isArray(from)) {\n\t\t\tto = [];\n\t\t} else if (!serialize && isErrorLike(from)) {\n\t\t\tconst Error = getErrorConstructor(from.name);\n\t\t\tto = new Error();\n\t\t} else {\n\t\t\tto = {};\n\t\t}\n\t}\n\n\tseen.push(from);\n\n\tif (depth >= maxDepth) {\n\t\treturn to;\n\t}\n\n\tif (useToJSON && typeof from.toJSON === 'function' && !toJsonWasCalled.has(from)) {\n\t\treturn toJSON(from);\n\t}\n\n\tconst continueDestroyCircular = value => destroyCircular({\n\t\tfrom: value,\n\t\tseen: [...seen],\n\t\tforceEnumerable,\n\t\tmaxDepth,\n\t\tdepth,\n\t\tuseToJSON,\n\t\tserialize,\n\t});\n\n\tfor (const [key, value] of Object.entries(from)) {\n\t\tif (value && value instanceof Uint8Array && value.constructor.name === 'Buffer') {\n\t\t\tto[key] = '[object Buffer]';\n\t\t\tcontinue;\n\t\t}\n\n\t\t// TODO: Use `stream.isReadable()` when targeting Node.js 18.\n\t\tif (value !== null && typeof value === 'object' && typeof value.pipe === 'function') {\n\t\t\tto[key] = '[object Stream]';\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (typeof value === 'function') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!value || typeof value !== 'object') {\n\t\t\t// Gracefully handle non-configurable errors like `DOMException`.\n\t\t\ttry {\n\t\t\t\tto[key] = value;\n\t\t\t} catch {}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!seen.includes(from[key])) {\n\t\t\tdepth++;\n\t\t\tto[key] = continueDestroyCircular(from[key]);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tto[key] = '[Circular]';\n\t}\n\n\tfor (const {property, enumerable} of commonProperties) {\n\t\tif (typeof from[property] !== 'undefined' && from[property] !== null) {\n\t\t\tObject.defineProperty(to, property, {\n\t\t\t\tvalue: isErrorLike(from[property]) ? continueDestroyCircular(from[property]) : from[property],\n\t\t\t\tenumerable: forceEnumerable ? true : enumerable,\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t});\n\t\t}\n\t}\n\n\treturn to;\n};\n\nexport function serializeError(value, options = {}) {\n\tconst {\n\t\tmaxDepth = Number.POSITIVE_INFINITY,\n\t\tuseToJSON = true,\n\t} = options;\n\n\tif (typeof value === 'object' && value !== null) {\n\t\treturn destroyCircular({\n\t\t\tfrom: value,\n\t\t\tseen: [],\n\t\t\tforceEnumerable: true,\n\t\t\tmaxDepth,\n\t\t\tdepth: 0,\n\t\t\tuseToJSON,\n\t\t\tserialize: true,\n\t\t});\n\t}\n\n\t// People sometimes throw things besides Error objects…\n\tif (typeof value === 'function') {\n\t\t// `JSON.stringify()` discards functions. We do too, unless a function is thrown directly.\n\t\t// We intentionally use `||` because `.name` is an empty string for anonymous functions.\n\t\treturn `[Function: ${value.name || 'anonymous'}]`;\n\t}\n\n\treturn value;\n}\n\nexport function deserializeError(value, options = {}) {\n\tconst {maxDepth = Number.POSITIVE_INFINITY} = options;\n\n\tif (value instanceof Error) {\n\t\treturn value;\n\t}\n\n\tif (isMinimumViableSerializedError(value)) {\n\t\tconst Error = getErrorConstructor(value.name);\n\t\treturn destroyCircular({\n\t\t\tfrom: value,\n\t\t\tseen: [],\n\t\t\tto: new Error(),\n\t\t\tmaxDepth,\n\t\t\tdepth: 0,\n\t\t\tserialize: false,\n\t\t});\n\t}\n\n\treturn new NonError(value);\n}\n\nexport function isErrorLike(value) {\n\treturn Boolean(value)\n\t&& typeof value === 'object'\n\t&& 'name' in value\n\t&& 'message' in value\n\t&& 'stack' in value;\n}\n\nfunction isMinimumViableSerializedError(value) {\n\treturn Boolean(value)\n\t&& typeof value === 'object'\n\t&& 'message' in value\n\t&& !Array.isArray(value);\n}\n\nexport {default as errorConstructors} from './error-constructors.js';\n","/** Default: 250MB. Should be large enough to be useful but safe for most any computer that can run the app */\nconst CACHE_MAX_SIZE_DEFAULT = 250_000_000;\nexport default class VolumeCache {\n  // Ends of a linked list of entries, to track LRU and evict efficiently\n\n  // TODO implement some way to manage used vs unused (prefetched) entries so\n  // that prefetched entries which are never used don't get highest priority!\n\n  constructor(maxSize = CACHE_MAX_SIZE_DEFAULT) {\n    this.entries = new Map();\n    this.maxSize = maxSize;\n    this.currentSize = 0;\n    this.first = null;\n    this.last = null;\n  }\n\n  // Hide these behind getters so they're definitely never set from the outside\n  /** The size of all data arrays currently stored in this cache, in bytes. */\n  get size() {\n    return this.currentSize;\n  }\n\n  /** The number of entries currently stored in this cache. */\n  get numberOfEntries() {\n    return this.entries.size;\n  }\n\n  /**\n   * Removes an entry from a store but NOT the LRU list.\n   * Only call from a method with the word \"evict\" in it!\n   */\n  removeEntryFromStore(entry) {\n    this.entries.delete(entry.key);\n    this.currentSize -= entry.data.byteLength;\n  }\n\n  /**\n   * Removes an entry from the LRU list but NOT its store.\n   * Entry must be replaced in list or removed from store, or it will never be evicted!\n   */\n  removeEntryFromList(entry) {\n    const {\n      prev,\n      next\n    } = entry;\n    if (prev) {\n      prev.next = next;\n    } else {\n      this.first = next;\n    }\n    if (next) {\n      next.prev = prev;\n    } else {\n      this.last = prev;\n    }\n  }\n\n  /** Adds an entry which is *not currently in the list* to the front of the list. */\n  addEntryAsFirst(entry) {\n    if (this.first) {\n      this.first.prev = entry;\n    } else {\n      this.last = entry;\n    }\n    entry.next = this.first;\n    entry.prev = null;\n    this.first = entry;\n  }\n\n  /** Moves an entry which is *currently in the list* to the front of the list. */\n  moveEntryToFirst(entry) {\n    if (entry === this.first) return;\n    this.removeEntryFromList(entry);\n    this.addEntryAsFirst(entry);\n  }\n\n  /** Evicts the least recently used entry from the cache. */\n  evictLast() {\n    if (!this.last) {\n      console.error(\"VolumeCache: attempt to evict last entry from cache when no last entry is set\");\n      return;\n    }\n    this.removeEntryFromStore(this.last);\n    if (this.last.prev) {\n      this.last.prev.next = null;\n    }\n    this.last = this.last.prev;\n  }\n\n  /** Evicts a specific entry from the cache. */\n  evict(entry) {\n    this.removeEntryFromStore(entry);\n    this.removeEntryFromList(entry);\n  }\n\n  /**\n   * Adds a new entry to the cache.\n   * @returns {boolean} a boolean indicating whether the insertion succeeded.\n   */\n  insert(key, data) {\n    if (data.byteLength > this.maxSize) {\n      console.error(\"VolumeCache: attempt to insert a single entry larger than the cache\");\n      return false;\n    }\n\n    // Check if entry is already in cache\n    // This will move the entry to the front of the LRU list, if present\n    const getResult = this.getEntry(key);\n    if (getResult !== undefined) {\n      getResult.data = data;\n      return true;\n    }\n\n    // Add new entry to cache\n    const newEntry = {\n      data,\n      prev: null,\n      next: null,\n      key\n    };\n    this.addEntryAsFirst(newEntry);\n    this.entries.set(key, newEntry);\n    this.currentSize += data.byteLength;\n\n    // Evict until size is within limit\n    while (this.currentSize > this.maxSize) {\n      this.evictLast();\n    }\n    return true;\n  }\n\n  /** Internal implementation of `get`. Returns all entry metadata, not just the raw data. */\n  getEntry(key) {\n    const result = this.entries.get(key);\n    if (result) {\n      this.moveEntryToFirst(result);\n    }\n    return result;\n  }\n\n  /** Attempts to get a single entry from the cache. */\n  get(key) {\n    return this.getEntry(key)?.data;\n  }\n\n  /** Clears all cache entries whose keys begin with the specified prefix. */\n  clearWithPrefix(prefix) {\n    for (const [key, entry] of this.entries.entries()) {\n      if (key.startsWith(prefix)) {\n        this.evict(entry);\n      }\n    }\n  }\n\n  /** Clears all data from the cache. */\n  clear() {\n    while (this.last) {\n      this.evictLast();\n    }\n  }\n}","/**\n * @license\n * Copyright 2010-2024 Three.js Authors\n * SPDX-License-Identifier: MIT\n */\nconst REVISION = '171';\n\nconst MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };\nconst TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };\nconst CullFaceNone = 0;\nconst CullFaceBack = 1;\nconst CullFaceFront = 2;\nconst CullFaceFrontBack = 3;\nconst BasicShadowMap = 0;\nconst PCFShadowMap = 1;\nconst PCFSoftShadowMap = 2;\nconst VSMShadowMap = 3;\nconst FrontSide = 0;\nconst BackSide = 1;\nconst DoubleSide = 2;\nconst NoBlending = 0;\nconst NormalBlending = 1;\nconst AdditiveBlending = 2;\nconst SubtractiveBlending = 3;\nconst MultiplyBlending = 4;\nconst CustomBlending = 5;\nconst AddEquation = 100;\nconst SubtractEquation = 101;\nconst ReverseSubtractEquation = 102;\nconst MinEquation = 103;\nconst MaxEquation = 104;\nconst ZeroFactor = 200;\nconst OneFactor = 201;\nconst SrcColorFactor = 202;\nconst OneMinusSrcColorFactor = 203;\nconst SrcAlphaFactor = 204;\nconst OneMinusSrcAlphaFactor = 205;\nconst DstAlphaFactor = 206;\nconst OneMinusDstAlphaFactor = 207;\nconst DstColorFactor = 208;\nconst OneMinusDstColorFactor = 209;\nconst SrcAlphaSaturateFactor = 210;\nconst ConstantColorFactor = 211;\nconst OneMinusConstantColorFactor = 212;\nconst ConstantAlphaFactor = 213;\nconst OneMinusConstantAlphaFactor = 214;\nconst NeverDepth = 0;\nconst AlwaysDepth = 1;\nconst LessDepth = 2;\nconst LessEqualDepth = 3;\nconst EqualDepth = 4;\nconst GreaterEqualDepth = 5;\nconst GreaterDepth = 6;\nconst NotEqualDepth = 7;\nconst MultiplyOperation = 0;\nconst MixOperation = 1;\nconst AddOperation = 2;\nconst NoToneMapping = 0;\nconst LinearToneMapping = 1;\nconst ReinhardToneMapping = 2;\nconst CineonToneMapping = 3;\nconst ACESFilmicToneMapping = 4;\nconst CustomToneMapping = 5;\nconst AgXToneMapping = 6;\nconst NeutralToneMapping = 7;\nconst AttachedBindMode = 'attached';\nconst DetachedBindMode = 'detached';\n\nconst UVMapping = 300;\nconst CubeReflectionMapping = 301;\nconst CubeRefractionMapping = 302;\nconst EquirectangularReflectionMapping = 303;\nconst EquirectangularRefractionMapping = 304;\nconst CubeUVReflectionMapping = 306;\nconst RepeatWrapping = 1000;\nconst ClampToEdgeWrapping = 1001;\nconst MirroredRepeatWrapping = 1002;\nconst NearestFilter = 1003;\nconst NearestMipmapNearestFilter = 1004;\nconst NearestMipMapNearestFilter = 1004;\nconst NearestMipmapLinearFilter = 1005;\nconst NearestMipMapLinearFilter = 1005;\nconst LinearFilter = 1006;\nconst LinearMipmapNearestFilter = 1007;\nconst LinearMipMapNearestFilter = 1007;\nconst LinearMipmapLinearFilter = 1008;\nconst LinearMipMapLinearFilter = 1008;\nconst UnsignedByteType = 1009;\nconst ByteType = 1010;\nconst ShortType = 1011;\nconst UnsignedShortType = 1012;\nconst IntType = 1013;\nconst UnsignedIntType = 1014;\nconst FloatType = 1015;\nconst HalfFloatType = 1016;\nconst UnsignedShort4444Type = 1017;\nconst UnsignedShort5551Type = 1018;\nconst UnsignedInt248Type = 1020;\nconst UnsignedInt5999Type = 35902;\nconst AlphaFormat = 1021;\nconst RGBFormat = 1022;\nconst RGBAFormat = 1023;\nconst LuminanceFormat = 1024;\nconst LuminanceAlphaFormat = 1025;\nconst DepthFormat = 1026;\nconst DepthStencilFormat = 1027;\nconst RedFormat = 1028;\nconst RedIntegerFormat = 1029;\nconst RGFormat = 1030;\nconst RGIntegerFormat = 1031;\nconst RGBIntegerFormat = 1032;\nconst RGBAIntegerFormat = 1033;\n\nconst RGB_S3TC_DXT1_Format = 33776;\nconst RGBA_S3TC_DXT1_Format = 33777;\nconst RGBA_S3TC_DXT3_Format = 33778;\nconst RGBA_S3TC_DXT5_Format = 33779;\nconst RGB_PVRTC_4BPPV1_Format = 35840;\nconst RGB_PVRTC_2BPPV1_Format = 35841;\nconst RGBA_PVRTC_4BPPV1_Format = 35842;\nconst RGBA_PVRTC_2BPPV1_Format = 35843;\nconst RGB_ETC1_Format = 36196;\nconst RGB_ETC2_Format = 37492;\nconst RGBA_ETC2_EAC_Format = 37496;\nconst RGBA_ASTC_4x4_Format = 37808;\nconst RGBA_ASTC_5x4_Format = 37809;\nconst RGBA_ASTC_5x5_Format = 37810;\nconst RGBA_ASTC_6x5_Format = 37811;\nconst RGBA_ASTC_6x6_Format = 37812;\nconst RGBA_ASTC_8x5_Format = 37813;\nconst RGBA_ASTC_8x6_Format = 37814;\nconst RGBA_ASTC_8x8_Format = 37815;\nconst RGBA_ASTC_10x5_Format = 37816;\nconst RGBA_ASTC_10x6_Format = 37817;\nconst RGBA_ASTC_10x8_Format = 37818;\nconst RGBA_ASTC_10x10_Format = 37819;\nconst RGBA_ASTC_12x10_Format = 37820;\nconst RGBA_ASTC_12x12_Format = 37821;\nconst RGBA_BPTC_Format = 36492;\nconst RGB_BPTC_SIGNED_Format = 36494;\nconst RGB_BPTC_UNSIGNED_Format = 36495;\nconst RED_RGTC1_Format = 36283;\nconst SIGNED_RED_RGTC1_Format = 36284;\nconst RED_GREEN_RGTC2_Format = 36285;\nconst SIGNED_RED_GREEN_RGTC2_Format = 36286;\nconst LoopOnce = 2200;\nconst LoopRepeat = 2201;\nconst LoopPingPong = 2202;\nconst InterpolateDiscrete = 2300;\nconst InterpolateLinear = 2301;\nconst InterpolateSmooth = 2302;\nconst ZeroCurvatureEnding = 2400;\nconst ZeroSlopeEnding = 2401;\nconst WrapAroundEnding = 2402;\nconst NormalAnimationBlendMode = 2500;\nconst AdditiveAnimationBlendMode = 2501;\nconst TrianglesDrawMode = 0;\nconst TriangleStripDrawMode = 1;\nconst TriangleFanDrawMode = 2;\nconst BasicDepthPacking = 3200;\nconst RGBADepthPacking = 3201;\nconst RGBDepthPacking = 3202;\nconst RGDepthPacking = 3203;\nconst TangentSpaceNormalMap = 0;\nconst ObjectSpaceNormalMap = 1;\n\n// Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.\nconst NoColorSpace = '';\nconst SRGBColorSpace = 'srgb';\nconst LinearSRGBColorSpace = 'srgb-linear';\n\nconst LinearTransfer = 'linear';\nconst SRGBTransfer = 'srgb';\n\nconst ZeroStencilOp = 0;\nconst KeepStencilOp = 7680;\nconst ReplaceStencilOp = 7681;\nconst IncrementStencilOp = 7682;\nconst DecrementStencilOp = 7683;\nconst IncrementWrapStencilOp = 34055;\nconst DecrementWrapStencilOp = 34056;\nconst InvertStencilOp = 5386;\n\nconst NeverStencilFunc = 512;\nconst LessStencilFunc = 513;\nconst EqualStencilFunc = 514;\nconst LessEqualStencilFunc = 515;\nconst GreaterStencilFunc = 516;\nconst NotEqualStencilFunc = 517;\nconst GreaterEqualStencilFunc = 518;\nconst AlwaysStencilFunc = 519;\n\nconst NeverCompare = 512;\nconst LessCompare = 513;\nconst EqualCompare = 514;\nconst LessEqualCompare = 515;\nconst GreaterCompare = 516;\nconst NotEqualCompare = 517;\nconst GreaterEqualCompare = 518;\nconst AlwaysCompare = 519;\n\nconst StaticDrawUsage = 35044;\nconst DynamicDrawUsage = 35048;\nconst StreamDrawUsage = 35040;\nconst StaticReadUsage = 35045;\nconst DynamicReadUsage = 35049;\nconst StreamReadUsage = 35041;\nconst StaticCopyUsage = 35046;\nconst DynamicCopyUsage = 35050;\nconst StreamCopyUsage = 35042;\n\nconst GLSL1 = '100';\nconst GLSL3 = '300 es';\n\nconst WebGLCoordinateSystem = 2000;\nconst WebGPUCoordinateSystem = 2001;\n\n/**\n * https://github.com/mrdoob/eventdispatcher.js/\n */\n\nclass EventDispatcher {\n\n\taddEventListener( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) this._listeners = {};\n\n\t\tconst listeners = this._listeners;\n\n\t\tif ( listeners[ type ] === undefined ) {\n\n\t\t\tlisteners[ type ] = [];\n\n\t\t}\n\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\n\t\t\tlisteners[ type ].push( listener );\n\n\t\t}\n\n\t}\n\n\thasEventListener( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return false;\n\n\t\tconst listeners = this._listeners;\n\n\t\treturn listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;\n\n\t}\n\n\tremoveEventListener( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tconst listeners = this._listeners;\n\t\tconst listenerArray = listeners[ type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tconst index = listenerArray.indexOf( listener );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\tlistenerArray.splice( index, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tdispatchEvent( event ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tconst listeners = this._listeners;\n\t\tconst listenerArray = listeners[ event.type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tevent.target = this;\n\n\t\t\t// Make a copy, in case listeners are removed while iterating.\n\t\t\tconst array = listenerArray.slice( 0 );\n\n\t\t\tfor ( let i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ].call( this, event );\n\n\t\t\t}\n\n\t\t\tevent.target = null;\n\n\t\t}\n\n\t}\n\n}\n\nconst _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ];\n\nlet _seed = 1234567;\n\n\nconst DEG2RAD = Math.PI / 180;\nconst RAD2DEG = 180 / Math.PI;\n\n// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\nfunction generateUUID() {\n\n\tconst d0 = Math.random() * 0xffffffff | 0;\n\tconst d1 = Math.random() * 0xffffffff | 0;\n\tconst d2 = Math.random() * 0xffffffff | 0;\n\tconst d3 = Math.random() * 0xffffffff | 0;\n\tconst uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +\n\t\t\t_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];\n\n\t// .toLowerCase() here flattens concatenated strings to save heap memory space.\n\treturn uuid.toLowerCase();\n\n}\n\nfunction clamp( value, min, max ) {\n\n\treturn Math.max( min, Math.min( max, value ) );\n\n}\n\n// compute euclidean modulo of m % n\n// https://en.wikipedia.org/wiki/Modulo_operation\nfunction euclideanModulo( n, m ) {\n\n\treturn ( ( n % m ) + m ) % m;\n\n}\n\n// Linear mapping from range <a1, a2> to range <b1, b2>\nfunction mapLinear( x, a1, a2, b1, b2 ) {\n\n\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n}\n\n// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/\nfunction inverseLerp( x, y, value ) {\n\n\tif ( x !== y ) {\n\n\t\treturn ( value - x ) / ( y - x );\n\n\t} else {\n\n\t\treturn 0;\n\n\t}\n\n}\n\n// https://en.wikipedia.org/wiki/Linear_interpolation\nfunction lerp( x, y, t ) {\n\n\treturn ( 1 - t ) * x + t * y;\n\n}\n\n// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\nfunction damp( x, y, lambda, dt ) {\n\n\treturn lerp( x, y, 1 - Math.exp( - lambda * dt ) );\n\n}\n\n// https://www.desmos.com/calculator/vcsjnyz7x4\nfunction pingpong( x, length = 1 ) {\n\n\treturn length - Math.abs( euclideanModulo( x, length * 2 ) - length );\n\n}\n\n// http://en.wikipedia.org/wiki/Smoothstep\nfunction smoothstep( x, min, max ) {\n\n\tif ( x <= min ) return 0;\n\tif ( x >= max ) return 1;\n\n\tx = ( x - min ) / ( max - min );\n\n\treturn x * x * ( 3 - 2 * x );\n\n}\n\nfunction smootherstep( x, min, max ) {\n\n\tif ( x <= min ) return 0;\n\tif ( x >= max ) return 1;\n\n\tx = ( x - min ) / ( max - min );\n\n\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\n}\n\n// Random integer from <low, high> interval\nfunction randInt( low, high ) {\n\n\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n}\n\n// Random float from <low, high> interval\nfunction randFloat( low, high ) {\n\n\treturn low + Math.random() * ( high - low );\n\n}\n\n// Random float from <-range/2, range/2> interval\nfunction randFloatSpread( range ) {\n\n\treturn range * ( 0.5 - Math.random() );\n\n}\n\n// Deterministic pseudo-random float in the interval [ 0, 1 ]\nfunction seededRandom( s ) {\n\n\tif ( s !== undefined ) _seed = s;\n\n\t// Mulberry32 generator\n\n\tlet t = _seed += 0x6D2B79F5;\n\n\tt = Math.imul( t ^ t >>> 15, t | 1 );\n\n\tt ^= t + Math.imul( t ^ t >>> 7, t | 61 );\n\n\treturn ( ( t ^ t >>> 14 ) >>> 0 ) / 4294967296;\n\n}\n\nfunction degToRad( degrees ) {\n\n\treturn degrees * DEG2RAD;\n\n}\n\nfunction radToDeg( radians ) {\n\n\treturn radians * RAD2DEG;\n\n}\n\nfunction isPowerOfTwo( value ) {\n\n\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\n}\n\nfunction ceilPowerOfTwo( value ) {\n\n\treturn Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );\n\n}\n\nfunction floorPowerOfTwo( value ) {\n\n\treturn Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );\n\n}\n\nfunction setQuaternionFromProperEuler( q, a, b, c, order ) {\n\n\t// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles\n\n\t// rotations are applied to the axes in the order specified by 'order'\n\t// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'\n\t// angles are in radians\n\n\tconst cos = Math.cos;\n\tconst sin = Math.sin;\n\n\tconst c2 = cos( b / 2 );\n\tconst s2 = sin( b / 2 );\n\n\tconst c13 = cos( ( a + c ) / 2 );\n\tconst s13 = sin( ( a + c ) / 2 );\n\n\tconst c1_3 = cos( ( a - c ) / 2 );\n\tconst s1_3 = sin( ( a - c ) / 2 );\n\n\tconst c3_1 = cos( ( c - a ) / 2 );\n\tconst s3_1 = sin( ( c - a ) / 2 );\n\n\tswitch ( order ) {\n\n\t\tcase 'XYX':\n\t\t\tq.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'YZY':\n\t\t\tq.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'ZXZ':\n\t\t\tq.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'XZX':\n\t\t\tq.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'YXY':\n\t\t\tq.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'ZYZ':\n\t\t\tq.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tconsole.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );\n\n\t}\n\n}\n\nfunction denormalize( value, array ) {\n\n\tswitch ( array.constructor ) {\n\n\t\tcase Float32Array:\n\n\t\t\treturn value;\n\n\t\tcase Uint32Array:\n\n\t\t\treturn value / 4294967295.0;\n\n\t\tcase Uint16Array:\n\n\t\t\treturn value / 65535.0;\n\n\t\tcase Uint8Array:\n\n\t\t\treturn value / 255.0;\n\n\t\tcase Int32Array:\n\n\t\t\treturn Math.max( value / 2147483647.0, - 1.0 );\n\n\t\tcase Int16Array:\n\n\t\t\treturn Math.max( value / 32767.0, - 1.0 );\n\n\t\tcase Int8Array:\n\n\t\t\treturn Math.max( value / 127.0, - 1.0 );\n\n\t\tdefault:\n\n\t\t\tthrow new Error( 'Invalid component type.' );\n\n\t}\n\n}\n\nfunction normalize( value, array ) {\n\n\tswitch ( array.constructor ) {\n\n\t\tcase Float32Array:\n\n\t\t\treturn value;\n\n\t\tcase Uint32Array:\n\n\t\t\treturn Math.round( value * 4294967295.0 );\n\n\t\tcase Uint16Array:\n\n\t\t\treturn Math.round( value * 65535.0 );\n\n\t\tcase Uint8Array:\n\n\t\t\treturn Math.round( value * 255.0 );\n\n\t\tcase Int32Array:\n\n\t\t\treturn Math.round( value * 2147483647.0 );\n\n\t\tcase Int16Array:\n\n\t\t\treturn Math.round( value * 32767.0 );\n\n\t\tcase Int8Array:\n\n\t\t\treturn Math.round( value * 127.0 );\n\n\t\tdefault:\n\n\t\t\tthrow new Error( 'Invalid component type.' );\n\n\t}\n\n}\n\nconst MathUtils = {\n\tDEG2RAD: DEG2RAD,\n\tRAD2DEG: RAD2DEG,\n\tgenerateUUID: generateUUID,\n\tclamp: clamp,\n\teuclideanModulo: euclideanModulo,\n\tmapLinear: mapLinear,\n\tinverseLerp: inverseLerp,\n\tlerp: lerp,\n\tdamp: damp,\n\tpingpong: pingpong,\n\tsmoothstep: smoothstep,\n\tsmootherstep: smootherstep,\n\trandInt: randInt,\n\trandFloat: randFloat,\n\trandFloatSpread: randFloatSpread,\n\tseededRandom: seededRandom,\n\tdegToRad: degToRad,\n\tradToDeg: radToDeg,\n\tisPowerOfTwo: isPowerOfTwo,\n\tceilPowerOfTwo: ceilPowerOfTwo,\n\tfloorPowerOfTwo: floorPowerOfTwo,\n\tsetQuaternionFromProperEuler: setQuaternionFromProperEuler,\n\tnormalize: normalize,\n\tdenormalize: denormalize\n};\n\nclass Vector2 {\n\n\tconstructor( x = 0, y = 0 ) {\n\n\t\tVector2.prototype.isVector2 = true;\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t}\n\n\tget width() {\n\n\t\treturn this.x;\n\n\t}\n\n\tset width( value ) {\n\n\t\tthis.x = value;\n\n\t}\n\n\tget height() {\n\n\t\treturn this.y;\n\n\t}\n\n\tset height( value ) {\n\n\t\tthis.y = value;\n\n\t}\n\n\tset( x, y ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetScalar( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\n\t\treturn this;\n\n\t}\n\n\tsetX( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t}\n\n\tsetY( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponent( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.x, this.y );\n\n\t}\n\n\tcopy( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\n\t\treturn this;\n\n\t}\n\n\tadd( v ) {\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\n\t\treturn this;\n\n\t}\n\n\taddScalar( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\n\t\treturn this;\n\n\t}\n\n\taddVectors( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\n\t\treturn this;\n\n\t}\n\n\taddScaledVector( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\n\t\treturn this;\n\n\t}\n\n\tsub( v ) {\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\n\t\treturn this;\n\n\t}\n\n\tsubScalar( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\n\t\treturn this;\n\n\t}\n\n\tsubVectors( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\n\t\treturn this;\n\n\t}\n\n\tdivide( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\n\t\treturn this;\n\n\t}\n\n\tdivideScalar( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t}\n\n\tapplyMatrix3( m ) {\n\n\t\tconst x = this.x, y = this.y;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];\n\n\t\treturn this;\n\n\t}\n\n\tmin( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\n\t\treturn this;\n\n\t}\n\n\tmax( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\n\t\treturn this;\n\n\t}\n\n\tclamp( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = clamp( this.x, min.x, max.x );\n\t\tthis.y = clamp( this.y, min.y, max.y );\n\n\t\treturn this;\n\n\t}\n\n\tclampScalar( minVal, maxVal ) {\n\n\t\tthis.x = clamp( this.x, minVal, maxVal );\n\t\tthis.y = clamp( this.y, minVal, maxVal );\n\n\t\treturn this;\n\n\t}\n\n\tclampLength( min, max ) {\n\n\t\tconst length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( clamp( length, min, max ) );\n\n\t}\n\n\tfloor() {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\n\t\treturn this;\n\n\t}\n\n\tceil() {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\n\t\treturn this;\n\n\t}\n\n\tround() {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\n\t\treturn this;\n\n\t}\n\n\troundToZero() {\n\n\t\tthis.x = Math.trunc( this.x );\n\t\tthis.y = Math.trunc( this.y );\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y;\n\n\t}\n\n\tcross( v ) {\n\n\t\treturn this.x * v.y - this.y * v.x;\n\n\t}\n\n\tlengthSq() {\n\n\t\treturn this.x * this.x + this.y * this.y;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\n\n\t}\n\n\tmanhattanLength() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y );\n\n\t}\n\n\tnormalize() {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t}\n\n\tangle() {\n\n\t\t// computes the angle in radians with respect to the positive x-axis\n\n\t\tconst angle = Math.atan2( - this.y, - this.x ) + Math.PI;\n\n\t\treturn angle;\n\n\t}\n\n\tangleTo( v ) {\n\n\t\tconst denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );\n\n\t\tif ( denominator === 0 ) return Math.PI / 2;\n\n\t\tconst theta = this.dot( v ) / denominator;\n\n\t\t// clamp, to handle numerical problems\n\n\t\treturn Math.acos( clamp( theta, - 1, 1 ) );\n\n\t}\n\n\tdistanceTo( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t}\n\n\tdistanceToSquared( v ) {\n\n\t\tconst dx = this.x - v.x, dy = this.y - v.y;\n\t\treturn dx * dx + dy * dy;\n\n\t}\n\n\tmanhattanDistanceTo( v ) {\n\n\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\n\n\t}\n\n\tsetLength( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t}\n\n\tlerp( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpVectors( v1, v2, alpha ) {\n\n\t\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\n\t\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tequals( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\n\t\treturn this;\n\n\t}\n\n\trotateAround( center, angle ) {\n\n\t\tconst c = Math.cos( angle ), s = Math.sin( angle );\n\n\t\tconst x = this.x - center.x;\n\t\tconst y = this.y - center.y;\n\n\t\tthis.x = x * c - y * s + center.x;\n\t\tthis.y = x * s + y * c + center.y;\n\n\t\treturn this;\n\n\t}\n\n\trandom() {\n\n\t\tthis.x = Math.random();\n\t\tthis.y = Math.random();\n\n\t\treturn this;\n\n\t}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this.x;\n\t\tyield this.y;\n\n\t}\n\n}\n\nclass Matrix3 {\n\n\tconstructor( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\tMatrix3.prototype.isMatrix3 = true;\n\n\t\tthis.elements = [\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t];\n\n\t\tif ( n11 !== undefined ) {\n\n\t\t\tthis.set( n11, n12, n13, n21, n22, n23, n31, n32, n33 );\n\n\t\t}\n\n\t}\n\n\tset( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\n\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\n\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\n\n\t\treturn this;\n\n\t}\n\n\tidentity() {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tcopy( m ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = m.elements;\n\n\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];\n\t\tte[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];\n\t\tte[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];\n\n\t\treturn this;\n\n\t}\n\n\textractBasis( xAxis, yAxis, zAxis ) {\n\n\t\txAxis.setFromMatrix3Column( this, 0 );\n\t\tyAxis.setFromMatrix3Column( this, 1 );\n\t\tzAxis.setFromMatrix3Column( this, 2 );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrix4( m ) {\n\n\t\tconst me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[ 0 ], me[ 4 ], me[ 8 ],\n\t\t\tme[ 1 ], me[ 5 ], me[ 9 ],\n\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( m ) {\n\n\t\treturn this.multiplyMatrices( this, m );\n\n\t}\n\n\tpremultiply( m ) {\n\n\t\treturn this.multiplyMatrices( m, this );\n\n\t}\n\n\tmultiplyMatrices( a, b ) {\n\n\t\tconst ae = a.elements;\n\t\tconst be = b.elements;\n\t\tconst te = this.elements;\n\n\t\tconst a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];\n\t\tconst a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];\n\t\tconst a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];\n\n\t\tconst b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];\n\t\tconst b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];\n\t\tconst b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];\n\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;\n\t\tte[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;\n\t\tte[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;\n\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;\n\t\tte[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;\n\t\tte[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;\n\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;\n\t\tte[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;\n\t\tte[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( s ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\n\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\n\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\n\n\t\treturn this;\n\n\t}\n\n\tdeterminant() {\n\n\t\tconst te = this.elements;\n\n\t\tconst a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\n\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\n\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\n\n\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\n\t}\n\n\tinvert() {\n\n\t\tconst te = this.elements,\n\n\t\t\tn11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],\n\t\t\tn12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],\n\t\t\tn13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],\n\n\t\t\tt11 = n33 * n22 - n32 * n23,\n\t\t\tt12 = n32 * n13 - n33 * n12,\n\t\t\tt13 = n23 * n12 - n22 * n13,\n\n\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\n\n\t\tif ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );\n\n\t\tconst detInv = 1 / det;\n\n\t\tte[ 0 ] = t11 * detInv;\n\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\n\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\n\n\t\tte[ 3 ] = t12 * detInv;\n\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\n\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\n\n\t\tte[ 6 ] = t13 * detInv;\n\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\n\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\n\n\t\treturn this;\n\n\t}\n\n\ttranspose() {\n\n\t\tlet tmp;\n\t\tconst m = this.elements;\n\n\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\n\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\n\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\n\n\t\treturn this;\n\n\t}\n\n\tgetNormalMatrix( matrix4 ) {\n\n\t\treturn this.setFromMatrix4( matrix4 ).invert().transpose();\n\n\t}\n\n\ttransposeIntoArray( r ) {\n\n\t\tconst m = this.elements;\n\n\t\tr[ 0 ] = m[ 0 ];\n\t\tr[ 1 ] = m[ 3 ];\n\t\tr[ 2 ] = m[ 6 ];\n\t\tr[ 3 ] = m[ 1 ];\n\t\tr[ 4 ] = m[ 4 ];\n\t\tr[ 5 ] = m[ 7 ];\n\t\tr[ 6 ] = m[ 2 ];\n\t\tr[ 7 ] = m[ 5 ];\n\t\tr[ 8 ] = m[ 8 ];\n\n\t\treturn this;\n\n\t}\n\n\tsetUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {\n\n\t\tconst c = Math.cos( rotation );\n\t\tconst s = Math.sin( rotation );\n\n\t\tthis.set(\n\t\t\tsx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,\n\t\t\t- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,\n\t\t\t0, 0, 1\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\t//\n\n\tscale( sx, sy ) {\n\n\t\tthis.premultiply( _m3.makeScale( sx, sy ) );\n\n\t\treturn this;\n\n\t}\n\n\trotate( theta ) {\n\n\t\tthis.premultiply( _m3.makeRotation( - theta ) );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( tx, ty ) {\n\n\t\tthis.premultiply( _m3.makeTranslation( tx, ty ) );\n\n\t\treturn this;\n\n\t}\n\n\t// for 2D Transforms\n\n\tmakeTranslation( x, y ) {\n\n\t\tif ( x.isVector2 ) {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, x.x,\n\t\t\t\t0, 1, x.y,\n\t\t\t\t0, 0, 1\n\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, x,\n\t\t\t\t0, 1, y,\n\t\t\t\t0, 0, 1\n\n\t\t\t);\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotation( theta ) {\n\n\t\t// counterclockwise\n\n\t\tconst c = Math.cos( theta );\n\t\tconst s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\tc, - s, 0,\n\t\t\ts, c, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeScale( x, y ) {\n\n\t\tthis.set(\n\n\t\t\tx, 0, 0,\n\t\t\t0, y, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\t//\n\n\tequals( matrix ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = matrix.elements;\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tconst te = this.elements;\n\n\t\tarray[ offset ] = te[ 0 ];\n\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\tarray[ offset + 2 ] = te[ 2 ];\n\n\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\tarray[ offset + 5 ] = te[ 5 ];\n\n\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\tarray[ offset + 8 ] = te[ 8 ];\n\n\t\treturn array;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().fromArray( this.elements );\n\n\t}\n\n}\n\nconst _m3 = /*@__PURE__*/ new Matrix3();\n\nfunction arrayNeedsUint32( array ) {\n\n\t// assumes larger values usually on last\n\n\tfor ( let i = array.length - 1; i >= 0; -- i ) {\n\n\t\tif ( array[ i ] >= 65535 ) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565\n\n\t}\n\n\treturn false;\n\n}\n\nconst TYPED_ARRAYS = {\n\tInt8Array: Int8Array,\n\tUint8Array: Uint8Array,\n\tUint8ClampedArray: Uint8ClampedArray,\n\tInt16Array: Int16Array,\n\tUint16Array: Uint16Array,\n\tInt32Array: Int32Array,\n\tUint32Array: Uint32Array,\n\tFloat32Array: Float32Array,\n\tFloat64Array: Float64Array\n};\n\nfunction getTypedArray( type, buffer ) {\n\n\treturn new TYPED_ARRAYS[ type ]( buffer );\n\n}\n\nfunction createElementNS( name ) {\n\n\treturn document.createElementNS( 'http://www.w3.org/1999/xhtml', name );\n\n}\n\nfunction createCanvasElement() {\n\n\tconst canvas = createElementNS( 'canvas' );\n\tcanvas.style.display = 'block';\n\treturn canvas;\n\n}\n\nconst _cache = {};\n\nfunction warnOnce( message ) {\n\n\tif ( message in _cache ) return;\n\n\t_cache[ message ] = true;\n\n\tconsole.warn( message );\n\n}\n\nfunction probeAsync( gl, sync, interval ) {\n\n\treturn new Promise( function ( resolve, reject ) {\n\n\t\tfunction probe() {\n\n\t\t\tswitch ( gl.clientWaitSync( sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0 ) ) {\n\n\t\t\t\tcase gl.WAIT_FAILED:\n\t\t\t\t\treject();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase gl.TIMEOUT_EXPIRED:\n\t\t\t\t\tsetTimeout( probe, interval );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tresolve();\n\n\t\t\t}\n\n\t\t}\n\n\t\tsetTimeout( probe, interval );\n\n\t} );\n\n}\n\nfunction toNormalizedProjectionMatrix( projectionMatrix ) {\n\n\tconst m = projectionMatrix.elements;\n\n\t// Convert [-1, 1] to [0, 1] projection matrix\n\tm[ 2 ] = 0.5 * m[ 2 ] + 0.5 * m[ 3 ];\n\tm[ 6 ] = 0.5 * m[ 6 ] + 0.5 * m[ 7 ];\n\tm[ 10 ] = 0.5 * m[ 10 ] + 0.5 * m[ 11 ];\n\tm[ 14 ] = 0.5 * m[ 14 ] + 0.5 * m[ 15 ];\n\n}\n\nfunction toReversedProjectionMatrix( projectionMatrix ) {\n\n\tconst m = projectionMatrix.elements;\n\tconst isPerspectiveMatrix = m[ 11 ] === - 1;\n\n\t// Reverse [0, 1] projection matrix\n\tif ( isPerspectiveMatrix ) {\n\n\t\tm[ 10 ] = - m[ 10 ] - 1;\n\t\tm[ 14 ] = - m[ 14 ];\n\n\t} else {\n\n\t\tm[ 10 ] = - m[ 10 ];\n\t\tm[ 14 ] = - m[ 14 ] + 1;\n\n\t}\n\n}\n\nconst LINEAR_REC709_TO_XYZ = /*@__PURE__*/ new Matrix3().set(\n\t0.4123908, 0.3575843, 0.1804808,\n\t0.2126390, 0.7151687, 0.0721923,\n\t0.0193308, 0.1191948, 0.9505322\n);\n\nconst XYZ_TO_LINEAR_REC709 = /*@__PURE__*/ new Matrix3().set(\n\t3.2409699, - 1.5373832, - 0.4986108,\n\t- 0.9692436, 1.8759675, 0.0415551,\n\t0.0556301, - 0.2039770, 1.0569715\n);\n\nfunction createColorManagement() {\n\n\tconst ColorManagement = {\n\n\t\tenabled: true,\n\n\t\tworkingColorSpace: LinearSRGBColorSpace,\n\n\t\t/**\n\t\t * Implementations of supported color spaces.\n\t\t *\n\t\t * Required:\n\t\t *\t- primaries: chromaticity coordinates [ rx ry gx gy bx by ]\n\t\t *\t- whitePoint: reference white [ x y ]\n\t\t *\t- transfer: transfer function (pre-defined)\n\t\t *\t- toXYZ: Matrix3 RGB to XYZ transform\n\t\t *\t- fromXYZ: Matrix3 XYZ to RGB transform\n\t\t *\t- luminanceCoefficients: RGB luminance coefficients\n\t\t *\n\t\t * Optional:\n\t\t *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }\n\t\t *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }\n\t\t *\n\t\t * Reference:\n\t\t * - https://www.russellcottrell.com/photo/matrixCalculator.htm\n\t\t */\n\t\tspaces: {},\n\n\t\tconvert: function ( color, sourceColorSpace, targetColorSpace ) {\n\n\t\t\tif ( this.enabled === false || sourceColorSpace === targetColorSpace || ! sourceColorSpace || ! targetColorSpace ) {\n\n\t\t\t\treturn color;\n\n\t\t\t}\n\n\t\t\tif ( this.spaces[ sourceColorSpace ].transfer === SRGBTransfer ) {\n\n\t\t\t\tcolor.r = SRGBToLinear( color.r );\n\t\t\t\tcolor.g = SRGBToLinear( color.g );\n\t\t\t\tcolor.b = SRGBToLinear( color.b );\n\n\t\t\t}\n\n\t\t\tif ( this.spaces[ sourceColorSpace ].primaries !== this.spaces[ targetColorSpace ].primaries ) {\n\n\t\t\t\tcolor.applyMatrix3( this.spaces[ sourceColorSpace ].toXYZ );\n\t\t\t\tcolor.applyMatrix3( this.spaces[ targetColorSpace ].fromXYZ );\n\n\t\t\t}\n\n\t\t\tif ( this.spaces[ targetColorSpace ].transfer === SRGBTransfer ) {\n\n\t\t\t\tcolor.r = LinearToSRGB( color.r );\n\t\t\t\tcolor.g = LinearToSRGB( color.g );\n\t\t\t\tcolor.b = LinearToSRGB( color.b );\n\n\t\t\t}\n\n\t\t\treturn color;\n\n\t\t},\n\n\t\tfromWorkingColorSpace: function ( color, targetColorSpace ) {\n\n\t\t\treturn this.convert( color, this.workingColorSpace, targetColorSpace );\n\n\t\t},\n\n\t\ttoWorkingColorSpace: function ( color, sourceColorSpace ) {\n\n\t\t\treturn this.convert( color, sourceColorSpace, this.workingColorSpace );\n\n\t\t},\n\n\t\tgetPrimaries: function ( colorSpace ) {\n\n\t\t\treturn this.spaces[ colorSpace ].primaries;\n\n\t\t},\n\n\t\tgetTransfer: function ( colorSpace ) {\n\n\t\t\tif ( colorSpace === NoColorSpace ) return LinearTransfer;\n\n\t\t\treturn this.spaces[ colorSpace ].transfer;\n\n\t\t},\n\n\t\tgetLuminanceCoefficients: function ( target, colorSpace = this.workingColorSpace ) {\n\n\t\t\treturn target.fromArray( this.spaces[ colorSpace ].luminanceCoefficients );\n\n\t\t},\n\n\t\tdefine: function ( colorSpaces ) {\n\n\t\t\tObject.assign( this.spaces, colorSpaces );\n\n\t\t},\n\n\t\t// Internal APIs\n\n\t\t_getMatrix: function ( targetMatrix, sourceColorSpace, targetColorSpace ) {\n\n\t\t\treturn targetMatrix\n\t\t\t\t.copy( this.spaces[ sourceColorSpace ].toXYZ )\n\t\t\t\t.multiply( this.spaces[ targetColorSpace ].fromXYZ );\n\n\t\t},\n\n\t\t_getDrawingBufferColorSpace: function ( colorSpace ) {\n\n\t\t\treturn this.spaces[ colorSpace ].outputColorSpaceConfig.drawingBufferColorSpace;\n\n\t\t},\n\n\t\t_getUnpackColorSpace: function ( colorSpace = this.workingColorSpace ) {\n\n\t\t\treturn this.spaces[ colorSpace ].workingColorSpaceConfig.unpackColorSpace;\n\n\t\t}\n\n\t};\n\n\t/******************************************************************************\n\t * sRGB definitions\n\t */\n\n\tconst REC709_PRIMARIES = [ 0.640, 0.330, 0.300, 0.600, 0.150, 0.060 ];\n\tconst REC709_LUMINANCE_COEFFICIENTS = [ 0.2126, 0.7152, 0.0722 ];\n\tconst D65 = [ 0.3127, 0.3290 ];\n\n\tColorManagement.define( {\n\n\t\t[ LinearSRGBColorSpace ]: {\n\t\t\tprimaries: REC709_PRIMARIES,\n\t\t\twhitePoint: D65,\n\t\t\ttransfer: LinearTransfer,\n\t\t\ttoXYZ: LINEAR_REC709_TO_XYZ,\n\t\t\tfromXYZ: XYZ_TO_LINEAR_REC709,\n\t\t\tluminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,\n\t\t\tworkingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace },\n\t\t\toutputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }\n\t\t},\n\n\t\t[ SRGBColorSpace ]: {\n\t\t\tprimaries: REC709_PRIMARIES,\n\t\t\twhitePoint: D65,\n\t\t\ttransfer: SRGBTransfer,\n\t\t\ttoXYZ: LINEAR_REC709_TO_XYZ,\n\t\t\tfromXYZ: XYZ_TO_LINEAR_REC709,\n\t\t\tluminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,\n\t\t\toutputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }\n\t\t},\n\n\t} );\n\n\treturn ColorManagement;\n\n}\n\nconst ColorManagement = /*@__PURE__*/ createColorManagement();\n\nfunction SRGBToLinear( c ) {\n\n\treturn ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n\n}\n\nfunction LinearToSRGB( c ) {\n\n\treturn ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;\n\n}\n\nlet _canvas;\n\nclass ImageUtils {\n\n\tstatic getDataURL( image ) {\n\n\t\tif ( /^data:/i.test( image.src ) ) {\n\n\t\t\treturn image.src;\n\n\t\t}\n\n\t\tif ( typeof HTMLCanvasElement === 'undefined' ) {\n\n\t\t\treturn image.src;\n\n\t\t}\n\n\t\tlet canvas;\n\n\t\tif ( image instanceof HTMLCanvasElement ) {\n\n\t\t\tcanvas = image;\n\n\t\t} else {\n\n\t\t\tif ( _canvas === undefined ) _canvas = createElementNS( 'canvas' );\n\n\t\t\t_canvas.width = image.width;\n\t\t\t_canvas.height = image.height;\n\n\t\t\tconst context = _canvas.getContext( '2d' );\n\n\t\t\tif ( image instanceof ImageData ) {\n\n\t\t\t\tcontext.putImageData( image, 0, 0 );\n\n\t\t\t} else {\n\n\t\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height );\n\n\t\t\t}\n\n\t\t\tcanvas = _canvas;\n\n\t\t}\n\n\t\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\n\n\t\t\tconsole.warn( 'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image );\n\n\t\t\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\n\n\t\t} else {\n\n\t\t\treturn canvas.toDataURL( 'image/png' );\n\n\t\t}\n\n\t}\n\n\tstatic sRGBToLinear( image ) {\n\n\t\tif ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||\n\t\t\t( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||\n\t\t\t( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {\n\n\t\t\tconst canvas = createElementNS( 'canvas' );\n\n\t\t\tcanvas.width = image.width;\n\t\t\tcanvas.height = image.height;\n\n\t\t\tconst context = canvas.getContext( '2d' );\n\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height );\n\n\t\t\tconst imageData = context.getImageData( 0, 0, image.width, image.height );\n\t\t\tconst data = imageData.data;\n\n\t\t\tfor ( let i = 0; i < data.length; i ++ ) {\n\n\t\t\t\tdata[ i ] = SRGBToLinear( data[ i ] / 255 ) * 255;\n\n\t\t\t}\n\n\t\t\tcontext.putImageData( imageData, 0, 0 );\n\n\t\t\treturn canvas;\n\n\t\t} else if ( image.data ) {\n\n\t\t\tconst data = image.data.slice( 0 );\n\n\t\t\tfor ( let i = 0; i < data.length; i ++ ) {\n\n\t\t\t\tif ( data instanceof Uint8Array || data instanceof Uint8ClampedArray ) {\n\n\t\t\t\t\tdata[ i ] = Math.floor( SRGBToLinear( data[ i ] / 255 ) * 255 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// assuming float\n\n\t\t\t\t\tdata[ i ] = SRGBToLinear( data[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tdata: data,\n\t\t\t\twidth: image.width,\n\t\t\t\theight: image.height\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.' );\n\t\t\treturn image;\n\n\t\t}\n\n\t}\n\n}\n\nlet _sourceId = 0;\n\nclass Source {\n\n\tconstructor( data = null ) {\n\n\t\tthis.isSource = true;\n\n\t\tObject.defineProperty( this, 'id', { value: _sourceId ++ } );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.data = data;\n\t\tthis.dataReady = true;\n\n\t\tthis.version = 0;\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( ! isRootObject && meta.images[ this.uuid ] !== undefined ) {\n\n\t\t\treturn meta.images[ this.uuid ];\n\n\t\t}\n\n\t\tconst output = {\n\t\t\tuuid: this.uuid,\n\t\t\turl: ''\n\t\t};\n\n\t\tconst data = this.data;\n\n\t\tif ( data !== null ) {\n\n\t\t\tlet url;\n\n\t\t\tif ( Array.isArray( data ) ) {\n\n\t\t\t\t// cube texture\n\n\t\t\t\turl = [];\n\n\t\t\t\tfor ( let i = 0, l = data.length; i < l; i ++ ) {\n\n\t\t\t\t\tif ( data[ i ].isDataTexture ) {\n\n\t\t\t\t\t\turl.push( serializeImage( data[ i ].image ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\turl.push( serializeImage( data[ i ] ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// texture\n\n\t\t\t\turl = serializeImage( data );\n\n\t\t\t}\n\n\t\t\toutput.url = url;\n\n\t\t}\n\n\t\tif ( ! isRootObject ) {\n\n\t\t\tmeta.images[ this.uuid ] = output;\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n}\n\nfunction serializeImage( image ) {\n\n\tif ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||\n\t\t( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||\n\t\t( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {\n\n\t\t// default images\n\n\t\treturn ImageUtils.getDataURL( image );\n\n\t} else {\n\n\t\tif ( image.data ) {\n\n\t\t\t// images of DataTexture\n\n\t\t\treturn {\n\t\t\t\tdata: Array.from( image.data ),\n\t\t\t\twidth: image.width,\n\t\t\t\theight: image.height,\n\t\t\t\ttype: image.data.constructor.name\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.Texture: Unable to serialize Texture.' );\n\t\t\treturn {};\n\n\t\t}\n\n\t}\n\n}\n\nlet _textureId = 0;\n\nclass Texture extends EventDispatcher {\n\n\tconstructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace ) {\n\n\t\tsuper();\n\n\t\tthis.isTexture = true;\n\n\t\tObject.defineProperty( this, 'id', { value: _textureId ++ } );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.name = '';\n\n\t\tthis.source = new Source( image );\n\t\tthis.mipmaps = [];\n\n\t\tthis.mapping = mapping;\n\t\tthis.channel = 0;\n\n\t\tthis.wrapS = wrapS;\n\t\tthis.wrapT = wrapT;\n\n\t\tthis.magFilter = magFilter;\n\t\tthis.minFilter = minFilter;\n\n\t\tthis.anisotropy = anisotropy;\n\n\t\tthis.format = format;\n\t\tthis.internalFormat = null;\n\t\tthis.type = type;\n\n\t\tthis.offset = new Vector2( 0, 0 );\n\t\tthis.repeat = new Vector2( 1, 1 );\n\t\tthis.center = new Vector2( 0, 0 );\n\t\tthis.rotation = 0;\n\n\t\tthis.matrixAutoUpdate = true;\n\t\tthis.matrix = new Matrix3();\n\n\t\tthis.generateMipmaps = true;\n\t\tthis.premultiplyAlpha = false;\n\t\tthis.flipY = true;\n\t\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n\t\tthis.colorSpace = colorSpace;\n\n\t\tthis.userData = {};\n\n\t\tthis.version = 0;\n\t\tthis.onUpdate = null;\n\n\t\tthis.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not\n\t\tthis.pmremVersion = 0; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)\n\n\t}\n\n\tget image() {\n\n\t\treturn this.source.data;\n\n\t}\n\n\tset image( value = null ) {\n\n\t\tthis.source.data = value;\n\n\t}\n\n\tupdateMatrix() {\n\n\t\tthis.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.source = source.source;\n\t\tthis.mipmaps = source.mipmaps.slice( 0 );\n\n\t\tthis.mapping = source.mapping;\n\t\tthis.channel = source.channel;\n\n\t\tthis.wrapS = source.wrapS;\n\t\tthis.wrapT = source.wrapT;\n\n\t\tthis.magFilter = source.magFilter;\n\t\tthis.minFilter = source.minFilter;\n\n\t\tthis.anisotropy = source.anisotropy;\n\n\t\tthis.format = source.format;\n\t\tthis.internalFormat = source.internalFormat;\n\t\tthis.type = source.type;\n\n\t\tthis.offset.copy( source.offset );\n\t\tthis.repeat.copy( source.repeat );\n\t\tthis.center.copy( source.center );\n\t\tthis.rotation = source.rotation;\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\tthis.matrix.copy( source.matrix );\n\n\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\tthis.flipY = source.flipY;\n\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\tthis.colorSpace = source.colorSpace;\n\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\tthis.needsUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {\n\n\t\t\treturn meta.textures[ this.uuid ];\n\n\t\t}\n\n\t\tconst output = {\n\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'Texture',\n\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t},\n\n\t\t\tuuid: this.uuid,\n\t\t\tname: this.name,\n\n\t\t\timage: this.source.toJSON( meta ).uuid,\n\n\t\t\tmapping: this.mapping,\n\t\t\tchannel: this.channel,\n\n\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\n\t\t\toffset: [ this.offset.x, this.offset.y ],\n\t\t\tcenter: [ this.center.x, this.center.y ],\n\t\t\trotation: this.rotation,\n\n\t\t\twrap: [ this.wrapS, this.wrapT ],\n\n\t\t\tformat: this.format,\n\t\t\tinternalFormat: this.internalFormat,\n\t\t\ttype: this.type,\n\t\t\tcolorSpace: this.colorSpace,\n\n\t\t\tminFilter: this.minFilter,\n\t\t\tmagFilter: this.magFilter,\n\t\t\tanisotropy: this.anisotropy,\n\n\t\t\tflipY: this.flipY,\n\n\t\t\tgenerateMipmaps: this.generateMipmaps,\n\t\t\tpremultiplyAlpha: this.premultiplyAlpha,\n\t\t\tunpackAlignment: this.unpackAlignment\n\n\t\t};\n\n\t\tif ( Object.keys( this.userData ).length > 0 ) output.userData = this.userData;\n\n\t\tif ( ! isRootObject ) {\n\n\t\t\tmeta.textures[ this.uuid ] = output;\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n\ttransformUv( uv ) {\n\n\t\tif ( this.mapping !== UVMapping ) return uv;\n\n\t\tuv.applyMatrix3( this.matrix );\n\n\t\tif ( uv.x < 0 || uv.x > 1 ) {\n\n\t\t\tswitch ( this.wrapS ) {\n\n\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( uv.y < 0 || uv.y > 1 ) {\n\n\t\t\tswitch ( this.wrapT ) {\n\n\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.flipY ) {\n\n\t\t\tuv.y = 1 - uv.y;\n\n\t\t}\n\n\t\treturn uv;\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.version ++;\n\t\t\tthis.source.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\tset needsPMREMUpdate( value ) {\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.pmremVersion ++;\n\n\t\t}\n\n\t}\n\n}\n\nTexture.DEFAULT_IMAGE = null;\nTexture.DEFAULT_MAPPING = UVMapping;\nTexture.DEFAULT_ANISOTROPY = 1;\n\nclass Vector4 {\n\n\tconstructor( x = 0, y = 0, z = 0, w = 1 ) {\n\n\t\tVector4.prototype.isVector4 = true;\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\n\t}\n\n\tget width() {\n\n\t\treturn this.z;\n\n\t}\n\n\tset width( value ) {\n\n\t\tthis.z = value;\n\n\t}\n\n\tget height() {\n\n\t\treturn this.w;\n\n\t}\n\n\tset height( value ) {\n\n\t\tthis.w = value;\n\n\t}\n\n\tset( x, y, z, w ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t}\n\n\tsetScalar( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\t\tthis.z = scalar;\n\t\tthis.w = scalar;\n\n\t\treturn this;\n\n\t}\n\n\tsetX( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t}\n\n\tsetY( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetZ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetW( w ) {\n\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponent( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tcase 3: this.w = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tcase 3: return this.w;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\n\n\t}\n\n\tcopy( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\n\n\t\treturn this;\n\n\t}\n\n\tadd( v ) {\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\t\tthis.w += v.w;\n\n\t\treturn this;\n\n\t}\n\n\taddScalar( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\t\tthis.w += s;\n\n\t\treturn this;\n\n\t}\n\n\taddVectors( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\t\tthis.w = a.w + b.w;\n\n\t\treturn this;\n\n\t}\n\n\taddScaledVector( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\t\tthis.z += v.z * s;\n\t\tthis.w += v.w * s;\n\n\t\treturn this;\n\n\t}\n\n\tsub( v ) {\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\t\tthis.w -= v.w;\n\n\t\treturn this;\n\n\t}\n\n\tsubScalar( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\t\tthis.z -= s;\n\t\tthis.w -= s;\n\n\t\treturn this;\n\n\t}\n\n\tsubVectors( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\t\tthis.w = a.w - b.w;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\t\tthis.z *= v.z;\n\t\tthis.w *= v.w;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\t\tthis.w *= scalar;\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix4( m ) {\n\n\t\tconst x = this.x, y = this.y, z = this.z, w = this.w;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\n\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\n\n\t\treturn this;\n\n\t}\n\n\tdivide( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\t\tthis.z /= v.z;\n\t\tthis.w /= v.w;\n\n\t\treturn this;\n\n\t}\n\n\tdivideScalar( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t}\n\n\tsetAxisAngleFromQuaternion( q ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\n\t\t// q is assumed to be normalized\n\n\t\tthis.w = 2 * Math.acos( q.w );\n\n\t\tconst s = Math.sqrt( 1 - q.w * q.w );\n\n\t\tif ( s < 0.0001 ) {\n\n\t\t\tthis.x = 1;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\n\t\t} else {\n\n\t\t\tthis.x = q.x / s;\n\t\t\tthis.y = q.y / s;\n\t\t\tthis.z = q.z / s;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetAxisAngleFromRotationMatrix( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tlet angle, x, y, z; // variables for result\n\t\tconst epsilon = 0.01,\t\t// margin to allow for rounding errors\n\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\n\n\t\t\tte = m.elements,\n\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\n\t\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\n\t\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\n\n\t\t\t// singularity found\n\t\t\t// first check for identity matrix which must have +1 for all terms\n\t\t\t// in leading diagonal and zero in other terms\n\n\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\n\n\t\t\t\t// this singularity is identity matrix so angle = 0\n\n\t\t\t\tthis.set( 1, 0, 0, 0 );\n\n\t\t\t\treturn this; // zero angle, arbitrary axis\n\n\t\t\t}\n\n\t\t\t// otherwise this singularity is angle = 180\n\n\t\t\tangle = Math.PI;\n\n\t\t\tconst xx = ( m11 + 1 ) / 2;\n\t\t\tconst yy = ( m22 + 1 ) / 2;\n\t\t\tconst zz = ( m33 + 1 ) / 2;\n\t\t\tconst xy = ( m12 + m21 ) / 4;\n\t\t\tconst xz = ( m13 + m31 ) / 4;\n\t\t\tconst yz = ( m23 + m32 ) / 4;\n\n\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\n\n\t\t\t\t// m11 is the largest diagonal term\n\n\t\t\t\tif ( xx < epsilon ) {\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tx = Math.sqrt( xx );\n\t\t\t\t\ty = xy / x;\n\t\t\t\t\tz = xz / x;\n\n\t\t\t\t}\n\n\t\t\t} else if ( yy > zz ) {\n\n\t\t\t\t// m22 is the largest diagonal term\n\n\t\t\t\tif ( yy < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ty = Math.sqrt( yy );\n\t\t\t\t\tx = xy / y;\n\t\t\t\t\tz = yz / y;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// m33 is the largest diagonal term so base result on this\n\n\t\t\t\tif ( zz < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tz = Math.sqrt( zz );\n\t\t\t\t\tx = xz / z;\n\t\t\t\t\ty = yz / z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.set( x, y, z, angle );\n\n\t\t\treturn this; // return 180 deg rotation\n\n\t\t}\n\n\t\t// as we have reached here there are no singularities so we can handle normally\n\n\t\tlet s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\n\t\t\t( m13 - m31 ) * ( m13 - m31 ) +\n\t\t\t( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\n\n\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\n\n\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t\t// caught by singularity test above, but I've left it in just in case\n\n\t\tthis.x = ( m32 - m23 ) / s;\n\t\tthis.y = ( m13 - m31 ) / s;\n\t\tthis.z = ( m21 - m12 ) / s;\n\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrixPosition( m ) {\n\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 12 ];\n\t\tthis.y = e[ 13 ];\n\t\tthis.z = e[ 14 ];\n\t\tthis.w = e[ 15 ];\n\n\t\treturn this;\n\n\t}\n\n\tmin( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\t\tthis.z = Math.min( this.z, v.z );\n\t\tthis.w = Math.min( this.w, v.w );\n\n\t\treturn this;\n\n\t}\n\n\tmax( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\t\tthis.z = Math.max( this.z, v.z );\n\t\tthis.w = Math.max( this.w, v.w );\n\n\t\treturn this;\n\n\t}\n\n\tclamp( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = clamp( this.x, min.x, max.x );\n\t\tthis.y = clamp( this.y, min.y, max.y );\n\t\tthis.z = clamp( this.z, min.z, max.z );\n\t\tthis.w = clamp( this.w, min.w, max.w );\n\n\t\treturn this;\n\n\t}\n\n\tclampScalar( minVal, maxVal ) {\n\n\t\tthis.x = clamp( this.x, minVal, maxVal );\n\t\tthis.y = clamp( this.y, minVal, maxVal );\n\t\tthis.z = clamp( this.z, minVal, maxVal );\n\t\tthis.w = clamp( this.w, minVal, maxVal );\n\n\t\treturn this;\n\n\t}\n\n\tclampLength( min, max ) {\n\n\t\tconst length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( clamp( length, min, max ) );\n\n\t}\n\n\tfloor() {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\t\tthis.z = Math.floor( this.z );\n\t\tthis.w = Math.floor( this.w );\n\n\t\treturn this;\n\n\t}\n\n\tceil() {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\t\tthis.z = Math.ceil( this.z );\n\t\tthis.w = Math.ceil( this.w );\n\n\t\treturn this;\n\n\t}\n\n\tround() {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\t\tthis.z = Math.round( this.z );\n\t\tthis.w = Math.round( this.w );\n\n\t\treturn this;\n\n\t}\n\n\troundToZero() {\n\n\t\tthis.x = Math.trunc( this.x );\n\t\tthis.y = Math.trunc( this.y );\n\t\tthis.z = Math.trunc( this.z );\n\t\tthis.w = Math.trunc( this.w );\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\t\tthis.z = - this.z;\n\t\tthis.w = - this.w;\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\n\t}\n\n\tlengthSq() {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\n\n\t}\n\n\tmanhattanLength() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\n\n\t}\n\n\tnormalize() {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t}\n\n\tsetLength( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t}\n\n\tlerp( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\tthis.w += ( v.w - this.w ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpVectors( v1, v2, alpha ) {\n\n\t\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\n\t\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\n\t\tthis.z = v1.z + ( v2.z - v1.z ) * alpha;\n\t\tthis.w = v1.w + ( v2.w - v1.w ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tequals( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\t\tthis.z = array[ offset + 2 ];\n\t\tthis.w = array[ offset + 3 ];\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\t\tarray[ offset + 2 ] = this.z;\n\t\tarray[ offset + 3 ] = this.w;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\t\tthis.z = attribute.getZ( index );\n\t\tthis.w = attribute.getW( index );\n\n\t\treturn this;\n\n\t}\n\n\trandom() {\n\n\t\tthis.x = Math.random();\n\t\tthis.y = Math.random();\n\t\tthis.z = Math.random();\n\t\tthis.w = Math.random();\n\n\t\treturn this;\n\n\t}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this.x;\n\t\tyield this.y;\n\t\tyield this.z;\n\t\tyield this.w;\n\n\t}\n\n}\n\n/*\n In options, we can specify:\n * Texture parameters for an auto-generated target texture\n * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\n*/\nclass RenderTarget extends EventDispatcher {\n\n\tconstructor( width = 1, height = 1, options = {} ) {\n\n\t\tsuper();\n\n\t\tthis.isRenderTarget = true;\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tthis.depth = 1;\n\n\t\tthis.scissor = new Vector4( 0, 0, width, height );\n\t\tthis.scissorTest = false;\n\n\t\tthis.viewport = new Vector4( 0, 0, width, height );\n\n\t\tconst image = { width: width, height: height, depth: 1 };\n\n\t\toptions = Object.assign( {\n\t\t\tgenerateMipmaps: false,\n\t\t\tinternalFormat: null,\n\t\t\tminFilter: LinearFilter,\n\t\t\tdepthBuffer: true,\n\t\t\tstencilBuffer: false,\n\t\t\tresolveDepthBuffer: true,\n\t\t\tresolveStencilBuffer: true,\n\t\t\tdepthTexture: null,\n\t\t\tsamples: 0,\n\t\t\tcount: 1\n\t\t}, options );\n\n\t\tconst texture = new Texture( image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace );\n\n\t\ttexture.flipY = false;\n\t\ttexture.generateMipmaps = options.generateMipmaps;\n\t\ttexture.internalFormat = options.internalFormat;\n\n\t\tthis.textures = [];\n\n\t\tconst count = options.count;\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tthis.textures[ i ] = texture.clone();\n\t\t\tthis.textures[ i ].isRenderTargetTexture = true;\n\n\t\t}\n\n\t\tthis.depthBuffer = options.depthBuffer;\n\t\tthis.stencilBuffer = options.stencilBuffer;\n\n\t\tthis.resolveDepthBuffer = options.resolveDepthBuffer;\n\t\tthis.resolveStencilBuffer = options.resolveStencilBuffer;\n\n\t\tthis.depthTexture = options.depthTexture;\n\n\t\tthis.samples = options.samples;\n\n\t}\n\n\tget texture() {\n\n\t\treturn this.textures[ 0 ];\n\n\t}\n\n\tset texture( value ) {\n\n\t\tthis.textures[ 0 ] = value;\n\n\t}\n\n\tsetSize( width, height, depth = 1 ) {\n\n\t\tif ( this.width !== width || this.height !== height || this.depth !== depth ) {\n\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\t\t\tthis.depth = depth;\n\n\t\t\tfor ( let i = 0, il = this.textures.length; i < il; i ++ ) {\n\n\t\t\t\tthis.textures[ i ].image.width = width;\n\t\t\t\tthis.textures[ i ].image.height = height;\n\t\t\t\tthis.textures[ i ].image.depth = depth;\n\n\t\t\t}\n\n\t\t\tthis.dispose();\n\n\t\t}\n\n\t\tthis.viewport.set( 0, 0, width, height );\n\t\tthis.scissor.set( 0, 0, width, height );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.width = source.width;\n\t\tthis.height = source.height;\n\t\tthis.depth = source.depth;\n\n\t\tthis.scissor.copy( source.scissor );\n\t\tthis.scissorTest = source.scissorTest;\n\n\t\tthis.viewport.copy( source.viewport );\n\n\t\tthis.textures.length = 0;\n\n\t\tfor ( let i = 0, il = source.textures.length; i < il; i ++ ) {\n\n\t\t\tthis.textures[ i ] = source.textures[ i ].clone();\n\t\t\tthis.textures[ i ].isRenderTargetTexture = true;\n\n\t\t}\n\n\t\t// ensure image object is not shared, see #20328\n\n\t\tconst image = Object.assign( {}, source.texture.image );\n\t\tthis.texture.source = new Source( image );\n\n\t\tthis.depthBuffer = source.depthBuffer;\n\t\tthis.stencilBuffer = source.stencilBuffer;\n\n\t\tthis.resolveDepthBuffer = source.resolveDepthBuffer;\n\t\tthis.resolveStencilBuffer = source.resolveStencilBuffer;\n\n\t\tif ( source.depthTexture !== null ) this.depthTexture = source.depthTexture.clone();\n\n\t\tthis.samples = source.samples;\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n}\n\nclass WebGLRenderTarget extends RenderTarget {\n\n\tconstructor( width = 1, height = 1, options = {} ) {\n\n\t\tsuper( width, height, options );\n\n\t\tthis.isWebGLRenderTarget = true;\n\n\t}\n\n}\n\nclass DataArrayTexture extends Texture {\n\n\tconstructor( data = null, width = 1, height = 1, depth = 1 ) {\n\n\t\tsuper( null );\n\n\t\tthis.isDataArrayTexture = true;\n\n\t\tthis.image = { data, width, height, depth };\n\n\t\tthis.magFilter = NearestFilter;\n\t\tthis.minFilter = NearestFilter;\n\n\t\tthis.wrapR = ClampToEdgeWrapping;\n\n\t\tthis.generateMipmaps = false;\n\t\tthis.flipY = false;\n\t\tthis.unpackAlignment = 1;\n\n\t\tthis.layerUpdates = new Set();\n\n\t}\n\n\taddLayerUpdate( layerIndex ) {\n\n\t\tthis.layerUpdates.add( layerIndex );\n\n\t}\n\n\tclearLayerUpdates() {\n\n\t\tthis.layerUpdates.clear();\n\n\t}\n\n}\n\nclass WebGLArrayRenderTarget extends WebGLRenderTarget {\n\n\tconstructor( width = 1, height = 1, depth = 1, options = {} ) {\n\n\t\tsuper( width, height, options );\n\n\t\tthis.isWebGLArrayRenderTarget = true;\n\n\t\tthis.depth = depth;\n\n\t\tthis.texture = new DataArrayTexture( null, width, height, depth );\n\n\t\tthis.texture.isRenderTargetTexture = true;\n\n\t}\n\n}\n\nclass Data3DTexture extends Texture {\n\n\tconstructor( data = null, width = 1, height = 1, depth = 1 ) {\n\n\t\t// We're going to add .setXXX() methods for setting properties later.\n\t\t// Users can still set in DataTexture3D directly.\n\t\t//\n\t\t//\tconst texture = new THREE.DataTexture3D( data, width, height, depth );\n\t\t// \ttexture.anisotropy = 16;\n\t\t//\n\t\t// See #14839\n\n\t\tsuper( null );\n\n\t\tthis.isData3DTexture = true;\n\n\t\tthis.image = { data, width, height, depth };\n\n\t\tthis.magFilter = NearestFilter;\n\t\tthis.minFilter = NearestFilter;\n\n\t\tthis.wrapR = ClampToEdgeWrapping;\n\n\t\tthis.generateMipmaps = false;\n\t\tthis.flipY = false;\n\t\tthis.unpackAlignment = 1;\n\n\t}\n\n}\n\nclass WebGL3DRenderTarget extends WebGLRenderTarget {\n\n\tconstructor( width = 1, height = 1, depth = 1, options = {} ) {\n\n\t\tsuper( width, height, options );\n\n\t\tthis.isWebGL3DRenderTarget = true;\n\n\t\tthis.depth = depth;\n\n\t\tthis.texture = new Data3DTexture( null, width, height, depth );\n\n\t\tthis.texture.isRenderTargetTexture = true;\n\n\t}\n\n}\n\nclass Quaternion {\n\n\tconstructor( x = 0, y = 0, z = 0, w = 1 ) {\n\n\t\tthis.isQuaternion = true;\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._w = w;\n\n\t}\n\n\tstatic slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\n\n\t\t// fuzz-free, array-based Quaternion SLERP operation\n\n\t\tlet x0 = src0[ srcOffset0 + 0 ],\n\t\t\ty0 = src0[ srcOffset0 + 1 ],\n\t\t\tz0 = src0[ srcOffset0 + 2 ],\n\t\t\tw0 = src0[ srcOffset0 + 3 ];\n\n\t\tconst x1 = src1[ srcOffset1 + 0 ],\n\t\t\ty1 = src1[ srcOffset1 + 1 ],\n\t\t\tz1 = src1[ srcOffset1 + 2 ],\n\t\t\tw1 = src1[ srcOffset1 + 3 ];\n\n\t\tif ( t === 0 ) {\n\n\t\t\tdst[ dstOffset + 0 ] = x0;\n\t\t\tdst[ dstOffset + 1 ] = y0;\n\t\t\tdst[ dstOffset + 2 ] = z0;\n\t\t\tdst[ dstOffset + 3 ] = w0;\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( t === 1 ) {\n\n\t\t\tdst[ dstOffset + 0 ] = x1;\n\t\t\tdst[ dstOffset + 1 ] = y1;\n\t\t\tdst[ dstOffset + 2 ] = z1;\n\t\t\tdst[ dstOffset + 3 ] = w1;\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\n\n\t\t\tlet s = 1 - t;\n\t\t\tconst cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\n\t\t\t\tsqrSin = 1 - cos * cos;\n\n\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\n\t\t\tif ( sqrSin > Number.EPSILON ) {\n\n\t\t\t\tconst sin = Math.sqrt( sqrSin ),\n\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\n\n\t\t\t\ts = Math.sin( s * len ) / sin;\n\t\t\t\tt = Math.sin( t * len ) / sin;\n\n\t\t\t}\n\n\t\t\tconst tDir = t * dir;\n\n\t\t\tx0 = x0 * s + x1 * tDir;\n\t\t\ty0 = y0 * s + y1 * tDir;\n\t\t\tz0 = z0 * s + z1 * tDir;\n\t\t\tw0 = w0 * s + w1 * tDir;\n\n\t\t\t// Normalize in case we just did a lerp:\n\t\t\tif ( s === 1 - t ) {\n\n\t\t\t\tconst f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\n\n\t\t\t\tx0 *= f;\n\t\t\t\ty0 *= f;\n\t\t\t\tz0 *= f;\n\t\t\t\tw0 *= f;\n\n\t\t\t}\n\n\t\t}\n\n\t\tdst[ dstOffset ] = x0;\n\t\tdst[ dstOffset + 1 ] = y0;\n\t\tdst[ dstOffset + 2 ] = z0;\n\t\tdst[ dstOffset + 3 ] = w0;\n\n\t}\n\n\tstatic multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {\n\n\t\tconst x0 = src0[ srcOffset0 ];\n\t\tconst y0 = src0[ srcOffset0 + 1 ];\n\t\tconst z0 = src0[ srcOffset0 + 2 ];\n\t\tconst w0 = src0[ srcOffset0 + 3 ];\n\n\t\tconst x1 = src1[ srcOffset1 ];\n\t\tconst y1 = src1[ srcOffset1 + 1 ];\n\t\tconst z1 = src1[ srcOffset1 + 2 ];\n\t\tconst w1 = src1[ srcOffset1 + 3 ];\n\n\t\tdst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;\n\t\tdst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;\n\t\tdst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;\n\t\tdst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\n\n\t\treturn dst;\n\n\t}\n\n\tget x() {\n\n\t\treturn this._x;\n\n\t}\n\n\tset x( value ) {\n\n\t\tthis._x = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget y() {\n\n\t\treturn this._y;\n\n\t}\n\n\tset y( value ) {\n\n\t\tthis._y = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget z() {\n\n\t\treturn this._z;\n\n\t}\n\n\tset z( value ) {\n\n\t\tthis._z = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget w() {\n\n\t\treturn this._w;\n\n\t}\n\n\tset w( value ) {\n\n\t\tthis._w = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tset( x, y, z, w ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._w = w;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\n\n\t}\n\n\tcopy( quaternion ) {\n\n\t\tthis._x = quaternion.x;\n\t\tthis._y = quaternion.y;\n\t\tthis._z = quaternion.z;\n\t\tthis._w = quaternion.w;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromEuler( euler, update = true ) {\n\n\t\tconst x = euler._x, y = euler._y, z = euler._z, order = euler._order;\n\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t//\tcontent/SpinCalc.m\n\n\t\tconst cos = Math.cos;\n\t\tconst sin = Math.sin;\n\n\t\tconst c1 = cos( x / 2 );\n\t\tconst c2 = cos( y / 2 );\n\t\tconst c3 = cos( z / 2 );\n\n\t\tconst s1 = sin( x / 2 );\n\t\tconst s2 = sin( y / 2 );\n\t\tconst s3 = sin( z / 2 );\n\n\t\tswitch ( order ) {\n\n\t\t\tcase 'XYZ':\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'YXZ':\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZXY':\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZYX':\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'YZX':\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'XZY':\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );\n\n\t\t}\n\n\t\tif ( update === true ) this._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromAxisAngle( axis, angle ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\n\t\t// assumes axis is normalized\n\n\t\tconst halfAngle = angle / 2, s = Math.sin( halfAngle );\n\n\t\tthis._x = axis.x * s;\n\t\tthis._y = axis.y * s;\n\t\tthis._z = axis.z * s;\n\t\tthis._w = Math.cos( halfAngle );\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromRotationMatrix( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tconst te = m.elements,\n\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\n\n\t\t\ttrace = m11 + m22 + m33;\n\n\t\tif ( trace > 0 ) {\n\n\t\t\tconst s = 0.5 / Math.sqrt( trace + 1.0 );\n\n\t\t\tthis._w = 0.25 / s;\n\t\t\tthis._x = ( m32 - m23 ) * s;\n\t\t\tthis._y = ( m13 - m31 ) * s;\n\t\t\tthis._z = ( m21 - m12 ) * s;\n\n\t\t} else if ( m11 > m22 && m11 > m33 ) {\n\n\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\n\t\t\tthis._w = ( m32 - m23 ) / s;\n\t\t\tthis._x = 0.25 * s;\n\t\t\tthis._y = ( m12 + m21 ) / s;\n\t\t\tthis._z = ( m13 + m31 ) / s;\n\n\t\t} else if ( m22 > m33 ) {\n\n\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\n\t\t\tthis._w = ( m13 - m31 ) / s;\n\t\t\tthis._x = ( m12 + m21 ) / s;\n\t\t\tthis._y = 0.25 * s;\n\t\t\tthis._z = ( m23 + m32 ) / s;\n\n\t\t} else {\n\n\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\n\t\t\tthis._w = ( m21 - m12 ) / s;\n\t\t\tthis._x = ( m13 + m31 ) / s;\n\t\t\tthis._y = ( m23 + m32 ) / s;\n\t\t\tthis._z = 0.25 * s;\n\n\t\t}\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromUnitVectors( vFrom, vTo ) {\n\n\t\t// assumes direction vectors vFrom and vTo are normalized\n\n\t\tlet r = vFrom.dot( vTo ) + 1;\n\n\t\tif ( r < Number.EPSILON ) {\n\n\t\t\t// vFrom and vTo point in opposite directions\n\n\t\t\tr = 0;\n\n\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\n\n\t\t\t\tthis._x = - vFrom.y;\n\t\t\t\tthis._y = vFrom.x;\n\t\t\t\tthis._z = 0;\n\t\t\t\tthis._w = r;\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._y = - vFrom.z;\n\t\t\t\tthis._z = vFrom.y;\n\t\t\t\tthis._w = r;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3\n\n\t\t\tthis._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n\t\t\tthis._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\n\t\t\tthis._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n\t\t\tthis._w = r;\n\n\t\t}\n\n\t\treturn this.normalize();\n\n\t}\n\n\tangleTo( q ) {\n\n\t\treturn 2 * Math.acos( Math.abs( clamp( this.dot( q ), - 1, 1 ) ) );\n\n\t}\n\n\trotateTowards( q, step ) {\n\n\t\tconst angle = this.angleTo( q );\n\n\t\tif ( angle === 0 ) return this;\n\n\t\tconst t = Math.min( 1, step / angle );\n\n\t\tthis.slerp( q, t );\n\n\t\treturn this;\n\n\t}\n\n\tidentity() {\n\n\t\treturn this.set( 0, 0, 0, 1 );\n\n\t}\n\n\tinvert() {\n\n\t\t// quaternion is assumed to have unit length\n\n\t\treturn this.conjugate();\n\n\t}\n\n\tconjugate() {\n\n\t\tthis._x *= - 1;\n\t\tthis._y *= - 1;\n\t\tthis._z *= - 1;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\n\t}\n\n\tlengthSq() {\n\n\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\n\n\t}\n\n\tnormalize() {\n\n\t\tlet l = this.length();\n\n\t\tif ( l === 0 ) {\n\n\t\t\tthis._x = 0;\n\t\t\tthis._y = 0;\n\t\t\tthis._z = 0;\n\t\t\tthis._w = 1;\n\n\t\t} else {\n\n\t\t\tl = 1 / l;\n\n\t\t\tthis._x = this._x * l;\n\t\t\tthis._y = this._y * l;\n\t\t\tthis._z = this._z * l;\n\t\t\tthis._w = this._w * l;\n\n\t\t}\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( q ) {\n\n\t\treturn this.multiplyQuaternions( this, q );\n\n\t}\n\n\tpremultiply( q ) {\n\n\t\treturn this.multiplyQuaternions( q, this );\n\n\t}\n\n\tmultiplyQuaternions( a, b ) {\n\n\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n\t\tconst qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n\t\tconst qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n\n\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tslerp( qb, t ) {\n\n\t\tif ( t === 0 ) return this;\n\t\tif ( t === 1 ) return this.copy( qb );\n\n\t\tconst x = this._x, y = this._y, z = this._z, w = this._w;\n\n\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n\t\tlet cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n\t\tif ( cosHalfTheta < 0 ) {\n\n\t\t\tthis._w = - qb._w;\n\t\t\tthis._x = - qb._x;\n\t\t\tthis._y = - qb._y;\n\t\t\tthis._z = - qb._z;\n\n\t\t\tcosHalfTheta = - cosHalfTheta;\n\n\t\t} else {\n\n\t\t\tthis.copy( qb );\n\n\t\t}\n\n\t\tif ( cosHalfTheta >= 1.0 ) {\n\n\t\t\tthis._w = w;\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\n\n\t\tif ( sqrSinHalfTheta <= Number.EPSILON ) {\n\n\t\t\tconst s = 1 - t;\n\t\t\tthis._w = s * w + t * this._w;\n\t\t\tthis._x = s * x + t * this._x;\n\t\t\tthis._y = s * y + t * this._y;\n\t\t\tthis._z = s * z + t * this._z;\n\n\t\t\tthis.normalize(); // normalize calls _onChangeCallback()\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst sinHalfTheta = Math.sqrt( sqrSinHalfTheta );\n\t\tconst halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\n\t\tconst ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n\t\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\n\t\tthis._w = ( w * ratioA + this._w * ratioB );\n\t\tthis._x = ( x * ratioA + this._x * ratioB );\n\t\tthis._y = ( y * ratioA + this._y * ratioB );\n\t\tthis._z = ( z * ratioA + this._z * ratioB );\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tslerpQuaternions( qa, qb, t ) {\n\n\t\treturn this.copy( qa ).slerp( qb, t );\n\n\t}\n\n\trandom() {\n\n\t\t// sets this quaternion to a uniform random unit quaternnion\n\n\t\t// Ken Shoemake\n\t\t// Uniform random rotations\n\t\t// D. Kirk, editor, Graphics Gems III, pages 124-132. Academic Press, New York, 1992.\n\n\t\tconst theta1 = 2 * Math.PI * Math.random();\n\t\tconst theta2 = 2 * Math.PI * Math.random();\n\n\t\tconst x0 = Math.random();\n\t\tconst r1 = Math.sqrt( 1 - x0 );\n\t\tconst r2 = Math.sqrt( x0 );\n\n\t\treturn this.set(\n\t\t\tr1 * Math.sin( theta1 ),\n\t\t\tr1 * Math.cos( theta1 ),\n\t\t\tr2 * Math.sin( theta2 ),\n\t\t\tr2 * Math.cos( theta2 ),\n\t\t);\n\n\t}\n\n\tequals( quaternion ) {\n\n\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis._x = array[ offset ];\n\t\tthis._y = array[ offset + 1 ];\n\t\tthis._z = array[ offset + 2 ];\n\t\tthis._w = array[ offset + 3 ];\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this._x;\n\t\tarray[ offset + 1 ] = this._y;\n\t\tarray[ offset + 2 ] = this._z;\n\t\tarray[ offset + 3 ] = this._w;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis._x = attribute.getX( index );\n\t\tthis._y = attribute.getY( index );\n\t\tthis._z = attribute.getZ( index );\n\t\tthis._w = attribute.getW( index );\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\treturn this.toArray();\n\n\t}\n\n\t_onChange( callback ) {\n\n\t\tthis._onChangeCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n\t_onChangeCallback() {}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this._x;\n\t\tyield this._y;\n\t\tyield this._z;\n\t\tyield this._w;\n\n\t}\n\n}\n\nclass Vector3 {\n\n\tconstructor( x = 0, y = 0, z = 0 ) {\n\n\t\tVector3.prototype.isVector3 = true;\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\n\t}\n\n\tset( x, y, z ) {\n\n\t\tif ( z === undefined ) z = this.z; // sprite.scale.set(x,y)\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetScalar( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\t\tthis.z = scalar;\n\n\t\treturn this;\n\n\t}\n\n\tsetX( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t}\n\n\tsetY( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetZ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponent( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.x, this.y, this.z );\n\n\t}\n\n\tcopy( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\n\t\treturn this;\n\n\t}\n\n\tadd( v ) {\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\n\t\treturn this;\n\n\t}\n\n\taddScalar( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\n\t\treturn this;\n\n\t}\n\n\taddVectors( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\n\t\treturn this;\n\n\t}\n\n\taddScaledVector( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\t\tthis.z += v.z * s;\n\n\t\treturn this;\n\n\t}\n\n\tsub( v ) {\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\n\t\treturn this;\n\n\t}\n\n\tsubScalar( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\t\tthis.z -= s;\n\n\t\treturn this;\n\n\t}\n\n\tsubVectors( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\t\tthis.z *= v.z;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyVectors( a, b ) {\n\n\t\tthis.x = a.x * b.x;\n\t\tthis.y = a.y * b.y;\n\t\tthis.z = a.z * b.z;\n\n\t\treturn this;\n\n\t}\n\n\tapplyEuler( euler ) {\n\n\t\treturn this.applyQuaternion( _quaternion$4.setFromEuler( euler ) );\n\n\t}\n\n\tapplyAxisAngle( axis, angle ) {\n\n\t\treturn this.applyQuaternion( _quaternion$4.setFromAxisAngle( axis, angle ) );\n\n\t}\n\n\tapplyMatrix3( m ) {\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\n\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\n\n\t\treturn this;\n\n\t}\n\n\tapplyNormalMatrix( m ) {\n\n\t\treturn this.applyMatrix3( m ).normalize();\n\n\t}\n\n\tapplyMatrix4( m ) {\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst e = m.elements;\n\n\t\tconst w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );\n\n\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;\n\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;\n\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;\n\n\t\treturn this;\n\n\t}\n\n\tapplyQuaternion( q ) {\n\n\t\t// quaternion q is assumed to have unit length\n\n\t\tconst vx = this.x, vy = this.y, vz = this.z;\n\t\tconst qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n\n\t\t// t = 2 * cross( q.xyz, v );\n\t\tconst tx = 2 * ( qy * vz - qz * vy );\n\t\tconst ty = 2 * ( qz * vx - qx * vz );\n\t\tconst tz = 2 * ( qx * vy - qy * vx );\n\n\t\t// v + q.w * t + cross( q.xyz, t );\n\t\tthis.x = vx + qw * tx + qy * tz - qz * ty;\n\t\tthis.y = vy + qw * ty + qz * tx - qx * tz;\n\t\tthis.z = vz + qw * tz + qx * ty - qy * tx;\n\n\t\treturn this;\n\n\t}\n\n\tproject( camera ) {\n\n\t\treturn this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );\n\n\t}\n\n\tunproject( camera ) {\n\n\t\treturn this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );\n\n\t}\n\n\ttransformDirection( m ) {\n\n\t\t// input: THREE.Matrix4 affine matrix\n\t\t// vector interpreted as a direction\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\n\n\t\treturn this.normalize();\n\n\t}\n\n\tdivide( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\t\tthis.z /= v.z;\n\n\t\treturn this;\n\n\t}\n\n\tdivideScalar( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t}\n\n\tmin( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\t\tthis.z = Math.min( this.z, v.z );\n\n\t\treturn this;\n\n\t}\n\n\tmax( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\t\tthis.z = Math.max( this.z, v.z );\n\n\t\treturn this;\n\n\t}\n\n\tclamp( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = clamp( this.x, min.x, max.x );\n\t\tthis.y = clamp( this.y, min.y, max.y );\n\t\tthis.z = clamp( this.z, min.z, max.z );\n\n\t\treturn this;\n\n\t}\n\n\tclampScalar( minVal, maxVal ) {\n\n\t\tthis.x = clamp( this.x, minVal, maxVal );\n\t\tthis.y = clamp( this.y, minVal, maxVal );\n\t\tthis.z = clamp( this.z, minVal, maxVal );\n\n\t\treturn this;\n\n\t}\n\n\tclampLength( min, max ) {\n\n\t\tconst length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( clamp( length, min, max ) );\n\n\t}\n\n\tfloor() {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\t\tthis.z = Math.floor( this.z );\n\n\t\treturn this;\n\n\t}\n\n\tceil() {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\t\tthis.z = Math.ceil( this.z );\n\n\t\treturn this;\n\n\t}\n\n\tround() {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\t\tthis.z = Math.round( this.z );\n\n\t\treturn this;\n\n\t}\n\n\troundToZero() {\n\n\t\tthis.x = Math.trunc( this.x );\n\t\tthis.y = Math.trunc( this.y );\n\t\tthis.z = Math.trunc( this.z );\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\t\tthis.z = - this.z;\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\n\t}\n\n\t// TODO lengthSquared?\n\n\tlengthSq() {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n\n\t}\n\n\tmanhattanLength() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\n\t}\n\n\tnormalize() {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t}\n\n\tsetLength( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t}\n\n\tlerp( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpVectors( v1, v2, alpha ) {\n\n\t\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\n\t\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\n\t\tthis.z = v1.z + ( v2.z - v1.z ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tcross( v ) {\n\n\t\treturn this.crossVectors( this, v );\n\n\t}\n\n\tcrossVectors( a, b ) {\n\n\t\tconst ax = a.x, ay = a.y, az = a.z;\n\t\tconst bx = b.x, by = b.y, bz = b.z;\n\n\t\tthis.x = ay * bz - az * by;\n\t\tthis.y = az * bx - ax * bz;\n\t\tthis.z = ax * by - ay * bx;\n\n\t\treturn this;\n\n\t}\n\n\tprojectOnVector( v ) {\n\n\t\tconst denominator = v.lengthSq();\n\n\t\tif ( denominator === 0 ) return this.set( 0, 0, 0 );\n\n\t\tconst scalar = v.dot( this ) / denominator;\n\n\t\treturn this.copy( v ).multiplyScalar( scalar );\n\n\t}\n\n\tprojectOnPlane( planeNormal ) {\n\n\t\t_vector$c.copy( this ).projectOnVector( planeNormal );\n\n\t\treturn this.sub( _vector$c );\n\n\t}\n\n\treflect( normal ) {\n\n\t\t// reflect incident vector off plane orthogonal to normal\n\t\t// normal is assumed to have unit length\n\n\t\treturn this.sub( _vector$c.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\n\n\t}\n\n\tangleTo( v ) {\n\n\t\tconst denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );\n\n\t\tif ( denominator === 0 ) return Math.PI / 2;\n\n\t\tconst theta = this.dot( v ) / denominator;\n\n\t\t// clamp, to handle numerical problems\n\n\t\treturn Math.acos( clamp( theta, - 1, 1 ) );\n\n\t}\n\n\tdistanceTo( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t}\n\n\tdistanceToSquared( v ) {\n\n\t\tconst dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n\n\t\treturn dx * dx + dy * dy + dz * dz;\n\n\t}\n\n\tmanhattanDistanceTo( v ) {\n\n\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );\n\n\t}\n\n\tsetFromSpherical( s ) {\n\n\t\treturn this.setFromSphericalCoords( s.radius, s.phi, s.theta );\n\n\t}\n\n\tsetFromSphericalCoords( radius, phi, theta ) {\n\n\t\tconst sinPhiRadius = Math.sin( phi ) * radius;\n\n\t\tthis.x = sinPhiRadius * Math.sin( theta );\n\t\tthis.y = Math.cos( phi ) * radius;\n\t\tthis.z = sinPhiRadius * Math.cos( theta );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCylindrical( c ) {\n\n\t\treturn this.setFromCylindricalCoords( c.radius, c.theta, c.y );\n\n\t}\n\n\tsetFromCylindricalCoords( radius, theta, y ) {\n\n\t\tthis.x = radius * Math.sin( theta );\n\t\tthis.y = y;\n\t\tthis.z = radius * Math.cos( theta );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrixPosition( m ) {\n\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 12 ];\n\t\tthis.y = e[ 13 ];\n\t\tthis.z = e[ 14 ];\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrixScale( m ) {\n\n\t\tconst sx = this.setFromMatrixColumn( m, 0 ).length();\n\t\tconst sy = this.setFromMatrixColumn( m, 1 ).length();\n\t\tconst sz = this.setFromMatrixColumn( m, 2 ).length();\n\n\t\tthis.x = sx;\n\t\tthis.y = sy;\n\t\tthis.z = sz;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrixColumn( m, index ) {\n\n\t\treturn this.fromArray( m.elements, index * 4 );\n\n\t}\n\n\tsetFromMatrix3Column( m, index ) {\n\n\t\treturn this.fromArray( m.elements, index * 3 );\n\n\t}\n\n\tsetFromEuler( e ) {\n\n\t\tthis.x = e._x;\n\t\tthis.y = e._y;\n\t\tthis.z = e._z;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromColor( c ) {\n\n\t\tthis.x = c.r;\n\t\tthis.y = c.g;\n\t\tthis.z = c.b;\n\n\t\treturn this;\n\n\t}\n\n\tequals( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\t\tthis.z = array[ offset + 2 ];\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\t\tarray[ offset + 2 ] = this.z;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\t\tthis.z = attribute.getZ( index );\n\n\t\treturn this;\n\n\t}\n\n\trandom() {\n\n\t\tthis.x = Math.random();\n\t\tthis.y = Math.random();\n\t\tthis.z = Math.random();\n\n\t\treturn this;\n\n\t}\n\n\trandomDirection() {\n\n\t\t// https://mathworld.wolfram.com/SpherePointPicking.html\n\n\t\tconst theta = Math.random() * Math.PI * 2;\n\t\tconst u = Math.random() * 2 - 1;\n\t\tconst c = Math.sqrt( 1 - u * u );\n\n\t\tthis.x = c * Math.cos( theta );\n\t\tthis.y = u;\n\t\tthis.z = c * Math.sin( theta );\n\n\t\treturn this;\n\n\t}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this.x;\n\t\tyield this.y;\n\t\tyield this.z;\n\n\t}\n\n}\n\nconst _vector$c = /*@__PURE__*/ new Vector3();\nconst _quaternion$4 = /*@__PURE__*/ new Quaternion();\n\nclass Box3 {\n\n\tconstructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {\n\n\t\tthis.isBox3 = true;\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tset( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromArray( array ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( let i = 0, il = array.length; i < il; i += 3 ) {\n\n\t\t\tthis.expandByPoint( _vector$b.fromArray( array, i ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromBufferAttribute( attribute ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( let i = 0, il = attribute.count; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( _vector$b.fromBufferAttribute( attribute, i ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( let i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCenterAndSize( center, size ) {\n\n\t\tconst halfSize = _vector$b.copy( size ).multiplyScalar( 0.5 );\n\n\t\tthis.min.copy( center ).sub( halfSize );\n\t\tthis.max.copy( center ).add( halfSize );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromObject( object, precise = false ) {\n\n\t\tthis.makeEmpty();\n\n\t\treturn this.expandByObject( object, precise );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t}\n\n\tmakeEmpty() {\n\n\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\n\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\n\n\t\treturn this;\n\n\t}\n\n\tisEmpty() {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\n\n\t}\n\n\tgetCenter( target ) {\n\n\t\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t}\n\n\tgetSize( target ) {\n\n\t\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );\n\n\t}\n\n\texpandByPoint( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t}\n\n\texpandByVector( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t}\n\n\texpandByScalar( scalar ) {\n\n\t\tthis.min.addScalar( - scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t}\n\n\texpandByObject( object, precise = false ) {\n\n\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t// accounting for both the object's, and children's, world transforms\n\n\t\tobject.updateWorldMatrix( false, false );\n\n\t\tconst geometry = object.geometry;\n\n\t\tif ( geometry !== undefined ) {\n\n\t\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\n\t\t\t// precise AABB computation based on vertex data requires at least a position attribute.\n\t\t\t// instancing isn't supported so far and uses the normal (conservative) code path.\n\n\t\t\tif ( precise === true && positionAttribute !== undefined && object.isInstancedMesh !== true ) {\n\n\t\t\t\tfor ( let i = 0, l = positionAttribute.count; i < l; i ++ ) {\n\n\t\t\t\t\tif ( object.isMesh === true ) {\n\n\t\t\t\t\t\tobject.getVertexPosition( i, _vector$b );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_vector$b.fromBufferAttribute( positionAttribute, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_vector$b.applyMatrix4( object.matrixWorld );\n\t\t\t\t\tthis.expandByPoint( _vector$b );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( object.boundingBox !== undefined ) {\n\n\t\t\t\t\t// object-level bounding box\n\n\t\t\t\t\tif ( object.boundingBox === null ) {\n\n\t\t\t\t\t\tobject.computeBoundingBox();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_box$4.copy( object.boundingBox );\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// geometry-level bounding box\n\n\t\t\t\t\tif ( geometry.boundingBox === null ) {\n\n\t\t\t\t\t\tgeometry.computeBoundingBox();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_box$4.copy( geometry.boundingBox );\n\n\t\t\t\t}\n\n\t\t\t\t_box$4.applyMatrix4( object.matrixWorld );\n\n\t\t\t\tthis.union( _box$4 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tthis.expandByObject( children[ i ], precise );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn point.x >= this.min.x && point.x <= this.max.x &&\n\t\t\tpoint.y >= this.min.y && point.y <= this.max.y &&\n\t\t\tpoint.z >= this.min.z && point.z <= this.max.z;\n\n\t}\n\n\tcontainsBox( box ) {\n\n\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\n\t\t\tthis.min.y <= box.min.y && box.max.y <= this.max.y &&\n\t\t\tthis.min.z <= box.min.z && box.max.z <= this.max.z;\n\n\t}\n\n\tgetParameter( point, target ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\treturn target.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\n\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\n\t\t);\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\t// using 6 splitting planes to rule out intersections.\n\t\treturn box.max.x >= this.min.x && box.min.x <= this.max.x &&\n\t\t\tbox.max.y >= this.min.y && box.min.y <= this.max.y &&\n\t\t\tbox.max.z >= this.min.z && box.min.z <= this.max.z;\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\t// Find the point on the AABB closest to the sphere center.\n\t\tthis.clampPoint( sphere.center, _vector$b );\n\n\t\t// If that point is inside the sphere, the AABB and sphere intersect.\n\t\treturn _vector$b.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t}\n\n\tintersectsPlane( plane ) {\n\n\t\t// We compute the minimum and maximum dot product values. If those values\n\t\t// are on the same side (back or front) of the plane, then there is no intersection.\n\n\t\tlet min, max;\n\n\t\tif ( plane.normal.x > 0 ) {\n\n\t\t\tmin = plane.normal.x * this.min.x;\n\t\t\tmax = plane.normal.x * this.max.x;\n\n\t\t} else {\n\n\t\t\tmin = plane.normal.x * this.max.x;\n\t\t\tmax = plane.normal.x * this.min.x;\n\n\t\t}\n\n\t\tif ( plane.normal.y > 0 ) {\n\n\t\t\tmin += plane.normal.y * this.min.y;\n\t\t\tmax += plane.normal.y * this.max.y;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.y * this.max.y;\n\t\t\tmax += plane.normal.y * this.min.y;\n\n\t\t}\n\n\t\tif ( plane.normal.z > 0 ) {\n\n\t\t\tmin += plane.normal.z * this.min.z;\n\t\t\tmax += plane.normal.z * this.max.z;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.z * this.max.z;\n\t\t\tmax += plane.normal.z * this.min.z;\n\n\t\t}\n\n\t\treturn ( min <= - plane.constant && max >= - plane.constant );\n\n\t}\n\n\tintersectsTriangle( triangle ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// compute box center and extents\n\t\tthis.getCenter( _center );\n\t\t_extents.subVectors( this.max, _center );\n\n\t\t// translate triangle to aabb origin\n\t\t_v0$2.subVectors( triangle.a, _center );\n\t\t_v1$7.subVectors( triangle.b, _center );\n\t\t_v2$4.subVectors( triangle.c, _center );\n\n\t\t// compute edge vectors for triangle\n\t\t_f0.subVectors( _v1$7, _v0$2 );\n\t\t_f1.subVectors( _v2$4, _v1$7 );\n\t\t_f2.subVectors( _v0$2, _v2$4 );\n\n\t\t// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb\n\t\t// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation\n\t\t// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)\n\t\tlet axes = [\n\t\t\t0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,\n\t\t\t_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,\n\t\t\t- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0\n\t\t];\n\t\tif ( ! satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// test 3 face normals from the aabb\n\t\taxes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];\n\t\tif ( ! satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// finally testing the face normal of the triangle\n\t\t// use already existing triangle edge vectors here\n\t\t_triangleNormal.crossVectors( _f0, _f1 );\n\t\taxes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];\n\n\t\treturn satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents );\n\n\t}\n\n\tclampPoint( point, target ) {\n\n\t\treturn target.copy( point ).clamp( this.min, this.max );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn this.clampPoint( point, _vector$b ).distanceTo( point );\n\n\t}\n\n\tgetBoundingSphere( target ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\ttarget.makeEmpty();\n\n\t\t} else {\n\n\t\t\tthis.getCenter( target.center );\n\n\t\t\ttarget.radius = this.getSize( _vector$b ).length() * 0.5;\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\tintersect( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\t\tif ( this.isEmpty() ) this.makeEmpty();\n\n\t\treturn this;\n\n\t}\n\n\tunion( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\t// transform of empty box is an empty box.\n\t\tif ( this.isEmpty() ) return this;\n\n\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\t\t_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\n\t\t_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\n\t\t_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\n\t\t_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\n\t\t_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\n\t\t_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\n\t\t_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\n\t\t_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111\n\n\t\tthis.setFromPoints( _points );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t}\n\n\tequals( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t}\n\n}\n\nconst _points = [\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3()\n];\n\nconst _vector$b = /*@__PURE__*/ new Vector3();\n\nconst _box$4 = /*@__PURE__*/ new Box3();\n\n// triangle centered vertices\n\nconst _v0$2 = /*@__PURE__*/ new Vector3();\nconst _v1$7 = /*@__PURE__*/ new Vector3();\nconst _v2$4 = /*@__PURE__*/ new Vector3();\n\n// triangle edge vectors\n\nconst _f0 = /*@__PURE__*/ new Vector3();\nconst _f1 = /*@__PURE__*/ new Vector3();\nconst _f2 = /*@__PURE__*/ new Vector3();\n\nconst _center = /*@__PURE__*/ new Vector3();\nconst _extents = /*@__PURE__*/ new Vector3();\nconst _triangleNormal = /*@__PURE__*/ new Vector3();\nconst _testAxis = /*@__PURE__*/ new Vector3();\n\nfunction satForAxes( axes, v0, v1, v2, extents ) {\n\n\tfor ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {\n\n\t\t_testAxis.fromArray( axes, i );\n\t\t// project the aabb onto the separating axis\n\t\tconst r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );\n\t\t// project all 3 vertices of the triangle onto the separating axis\n\t\tconst p0 = v0.dot( _testAxis );\n\t\tconst p1 = v1.dot( _testAxis );\n\t\tconst p2 = v2.dot( _testAxis );\n\t\t// actual test, basically see if either of the most extreme of the triangle points intersects r\n\t\tif ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\n\n\t\t\t// points of the projected triangle are outside the projected half-length of the aabb\n\t\t\t// the axis is separating and we can exit\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\treturn true;\n\n}\n\nconst _box$3 = /*@__PURE__*/ new Box3();\nconst _v1$6 = /*@__PURE__*/ new Vector3();\nconst _v2$3 = /*@__PURE__*/ new Vector3();\n\nclass Sphere {\n\n\tconstructor( center = new Vector3(), radius = - 1 ) {\n\n\t\tthis.isSphere = true;\n\n\t\tthis.center = center;\n\t\tthis.radius = radius;\n\n\t}\n\n\tset( center, radius ) {\n\n\t\tthis.center.copy( center );\n\t\tthis.radius = radius;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points, optionalCenter ) {\n\n\t\tconst center = this.center;\n\n\t\tif ( optionalCenter !== undefined ) {\n\n\t\t\tcenter.copy( optionalCenter );\n\n\t\t} else {\n\n\t\t\t_box$3.setFromPoints( points ).getCenter( center );\n\n\t\t}\n\n\t\tlet maxRadiusSq = 0;\n\n\t\tfor ( let i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\n\t\t}\n\n\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( sphere ) {\n\n\t\tthis.center.copy( sphere.center );\n\t\tthis.radius = sphere.radius;\n\n\t\treturn this;\n\n\t}\n\n\tisEmpty() {\n\n\t\treturn ( this.radius < 0 );\n\n\t}\n\n\tmakeEmpty() {\n\n\t\tthis.center.set( 0, 0, 0 );\n\t\tthis.radius = - 1;\n\n\t\treturn this;\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\tconst radiusSum = this.radius + sphere.radius;\n\n\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn box.intersectsSphere( this );\n\n\t}\n\n\tintersectsPlane( plane ) {\n\n\t\treturn Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;\n\n\t}\n\n\tclampPoint( point, target ) {\n\n\t\tconst deltaLengthSq = this.center.distanceToSquared( point );\n\n\t\ttarget.copy( point );\n\n\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\ttarget.sub( this.center ).normalize();\n\t\t\ttarget.multiplyScalar( this.radius ).add( this.center );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\tgetBoundingBox( target ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\t// Empty sphere produces empty bounding box\n\t\t\ttarget.makeEmpty();\n\t\t\treturn target;\n\n\t\t}\n\n\t\ttarget.set( this.center, this.center );\n\t\ttarget.expandByScalar( this.radius );\n\n\t\treturn target;\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tthis.center.applyMatrix4( matrix );\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.center.add( offset );\n\n\t\treturn this;\n\n\t}\n\n\texpandByPoint( point ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\tthis.center.copy( point );\n\n\t\t\tthis.radius = 0;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t_v1$6.subVectors( point, this.center );\n\n\t\tconst lengthSq = _v1$6.lengthSq();\n\n\t\tif ( lengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\t// calculate the minimal sphere\n\n\t\t\tconst length = Math.sqrt( lengthSq );\n\n\t\t\tconst delta = ( length - this.radius ) * 0.5;\n\n\t\t\tthis.center.addScaledVector( _v1$6, delta / length );\n\n\t\t\tthis.radius += delta;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tunion( sphere ) {\n\n\t\tif ( sphere.isEmpty() ) {\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\tthis.copy( sphere );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( this.center.equals( sphere.center ) === true ) {\n\n\t\t\t this.radius = Math.max( this.radius, sphere.radius );\n\n\t\t} else {\n\n\t\t\t_v2$3.subVectors( sphere.center, this.center ).setLength( sphere.radius );\n\n\t\t\tthis.expandByPoint( _v1$6.copy( sphere.center ).add( _v2$3 ) );\n\n\t\t\tthis.expandByPoint( _v1$6.copy( sphere.center ).sub( _v2$3 ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tequals( sphere ) {\n\n\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nconst _vector$a = /*@__PURE__*/ new Vector3();\nconst _segCenter = /*@__PURE__*/ new Vector3();\nconst _segDir = /*@__PURE__*/ new Vector3();\nconst _diff = /*@__PURE__*/ new Vector3();\n\nconst _edge1 = /*@__PURE__*/ new Vector3();\nconst _edge2 = /*@__PURE__*/ new Vector3();\nconst _normal$1 = /*@__PURE__*/ new Vector3();\n\nclass Ray {\n\n\tconstructor( origin = new Vector3(), direction = new Vector3( 0, 0, - 1 ) ) {\n\n\t\tthis.origin = origin;\n\t\tthis.direction = direction;\n\n\t}\n\n\tset( origin, direction ) {\n\n\t\tthis.origin.copy( origin );\n\t\tthis.direction.copy( direction );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( ray ) {\n\n\t\tthis.origin.copy( ray.origin );\n\t\tthis.direction.copy( ray.direction );\n\n\t\treturn this;\n\n\t}\n\n\tat( t, target ) {\n\n\t\treturn target.copy( this.origin ).addScaledVector( this.direction, t );\n\n\t}\n\n\tlookAt( v ) {\n\n\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\n\n\t\treturn this;\n\n\t}\n\n\trecast( t ) {\n\n\t\tthis.origin.copy( this.at( t, _vector$a ) );\n\n\t\treturn this;\n\n\t}\n\n\tclosestPointToPoint( point, target ) {\n\n\t\ttarget.subVectors( point, this.origin );\n\n\t\tconst directionDistance = target.dot( this.direction );\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn target.copy( this.origin );\n\n\t\t}\n\n\t\treturn target.copy( this.origin ).addScaledVector( this.direction, directionDistance );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\n\n\t}\n\n\tdistanceSqToPoint( point ) {\n\n\t\tconst directionDistance = _vector$a.subVectors( point, this.origin ).dot( this.direction );\n\n\t\t// point behind the ray\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn this.origin.distanceToSquared( point );\n\n\t\t}\n\n\t\t_vector$a.copy( this.origin ).addScaledVector( this.direction, directionDistance );\n\n\t\treturn _vector$a.distanceToSquared( point );\n\n\t}\n\n\tdistanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\n\t\t// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t// It returns the min distance between the ray and the segment\n\t\t// defined by v0 and v1\n\t\t// It can also set two optional targets :\n\t\t// - The closest point on the ray\n\t\t// - The closest point on the segment\n\n\t\t_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\n\t\t_segDir.copy( v1 ).sub( v0 ).normalize();\n\t\t_diff.copy( this.origin ).sub( _segCenter );\n\n\t\tconst segExtent = v0.distanceTo( v1 ) * 0.5;\n\t\tconst a01 = - this.direction.dot( _segDir );\n\t\tconst b0 = _diff.dot( this.direction );\n\t\tconst b1 = - _diff.dot( _segDir );\n\t\tconst c = _diff.lengthSq();\n\t\tconst det = Math.abs( 1 - a01 * a01 );\n\t\tlet s0, s1, sqrDist, extDet;\n\n\t\tif ( det > 0 ) {\n\n\t\t\t// The ray and segment are not parallel.\n\n\t\t\ts0 = a01 * b1 - b0;\n\t\t\ts1 = a01 * b0 - b1;\n\t\t\textDet = segExtent * det;\n\n\t\t\tif ( s0 >= 0 ) {\n\n\t\t\t\tif ( s1 >= - extDet ) {\n\n\t\t\t\t\tif ( s1 <= extDet ) {\n\n\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\n\t\t\t\t\t\tconst invDet = 1 / det;\n\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// region 1\n\n\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// region 5\n\n\t\t\t\t\ts1 = - segExtent;\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( s1 <= - extDet ) {\n\n\t\t\t\t\t// region 4\n\n\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t} else if ( s1 <= extDet ) {\n\n\t\t\t\t\t// region 3\n\n\t\t\t\t\ts0 = 0;\n\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// region 2\n\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// Ray and segment are parallel.\n\n\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t}\n\n\t\tif ( optionalPointOnRay ) {\n\n\t\t\toptionalPointOnRay.copy( this.origin ).addScaledVector( this.direction, s0 );\n\n\t\t}\n\n\t\tif ( optionalPointOnSegment ) {\n\n\t\t\toptionalPointOnSegment.copy( _segCenter ).addScaledVector( _segDir, s1 );\n\n\t\t}\n\n\t\treturn sqrDist;\n\n\t}\n\n\tintersectSphere( sphere, target ) {\n\n\t\t_vector$a.subVectors( sphere.center, this.origin );\n\t\tconst tca = _vector$a.dot( this.direction );\n\t\tconst d2 = _vector$a.dot( _vector$a ) - tca * tca;\n\t\tconst radius2 = sphere.radius * sphere.radius;\n\n\t\tif ( d2 > radius2 ) return null;\n\n\t\tconst thc = Math.sqrt( radius2 - d2 );\n\n\t\t// t0 = first intersect point - entrance on front of sphere\n\t\tconst t0 = tca - thc;\n\n\t\t// t1 = second intersect point - exit point on back of sphere\n\t\tconst t1 = tca + thc;\n\n\t\t// test to see if t1 is behind the ray - if so, return null\n\t\tif ( t1 < 0 ) return null;\n\n\t\t// test to see if t0 is behind the ray:\n\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t// in order to always return an intersect point that is in front of the ray.\n\t\tif ( t0 < 0 ) return this.at( t1, target );\n\n\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\n\t\treturn this.at( t0, target );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t}\n\n\tdistanceToPlane( plane ) {\n\n\t\tconst denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\n\t\t// Return if the ray never intersects the plane\n\n\t\treturn t >= 0 ? t : null;\n\n\t}\n\n\tintersectPlane( plane, target ) {\n\n\t\tconst t = this.distanceToPlane( plane );\n\n\t\tif ( t === null ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn this.at( t, target );\n\n\t}\n\n\tintersectsPlane( plane ) {\n\n\t\t// check if the ray lies on the plane first\n\n\t\tconst distToPoint = plane.distanceToPoint( this.origin );\n\n\t\tif ( distToPoint === 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tconst denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator * distToPoint < 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\t// ray origin is behind the plane (and is pointing behind it)\n\n\t\treturn false;\n\n\t}\n\n\tintersectBox( box, target ) {\n\n\t\tlet tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\t\tconst invdirx = 1 / this.direction.x,\n\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\tinvdirz = 1 / this.direction.z;\n\n\t\tconst origin = this.origin;\n\n\t\tif ( invdirx >= 0 ) {\n\n\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\n\n\t\t} else {\n\n\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\n\n\t\t}\n\n\t\tif ( invdiry >= 0 ) {\n\n\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\n\n\t\t} else {\n\n\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\n\n\t\t}\n\n\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\n\n\t\tif ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;\n\n\t\tif ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;\n\n\t\tif ( invdirz >= 0 ) {\n\n\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\n\n\t\t} else {\n\n\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\n\n\t\t}\n\n\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\n\n\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t\t//return point closest to the ray (positive side)\n\n\t\tif ( tmax < 0 ) return null;\n\n\t\treturn this.at( tmin >= 0 ? tmin : tmax, target );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn this.intersectBox( box, _vector$a ) !== null;\n\n\t}\n\n\tintersectTriangle( a, b, c, backfaceCulling, target ) {\n\n\t\t// Compute the offset origin, edges, and normal.\n\n\t\t// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\n\t\t_edge1.subVectors( b, a );\n\t\t_edge2.subVectors( c, a );\n\t\t_normal$1.crossVectors( _edge1, _edge2 );\n\n\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\tlet DdN = this.direction.dot( _normal$1 );\n\t\tlet sign;\n\n\t\tif ( DdN > 0 ) {\n\n\t\t\tif ( backfaceCulling ) return null;\n\t\t\tsign = 1;\n\n\t\t} else if ( DdN < 0 ) {\n\n\t\t\tsign = - 1;\n\t\t\tDdN = - DdN;\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t_diff.subVectors( this.origin, a );\n\t\tconst DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );\n\n\t\t// b1 < 0, no intersection\n\t\tif ( DdQxE2 < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );\n\n\t\t// b2 < 0, no intersection\n\t\tif ( DdE1xQ < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// b1+b2 > 1, no intersection\n\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// Line intersects triangle, check if ray does.\n\t\tconst QdN = - sign * _diff.dot( _normal$1 );\n\n\t\t// t < 0, no intersection\n\t\tif ( QdN < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// Ray intersects triangle.\n\t\treturn this.at( QdN / DdN, target );\n\n\t}\n\n\tapplyMatrix4( matrix4 ) {\n\n\t\tthis.origin.applyMatrix4( matrix4 );\n\t\tthis.direction.transformDirection( matrix4 );\n\n\t\treturn this;\n\n\t}\n\n\tequals( ray ) {\n\n\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nclass Matrix4 {\n\n\tconstructor( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\t\tMatrix4.prototype.isMatrix4 = true;\n\n\t\tthis.elements = [\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t];\n\n\t\tif ( n11 !== undefined ) {\n\n\t\t\tthis.set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 );\n\n\t\t}\n\n\t}\n\n\tset( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\n\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\n\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\n\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\n\n\t\treturn this;\n\n\t}\n\n\tidentity() {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new Matrix4().fromArray( this.elements );\n\n\t}\n\n\tcopy( m ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = m.elements;\n\n\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];\n\t\tte[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];\n\t\tte[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];\n\t\tte[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];\n\n\t\treturn this;\n\n\t}\n\n\tcopyPosition( m ) {\n\n\t\tconst te = this.elements, me = m.elements;\n\n\t\tte[ 12 ] = me[ 12 ];\n\t\tte[ 13 ] = me[ 13 ];\n\t\tte[ 14 ] = me[ 14 ];\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrix3( m ) {\n\n\t\tconst me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[ 0 ], me[ 3 ], me[ 6 ], 0,\n\t\t\tme[ 1 ], me[ 4 ], me[ 7 ], 0,\n\t\t\tme[ 2 ], me[ 5 ], me[ 8 ], 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\textractBasis( xAxis, yAxis, zAxis ) {\n\n\t\txAxis.setFromMatrixColumn( this, 0 );\n\t\tyAxis.setFromMatrixColumn( this, 1 );\n\t\tzAxis.setFromMatrixColumn( this, 2 );\n\n\t\treturn this;\n\n\t}\n\n\tmakeBasis( xAxis, yAxis, zAxis ) {\n\n\t\tthis.set(\n\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\n\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\n\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\n\t\t\t0, 0, 0, 1\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\textractRotation( m ) {\n\n\t\t// this method does not support reflection matrices\n\n\t\tconst te = this.elements;\n\t\tconst me = m.elements;\n\n\t\tconst scaleX = 1 / _v1$5.setFromMatrixColumn( m, 0 ).length();\n\t\tconst scaleY = 1 / _v1$5.setFromMatrixColumn( m, 1 ).length();\n\t\tconst scaleZ = 1 / _v1$5.setFromMatrixColumn( m, 2 ).length();\n\n\t\tte[ 0 ] = me[ 0 ] * scaleX;\n\t\tte[ 1 ] = me[ 1 ] * scaleX;\n\t\tte[ 2 ] = me[ 2 ] * scaleX;\n\t\tte[ 3 ] = 0;\n\n\t\tte[ 4 ] = me[ 4 ] * scaleY;\n\t\tte[ 5 ] = me[ 5 ] * scaleY;\n\t\tte[ 6 ] = me[ 6 ] * scaleY;\n\t\tte[ 7 ] = 0;\n\n\t\tte[ 8 ] = me[ 8 ] * scaleZ;\n\t\tte[ 9 ] = me[ 9 ] * scaleZ;\n\t\tte[ 10 ] = me[ 10 ] * scaleZ;\n\t\tte[ 11 ] = 0;\n\n\t\tte[ 12 ] = 0;\n\t\tte[ 13 ] = 0;\n\t\tte[ 14 ] = 0;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationFromEuler( euler ) {\n\n\t\tconst te = this.elements;\n\n\t\tconst x = euler.x, y = euler.y, z = euler.z;\n\t\tconst a = Math.cos( x ), b = Math.sin( x );\n\t\tconst c = Math.cos( y ), d = Math.sin( y );\n\t\tconst e = Math.cos( z ), f = Math.sin( z );\n\n\t\tif ( euler.order === 'XYZ' ) {\n\n\t\t\tconst ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = - c * f;\n\t\t\tte[ 8 ] = d;\n\n\t\t\tte[ 1 ] = af + be * d;\n\t\t\tte[ 5 ] = ae - bf * d;\n\t\t\tte[ 9 ] = - b * c;\n\n\t\t\tte[ 2 ] = bf - ae * d;\n\t\t\tte[ 6 ] = be + af * d;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'YXZ' ) {\n\n\t\t\tconst ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[ 0 ] = ce + df * b;\n\t\t\tte[ 4 ] = de * b - cf;\n\t\t\tte[ 8 ] = a * d;\n\n\t\t\tte[ 1 ] = a * f;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = - b;\n\n\t\t\tte[ 2 ] = cf * b - de;\n\t\t\tte[ 6 ] = df + ce * b;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'ZXY' ) {\n\n\t\t\tconst ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[ 0 ] = ce - df * b;\n\t\t\tte[ 4 ] = - a * f;\n\t\t\tte[ 8 ] = de + cf * b;\n\n\t\t\tte[ 1 ] = cf + de * b;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = df - ce * b;\n\n\t\t\tte[ 2 ] = - a * d;\n\t\t\tte[ 6 ] = b;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'ZYX' ) {\n\n\t\t\tconst ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = be * d - af;\n\t\t\tte[ 8 ] = ae * d + bf;\n\n\t\t\tte[ 1 ] = c * f;\n\t\t\tte[ 5 ] = bf * d + ae;\n\t\t\tte[ 9 ] = af * d - be;\n\n\t\t\tte[ 2 ] = - d;\n\t\t\tte[ 6 ] = b * c;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'YZX' ) {\n\n\t\t\tconst ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = bd - ac * f;\n\t\t\tte[ 8 ] = bc * f + ad;\n\n\t\t\tte[ 1 ] = f;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = - b * e;\n\n\t\t\tte[ 2 ] = - d * e;\n\t\t\tte[ 6 ] = ad * f + bc;\n\t\t\tte[ 10 ] = ac - bd * f;\n\n\t\t} else if ( euler.order === 'XZY' ) {\n\n\t\t\tconst ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = - f;\n\t\t\tte[ 8 ] = d * e;\n\n\t\t\tte[ 1 ] = ac * f + bd;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = ad * f - bc;\n\n\t\t\tte[ 2 ] = bc * f - ad;\n\t\t\tte[ 6 ] = b * e;\n\t\t\tte[ 10 ] = bd * f + ac;\n\n\t\t}\n\n\t\t// bottom row\n\t\tte[ 3 ] = 0;\n\t\tte[ 7 ] = 0;\n\t\tte[ 11 ] = 0;\n\n\t\t// last column\n\t\tte[ 12 ] = 0;\n\t\tte[ 13 ] = 0;\n\t\tte[ 14 ] = 0;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationFromQuaternion( q ) {\n\n\t\treturn this.compose( _zero, q, _one );\n\n\t}\n\n\tlookAt( eye, target, up ) {\n\n\t\tconst te = this.elements;\n\n\t\t_z.subVectors( eye, target );\n\n\t\tif ( _z.lengthSq() === 0 ) {\n\n\t\t\t// eye and target are in the same position\n\n\t\t\t_z.z = 1;\n\n\t\t}\n\n\t\t_z.normalize();\n\t\t_x.crossVectors( up, _z );\n\n\t\tif ( _x.lengthSq() === 0 ) {\n\n\t\t\t// up and z are parallel\n\n\t\t\tif ( Math.abs( up.z ) === 1 ) {\n\n\t\t\t\t_z.x += 0.0001;\n\n\t\t\t} else {\n\n\t\t\t\t_z.z += 0.0001;\n\n\t\t\t}\n\n\t\t\t_z.normalize();\n\t\t\t_x.crossVectors( up, _z );\n\n\t\t}\n\n\t\t_x.normalize();\n\t\t_y.crossVectors( _z, _x );\n\n\t\tte[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;\n\t\tte[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;\n\t\tte[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( m ) {\n\n\t\treturn this.multiplyMatrices( this, m );\n\n\t}\n\n\tpremultiply( m ) {\n\n\t\treturn this.multiplyMatrices( m, this );\n\n\t}\n\n\tmultiplyMatrices( a, b ) {\n\n\t\tconst ae = a.elements;\n\t\tconst be = b.elements;\n\t\tconst te = this.elements;\n\n\t\tconst a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\n\t\tconst a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\n\t\tconst a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\n\t\tconst a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\n\n\t\tconst b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\n\t\tconst b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\n\t\tconst b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\n\t\tconst b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\n\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( s ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\n\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\n\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\n\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\n\n\t\treturn this;\n\n\t}\n\n\tdeterminant() {\n\n\t\tconst te = this.elements;\n\n\t\tconst n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\n\t\tconst n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\n\t\tconst n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\n\t\tconst n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\n\n\t\t//TODO: make this more efficient\n\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n\t\treturn (\n\t\t\tn41 * (\n\t\t\t\t+ n14 * n23 * n32\n\t\t\t\t - n13 * n24 * n32\n\t\t\t\t - n14 * n22 * n33\n\t\t\t\t + n12 * n24 * n33\n\t\t\t\t + n13 * n22 * n34\n\t\t\t\t - n12 * n23 * n34\n\t\t\t) +\n\t\t\tn42 * (\n\t\t\t\t+ n11 * n23 * n34\n\t\t\t\t - n11 * n24 * n33\n\t\t\t\t + n14 * n21 * n33\n\t\t\t\t - n13 * n21 * n34\n\t\t\t\t + n13 * n24 * n31\n\t\t\t\t - n14 * n23 * n31\n\t\t\t) +\n\t\t\tn43 * (\n\t\t\t\t+ n11 * n24 * n32\n\t\t\t\t - n11 * n22 * n34\n\t\t\t\t - n14 * n21 * n32\n\t\t\t\t + n12 * n21 * n34\n\t\t\t\t + n14 * n22 * n31\n\t\t\t\t - n12 * n24 * n31\n\t\t\t) +\n\t\t\tn44 * (\n\t\t\t\t- n13 * n22 * n31\n\t\t\t\t - n11 * n23 * n32\n\t\t\t\t + n11 * n22 * n33\n\t\t\t\t + n13 * n21 * n32\n\t\t\t\t - n12 * n21 * n33\n\t\t\t\t + n12 * n23 * n31\n\t\t\t)\n\n\t\t);\n\n\t}\n\n\ttranspose() {\n\n\t\tconst te = this.elements;\n\t\tlet tmp;\n\n\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\n\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\n\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\n\n\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\n\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\n\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\n\n\t\treturn this;\n\n\t}\n\n\tsetPosition( x, y, z ) {\n\n\t\tconst te = this.elements;\n\n\t\tif ( x.isVector3 ) {\n\n\t\t\tte[ 12 ] = x.x;\n\t\t\tte[ 13 ] = x.y;\n\t\t\tte[ 14 ] = x.z;\n\n\t\t} else {\n\n\t\t\tte[ 12 ] = x;\n\t\t\tte[ 13 ] = y;\n\t\t\tte[ 14 ] = z;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tinvert() {\n\n\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\tconst te = this.elements,\n\n\t\t\tn11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],\n\t\t\tn12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],\n\t\t\tn13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],\n\t\t\tn14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],\n\n\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\n\t\tconst det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\n\t\tif ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );\n\n\t\tconst detInv = 1 / det;\n\n\t\tte[ 0 ] = t11 * detInv;\n\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\n\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\n\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\n\n\t\tte[ 4 ] = t12 * detInv;\n\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\n\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\n\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\n\n\t\tte[ 8 ] = t13 * detInv;\n\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\n\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\n\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\n\n\t\tte[ 12 ] = t14 * detInv;\n\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\n\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\n\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\n\n\t\treturn this;\n\n\t}\n\n\tscale( v ) {\n\n\t\tconst te = this.elements;\n\t\tconst x = v.x, y = v.y, z = v.z;\n\n\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\n\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\n\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\n\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\n\n\t\treturn this;\n\n\t}\n\n\tgetMaxScaleOnAxis() {\n\n\t\tconst te = this.elements;\n\n\t\tconst scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\n\t\tconst scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\n\t\tconst scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\n\n\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\n\n\t}\n\n\tmakeTranslation( x, y, z ) {\n\n\t\tif ( x.isVector3 ) {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, 0, x.x,\n\t\t\t\t0, 1, 0, x.y,\n\t\t\t\t0, 0, 1, x.z,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, 0, x,\n\t\t\t\t0, 1, 0, y,\n\t\t\t\t0, 0, 1, z,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationX( theta ) {\n\n\t\tconst c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, c, - s, 0,\n\t\t\t0, s, c, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationY( theta ) {\n\n\t\tconst c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t c, 0, s, 0,\n\t\t\t 0, 1, 0, 0,\n\t\t\t- s, 0, c, 0,\n\t\t\t 0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationZ( theta ) {\n\n\t\tconst c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\tc, - s, 0, 0,\n\t\t\ts, c, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationAxis( axis, angle ) {\n\n\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n\t\tconst c = Math.cos( angle );\n\t\tconst s = Math.sin( angle );\n\t\tconst t = 1 - c;\n\t\tconst x = axis.x, y = axis.y, z = axis.z;\n\t\tconst tx = t * x, ty = t * y;\n\n\t\tthis.set(\n\n\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\n\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\n\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeScale( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\tx, 0, 0, 0,\n\t\t\t0, y, 0, 0,\n\t\t\t0, 0, z, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeShear( xy, xz, yx, yz, zx, zy ) {\n\n\t\tthis.set(\n\n\t\t\t1, yx, zx, 0,\n\t\t\txy, 1, zy, 0,\n\t\t\txz, yz, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tcompose( position, quaternion, scale ) {\n\n\t\tconst te = this.elements;\n\n\t\tconst x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;\n\t\tconst x2 = x + x,\ty2 = y + y, z2 = z + z;\n\t\tconst xx = x * x2, xy = x * y2, xz = x * z2;\n\t\tconst yy = y * y2, yz = y * z2, zz = z * z2;\n\t\tconst wx = w * x2, wy = w * y2, wz = w * z2;\n\n\t\tconst sx = scale.x, sy = scale.y, sz = scale.z;\n\n\t\tte[ 0 ] = ( 1 - ( yy + zz ) ) * sx;\n\t\tte[ 1 ] = ( xy + wz ) * sx;\n\t\tte[ 2 ] = ( xz - wy ) * sx;\n\t\tte[ 3 ] = 0;\n\n\t\tte[ 4 ] = ( xy - wz ) * sy;\n\t\tte[ 5 ] = ( 1 - ( xx + zz ) ) * sy;\n\t\tte[ 6 ] = ( yz + wx ) * sy;\n\t\tte[ 7 ] = 0;\n\n\t\tte[ 8 ] = ( xz + wy ) * sz;\n\t\tte[ 9 ] = ( yz - wx ) * sz;\n\t\tte[ 10 ] = ( 1 - ( xx + yy ) ) * sz;\n\t\tte[ 11 ] = 0;\n\n\t\tte[ 12 ] = position.x;\n\t\tte[ 13 ] = position.y;\n\t\tte[ 14 ] = position.z;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\tdecompose( position, quaternion, scale ) {\n\n\t\tconst te = this.elements;\n\n\t\tlet sx = _v1$5.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\n\t\tconst sy = _v1$5.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\n\t\tconst sz = _v1$5.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\n\n\t\t// if determine is negative, we need to invert one scale\n\t\tconst det = this.determinant();\n\t\tif ( det < 0 ) sx = - sx;\n\n\t\tposition.x = te[ 12 ];\n\t\tposition.y = te[ 13 ];\n\t\tposition.z = te[ 14 ];\n\n\t\t// scale the rotation part\n\t\t_m1$2.copy( this );\n\n\t\tconst invSX = 1 / sx;\n\t\tconst invSY = 1 / sy;\n\t\tconst invSZ = 1 / sz;\n\n\t\t_m1$2.elements[ 0 ] *= invSX;\n\t\t_m1$2.elements[ 1 ] *= invSX;\n\t\t_m1$2.elements[ 2 ] *= invSX;\n\n\t\t_m1$2.elements[ 4 ] *= invSY;\n\t\t_m1$2.elements[ 5 ] *= invSY;\n\t\t_m1$2.elements[ 6 ] *= invSY;\n\n\t\t_m1$2.elements[ 8 ] *= invSZ;\n\t\t_m1$2.elements[ 9 ] *= invSZ;\n\t\t_m1$2.elements[ 10 ] *= invSZ;\n\n\t\tquaternion.setFromRotationMatrix( _m1$2 );\n\n\t\tscale.x = sx;\n\t\tscale.y = sy;\n\t\tscale.z = sz;\n\n\t\treturn this;\n\n\t}\n\n\tmakePerspective( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem ) {\n\n\t\tconst te = this.elements;\n\t\tconst x = 2 * near / ( right - left );\n\t\tconst y = 2 * near / ( top - bottom );\n\n\t\tconst a = ( right + left ) / ( right - left );\n\t\tconst b = ( top + bottom ) / ( top - bottom );\n\n\t\tlet c, d;\n\n\t\tif ( coordinateSystem === WebGLCoordinateSystem ) {\n\n\t\t\tc = - ( far + near ) / ( far - near );\n\t\t\td = ( - 2 * far * near ) / ( far - near );\n\n\t\t} else if ( coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\tc = - far / ( far - near );\n\t\t\td = ( - far * near ) / ( far - near );\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + coordinateSystem );\n\n\t\t}\n\n\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a; \tte[ 12 ] = 0;\n\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b; \tte[ 13 ] = 0;\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c; \tte[ 14 ] = d;\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\n\n\t\treturn this;\n\n\t}\n\n\tmakeOrthographic( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem ) {\n\n\t\tconst te = this.elements;\n\t\tconst w = 1.0 / ( right - left );\n\t\tconst h = 1.0 / ( top - bottom );\n\t\tconst p = 1.0 / ( far - near );\n\n\t\tconst x = ( right + left ) * w;\n\t\tconst y = ( top + bottom ) * h;\n\n\t\tlet z, zInv;\n\n\t\tif ( coordinateSystem === WebGLCoordinateSystem ) {\n\n\t\t\tz = ( far + near ) * p;\n\t\t\tzInv = - 2 * p;\n\n\t\t} else if ( coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\tz = near * p;\n\t\t\tzInv = - 1 * p;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + coordinateSystem );\n\n\t\t}\n\n\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\t\tte[ 8 ] = 0; \t\tte[ 12 ] = - x;\n\t\tte[ 1 ] = 0; \t\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0; \t\tte[ 13 ] = - y;\n\t\tte[ 2 ] = 0; \t\tte[ 6 ] = 0;\t\tte[ 10 ] = zInv;\tte[ 14 ] = - z;\n\t\tte[ 3 ] = 0; \t\tte[ 7 ] = 0;\t\tte[ 11 ] = 0;\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\tequals( matrix ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = matrix.elements;\n\n\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tconst te = this.elements;\n\n\t\tarray[ offset ] = te[ 0 ];\n\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\tarray[ offset + 2 ] = te[ 2 ];\n\t\tarray[ offset + 3 ] = te[ 3 ];\n\n\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\tarray[ offset + 5 ] = te[ 5 ];\n\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\tarray[ offset + 7 ] = te[ 7 ];\n\n\t\tarray[ offset + 8 ] = te[ 8 ];\n\t\tarray[ offset + 9 ] = te[ 9 ];\n\t\tarray[ offset + 10 ] = te[ 10 ];\n\t\tarray[ offset + 11 ] = te[ 11 ];\n\n\t\tarray[ offset + 12 ] = te[ 12 ];\n\t\tarray[ offset + 13 ] = te[ 13 ];\n\t\tarray[ offset + 14 ] = te[ 14 ];\n\t\tarray[ offset + 15 ] = te[ 15 ];\n\n\t\treturn array;\n\n\t}\n\n}\n\nconst _v1$5 = /*@__PURE__*/ new Vector3();\nconst _m1$2 = /*@__PURE__*/ new Matrix4();\nconst _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );\nconst _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );\nconst _x = /*@__PURE__*/ new Vector3();\nconst _y = /*@__PURE__*/ new Vector3();\nconst _z = /*@__PURE__*/ new Vector3();\n\nconst _matrix$2 = /*@__PURE__*/ new Matrix4();\nconst _quaternion$3 = /*@__PURE__*/ new Quaternion();\n\nclass Euler {\n\n\tconstructor( x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER ) {\n\n\t\tthis.isEuler = true;\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._order = order;\n\n\t}\n\n\tget x() {\n\n\t\treturn this._x;\n\n\t}\n\n\tset x( value ) {\n\n\t\tthis._x = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget y() {\n\n\t\treturn this._y;\n\n\t}\n\n\tset y( value ) {\n\n\t\tthis._y = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget z() {\n\n\t\treturn this._z;\n\n\t}\n\n\tset z( value ) {\n\n\t\tthis._z = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget order() {\n\n\t\treturn this._order;\n\n\t}\n\n\tset order( value ) {\n\n\t\tthis._order = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tset( x, y, z, order = this._order ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._order = order;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\n\n\t}\n\n\tcopy( euler ) {\n\n\t\tthis._x = euler._x;\n\t\tthis._y = euler._y;\n\t\tthis._z = euler._z;\n\t\tthis._order = euler._order;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromRotationMatrix( m, order = this._order, update = true ) {\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tconst te = m.elements;\n\t\tconst m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\n\t\tconst m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\n\t\tconst m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\tswitch ( order ) {\n\n\t\t\tcase 'XYZ':\n\n\t\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m13 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\tthis._z = Math.atan2( - m12, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\tthis._z = 0;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'YXZ':\n\n\t\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m23 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\t\t\t\t\tthis._z = Math.atan2( m21, m22 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\t\t\t\t\tthis._z = 0;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZXY':\n\n\t\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m32 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._y = Math.atan2( - m31, m33 );\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._y = 0;\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZYX':\n\n\t\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m31 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m33 );\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'YZX':\n\n\t\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m21 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m22 );\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'XZY':\n\n\t\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m12 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\tthis._y = Math.atan2( m13, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\tthis._y = 0;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );\n\n\t\t}\n\n\t\tthis._order = order;\n\n\t\tif ( update === true ) this._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromQuaternion( q, order, update ) {\n\n\t\t_matrix$2.makeRotationFromQuaternion( q );\n\n\t\treturn this.setFromRotationMatrix( _matrix$2, order, update );\n\n\t}\n\n\tsetFromVector3( v, order = this._order ) {\n\n\t\treturn this.set( v.x, v.y, v.z, order );\n\n\t}\n\n\treorder( newOrder ) {\n\n\t\t// WARNING: this discards revolution information -bhouston\n\n\t\t_quaternion$3.setFromEuler( this );\n\n\t\treturn this.setFromQuaternion( _quaternion$3, newOrder );\n\n\t}\n\n\tequals( euler ) {\n\n\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\n\n\t}\n\n\tfromArray( array ) {\n\n\t\tthis._x = array[ 0 ];\n\t\tthis._y = array[ 1 ];\n\t\tthis._z = array[ 2 ];\n\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this._x;\n\t\tarray[ offset + 1 ] = this._y;\n\t\tarray[ offset + 2 ] = this._z;\n\t\tarray[ offset + 3 ] = this._order;\n\n\t\treturn array;\n\n\t}\n\n\t_onChange( callback ) {\n\n\t\tthis._onChangeCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n\t_onChangeCallback() {}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this._x;\n\t\tyield this._y;\n\t\tyield this._z;\n\t\tyield this._order;\n\n\t}\n\n}\n\nEuler.DEFAULT_ORDER = 'XYZ';\n\nclass Layers {\n\n\tconstructor() {\n\n\t\tthis.mask = 1 | 0;\n\n\t}\n\n\tset( channel ) {\n\n\t\tthis.mask = ( 1 << channel | 0 ) >>> 0;\n\n\t}\n\n\tenable( channel ) {\n\n\t\tthis.mask |= 1 << channel | 0;\n\n\t}\n\n\tenableAll() {\n\n\t\tthis.mask = 0xffffffff | 0;\n\n\t}\n\n\ttoggle( channel ) {\n\n\t\tthis.mask ^= 1 << channel | 0;\n\n\t}\n\n\tdisable( channel ) {\n\n\t\tthis.mask &= ~ ( 1 << channel | 0 );\n\n\t}\n\n\tdisableAll() {\n\n\t\tthis.mask = 0;\n\n\t}\n\n\ttest( layers ) {\n\n\t\treturn ( this.mask & layers.mask ) !== 0;\n\n\t}\n\n\tisEnabled( channel ) {\n\n\t\treturn ( this.mask & ( 1 << channel | 0 ) ) !== 0;\n\n\t}\n\n}\n\nlet _object3DId = 0;\n\nconst _v1$4 = /*@__PURE__*/ new Vector3();\nconst _q1 = /*@__PURE__*/ new Quaternion();\nconst _m1$1 = /*@__PURE__*/ new Matrix4();\nconst _target = /*@__PURE__*/ new Vector3();\n\nconst _position$3 = /*@__PURE__*/ new Vector3();\nconst _scale$2 = /*@__PURE__*/ new Vector3();\nconst _quaternion$2 = /*@__PURE__*/ new Quaternion();\n\nconst _xAxis = /*@__PURE__*/ new Vector3( 1, 0, 0 );\nconst _yAxis = /*@__PURE__*/ new Vector3( 0, 1, 0 );\nconst _zAxis = /*@__PURE__*/ new Vector3( 0, 0, 1 );\n\nconst _addedEvent = { type: 'added' };\nconst _removedEvent = { type: 'removed' };\n\nconst _childaddedEvent = { type: 'childadded', child: null };\nconst _childremovedEvent = { type: 'childremoved', child: null };\n\nclass Object3D extends EventDispatcher {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isObject3D = true;\n\n\t\tObject.defineProperty( this, 'id', { value: _object3DId ++ } );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'Object3D';\n\n\t\tthis.parent = null;\n\t\tthis.children = [];\n\n\t\tthis.up = Object3D.DEFAULT_UP.clone();\n\n\t\tconst position = new Vector3();\n\t\tconst rotation = new Euler();\n\t\tconst quaternion = new Quaternion();\n\t\tconst scale = new Vector3( 1, 1, 1 );\n\n\t\tfunction onRotationChange() {\n\n\t\t\tquaternion.setFromEuler( rotation, false );\n\n\t\t}\n\n\t\tfunction onQuaternionChange() {\n\n\t\t\trotation.setFromQuaternion( quaternion, undefined, false );\n\n\t\t}\n\n\t\trotation._onChange( onRotationChange );\n\t\tquaternion._onChange( onQuaternionChange );\n\n\t\tObject.defineProperties( this, {\n\t\t\tposition: {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: position\n\t\t\t},\n\t\t\trotation: {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: rotation\n\t\t\t},\n\t\t\tquaternion: {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: quaternion\n\t\t\t},\n\t\t\tscale: {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: scale\n\t\t\t},\n\t\t\tmodelViewMatrix: {\n\t\t\t\tvalue: new Matrix4()\n\t\t\t},\n\t\t\tnormalMatrix: {\n\t\t\t\tvalue: new Matrix3()\n\t\t\t}\n\t\t} );\n\n\t\tthis.matrix = new Matrix4();\n\t\tthis.matrixWorld = new Matrix4();\n\n\t\tthis.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;\n\n\t\tthis.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE; // checked by the renderer\n\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\tthis.layers = new Layers();\n\t\tthis.visible = true;\n\n\t\tthis.castShadow = false;\n\t\tthis.receiveShadow = false;\n\n\t\tthis.frustumCulled = true;\n\t\tthis.renderOrder = 0;\n\n\t\tthis.animations = [];\n\n\t\tthis.userData = {};\n\n\t}\n\n\tonBeforeShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */ ) {}\n\n\tonAfterShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */ ) {}\n\n\tonBeforeRender( /* renderer, scene, camera, geometry, material, group */ ) {}\n\n\tonAfterRender( /* renderer, scene, camera, geometry, material, group */ ) {}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\n\n\t\tthis.matrix.premultiply( matrix );\n\n\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\n\n\t}\n\n\tapplyQuaternion( q ) {\n\n\t\tthis.quaternion.premultiply( q );\n\n\t\treturn this;\n\n\t}\n\n\tsetRotationFromAxisAngle( axis, angle ) {\n\n\t\t// assumes axis is normalized\n\n\t\tthis.quaternion.setFromAxisAngle( axis, angle );\n\n\t}\n\n\tsetRotationFromEuler( euler ) {\n\n\t\tthis.quaternion.setFromEuler( euler, true );\n\n\t}\n\n\tsetRotationFromMatrix( m ) {\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tthis.quaternion.setFromRotationMatrix( m );\n\n\t}\n\n\tsetRotationFromQuaternion( q ) {\n\n\t\t// assumes q is normalized\n\n\t\tthis.quaternion.copy( q );\n\n\t}\n\n\trotateOnAxis( axis, angle ) {\n\n\t\t// rotate object on axis in object space\n\t\t// axis is assumed to be normalized\n\n\t\t_q1.setFromAxisAngle( axis, angle );\n\n\t\tthis.quaternion.multiply( _q1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateOnWorldAxis( axis, angle ) {\n\n\t\t// rotate object on axis in world space\n\t\t// axis is assumed to be normalized\n\t\t// method assumes no rotated parent\n\n\t\t_q1.setFromAxisAngle( axis, angle );\n\n\t\tthis.quaternion.premultiply( _q1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateX( angle ) {\n\n\t\treturn this.rotateOnAxis( _xAxis, angle );\n\n\t}\n\n\trotateY( angle ) {\n\n\t\treturn this.rotateOnAxis( _yAxis, angle );\n\n\t}\n\n\trotateZ( angle ) {\n\n\t\treturn this.rotateOnAxis( _zAxis, angle );\n\n\t}\n\n\ttranslateOnAxis( axis, distance ) {\n\n\t\t// translate object by distance along axis in object space\n\t\t// axis is assumed to be normalized\n\n\t\t_v1$4.copy( axis ).applyQuaternion( this.quaternion );\n\n\t\tthis.position.add( _v1$4.multiplyScalar( distance ) );\n\n\t\treturn this;\n\n\t}\n\n\ttranslateX( distance ) {\n\n\t\treturn this.translateOnAxis( _xAxis, distance );\n\n\t}\n\n\ttranslateY( distance ) {\n\n\t\treturn this.translateOnAxis( _yAxis, distance );\n\n\t}\n\n\ttranslateZ( distance ) {\n\n\t\treturn this.translateOnAxis( _zAxis, distance );\n\n\t}\n\n\tlocalToWorld( vector ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\treturn vector.applyMatrix4( this.matrixWorld );\n\n\t}\n\n\tworldToLocal( vector ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\treturn vector.applyMatrix4( _m1$1.copy( this.matrixWorld ).invert() );\n\n\t}\n\n\tlookAt( x, y, z ) {\n\n\t\t// This method does not support objects having non-uniformly-scaled parent(s)\n\n\t\tif ( x.isVector3 ) {\n\n\t\t\t_target.copy( x );\n\n\t\t} else {\n\n\t\t\t_target.set( x, y, z );\n\n\t\t}\n\n\t\tconst parent = this.parent;\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\t_position$3.setFromMatrixPosition( this.matrixWorld );\n\n\t\tif ( this.isCamera || this.isLight ) {\n\n\t\t\t_m1$1.lookAt( _position$3, _target, this.up );\n\n\t\t} else {\n\n\t\t\t_m1$1.lookAt( _target, _position$3, this.up );\n\n\t\t}\n\n\t\tthis.quaternion.setFromRotationMatrix( _m1$1 );\n\n\t\tif ( parent ) {\n\n\t\t\t_m1$1.extractRotation( parent.matrixWorld );\n\t\t\t_q1.setFromRotationMatrix( _m1$1 );\n\t\t\tthis.quaternion.premultiply( _q1.invert() );\n\n\t\t}\n\n\t}\n\n\tadd( object ) {\n\n\t\tif ( arguments.length > 1 ) {\n\n\t\t\tfor ( let i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\tthis.add( arguments[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( object === this ) {\n\n\t\t\tconsole.error( 'THREE.Object3D.add: object can\\'t be added as a child of itself.', object );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( object && object.isObject3D ) {\n\n\t\t\tobject.removeFromParent();\n\t\t\tobject.parent = this;\n\t\t\tthis.children.push( object );\n\n\t\t\tobject.dispatchEvent( _addedEvent );\n\n\t\t\t_childaddedEvent.child = object;\n\t\t\tthis.dispatchEvent( _childaddedEvent );\n\t\t\t_childaddedEvent.child = null;\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tremove( object ) {\n\n\t\tif ( arguments.length > 1 ) {\n\n\t\t\tfor ( let i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\tthis.remove( arguments[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst index = this.children.indexOf( object );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\tobject.parent = null;\n\t\t\tthis.children.splice( index, 1 );\n\n\t\t\tobject.dispatchEvent( _removedEvent );\n\n\t\t\t_childremovedEvent.child = object;\n\t\t\tthis.dispatchEvent( _childremovedEvent );\n\t\t\t_childremovedEvent.child = null;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tremoveFromParent() {\n\n\t\tconst parent = this.parent;\n\n\t\tif ( parent !== null ) {\n\n\t\t\tparent.remove( this );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclear() {\n\n\t\treturn this.remove( ... this.children );\n\n\t}\n\n\tattach( object ) {\n\n\t\t// adds object as a child of this, while maintaining the object's world transform\n\n\t\t// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\t_m1$1.copy( this.matrixWorld ).invert();\n\n\t\tif ( object.parent !== null ) {\n\n\t\t\tobject.parent.updateWorldMatrix( true, false );\n\n\t\t\t_m1$1.multiply( object.parent.matrixWorld );\n\n\t\t}\n\n\t\tobject.applyMatrix4( _m1$1 );\n\n\t\tobject.removeFromParent();\n\t\tobject.parent = this;\n\t\tthis.children.push( object );\n\n\t\tobject.updateWorldMatrix( false, true );\n\n\t\tobject.dispatchEvent( _addedEvent );\n\n\t\t_childaddedEvent.child = object;\n\t\tthis.dispatchEvent( _childaddedEvent );\n\t\t_childaddedEvent.child = null;\n\n\t\treturn this;\n\n\t}\n\n\tgetObjectById( id ) {\n\n\t\treturn this.getObjectByProperty( 'id', id );\n\n\t}\n\n\tgetObjectByName( name ) {\n\n\t\treturn this.getObjectByProperty( 'name', name );\n\n\t}\n\n\tgetObjectByProperty( name, value ) {\n\n\t\tif ( this[ name ] === value ) return this;\n\n\t\tfor ( let i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tconst child = this.children[ i ];\n\t\t\tconst object = child.getObjectByProperty( name, value );\n\n\t\t\tif ( object !== undefined ) {\n\n\t\t\t\treturn object;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn undefined;\n\n\t}\n\n\tgetObjectsByProperty( name, value, result = [] ) {\n\n\t\tif ( this[ name ] === value ) result.push( this );\n\n\t\tconst children = this.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].getObjectsByProperty( name, value, result );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tgetWorldPosition( target ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\treturn target.setFromMatrixPosition( this.matrixWorld );\n\n\t}\n\n\tgetWorldQuaternion( target ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\tthis.matrixWorld.decompose( _position$3, target, _scale$2 );\n\n\t\treturn target;\n\n\t}\n\n\tgetWorldScale( target ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\tthis.matrixWorld.decompose( _position$3, _quaternion$2, target );\n\n\t\treturn target;\n\n\t}\n\n\tgetWorldDirection( target ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\tconst e = this.matrixWorld.elements;\n\n\t\treturn target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();\n\n\t}\n\n\traycast( /* raycaster, intersects */ ) {}\n\n\ttraverse( callback ) {\n\n\t\tcallback( this );\n\n\t\tconst children = this.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].traverse( callback );\n\n\t\t}\n\n\t}\n\n\ttraverseVisible( callback ) {\n\n\t\tif ( this.visible === false ) return;\n\n\t\tcallback( this );\n\n\t\tconst children = this.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].traverseVisible( callback );\n\n\t\t}\n\n\t}\n\n\ttraverseAncestors( callback ) {\n\n\t\tconst parent = this.parent;\n\n\t\tif ( parent !== null ) {\n\n\t\t\tcallback( parent );\n\n\t\t\tparent.traverseAncestors( callback );\n\n\t\t}\n\n\t}\n\n\tupdateMatrix() {\n\n\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\n\n\t\tthis.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\n\n\t\tif ( this.matrixWorldNeedsUpdate || force ) {\n\n\t\t\tif ( this.matrixWorldAutoUpdate === true ) {\n\n\t\t\t\tif ( this.parent === null ) {\n\n\t\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\tforce = true;\n\n\t\t}\n\n\t\t// make sure descendants are updated if required\n\n\t\tconst children = this.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tconst child = children[ i ];\n\n\t\t\tchild.updateMatrixWorld( force );\n\n\t\t}\n\n\t}\n\n\tupdateWorldMatrix( updateParents, updateChildren ) {\n\n\t\tconst parent = this.parent;\n\n\t\tif ( updateParents === true && parent !== null ) {\n\n\t\t\tparent.updateWorldMatrix( true, false );\n\n\t\t}\n\n\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\n\n\t\tif ( this.matrixWorldAutoUpdate === true ) {\n\n\t\t\tif ( this.parent === null ) {\n\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t\t} else {\n\n\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// make sure descendants are updated\n\n\t\tif ( updateChildren === true ) {\n\n\t\t\tconst children = this.children;\n\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = children[ i ];\n\n\t\t\t\tchild.updateWorldMatrix( false, true );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\t// meta is a string when called from JSON.stringify\n\t\tconst isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tconst output = {};\n\n\t\t// meta is a hash used to collect geometries, materials.\n\t\t// not providing it implies that this is the root object\n\t\t// being serialized.\n\t\tif ( isRootObject ) {\n\n\t\t\t// initialize meta obj\n\t\t\tmeta = {\n\t\t\t\tgeometries: {},\n\t\t\t\tmaterials: {},\n\t\t\t\ttextures: {},\n\t\t\t\timages: {},\n\t\t\t\tshapes: {},\n\t\t\t\tskeletons: {},\n\t\t\t\tanimations: {},\n\t\t\t\tnodes: {}\n\t\t\t};\n\n\t\t\toutput.metadata = {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'Object',\n\t\t\t\tgenerator: 'Object3D.toJSON'\n\t\t\t};\n\n\t\t}\n\n\t\t// standard Object3D serialization\n\n\t\tconst object = {};\n\n\t\tobject.uuid = this.uuid;\n\t\tobject.type = this.type;\n\n\t\tif ( this.name !== '' ) object.name = this.name;\n\t\tif ( this.castShadow === true ) object.castShadow = true;\n\t\tif ( this.receiveShadow === true ) object.receiveShadow = true;\n\t\tif ( this.visible === false ) object.visible = false;\n\t\tif ( this.frustumCulled === false ) object.frustumCulled = false;\n\t\tif ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;\n\t\tif ( Object.keys( this.userData ).length > 0 ) object.userData = this.userData;\n\n\t\tobject.layers = this.layers.mask;\n\t\tobject.matrix = this.matrix.toArray();\n\t\tobject.up = this.up.toArray();\n\n\t\tif ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;\n\n\t\t// object specific properties\n\n\t\tif ( this.isInstancedMesh ) {\n\n\t\t\tobject.type = 'InstancedMesh';\n\t\t\tobject.count = this.count;\n\t\t\tobject.instanceMatrix = this.instanceMatrix.toJSON();\n\t\t\tif ( this.instanceColor !== null ) object.instanceColor = this.instanceColor.toJSON();\n\n\t\t}\n\n\t\tif ( this.isBatchedMesh ) {\n\n\t\t\tobject.type = 'BatchedMesh';\n\t\t\tobject.perObjectFrustumCulled = this.perObjectFrustumCulled;\n\t\t\tobject.sortObjects = this.sortObjects;\n\n\t\t\tobject.drawRanges = this._drawRanges;\n\t\t\tobject.reservedRanges = this._reservedRanges;\n\n\t\t\tobject.visibility = this._visibility;\n\t\t\tobject.active = this._active;\n\t\t\tobject.bounds = this._bounds.map( bound => ( {\n\t\t\t\tboxInitialized: bound.boxInitialized,\n\t\t\t\tboxMin: bound.box.min.toArray(),\n\t\t\t\tboxMax: bound.box.max.toArray(),\n\n\t\t\t\tsphereInitialized: bound.sphereInitialized,\n\t\t\t\tsphereRadius: bound.sphere.radius,\n\t\t\t\tsphereCenter: bound.sphere.center.toArray()\n\t\t\t} ) );\n\n\t\t\tobject.maxInstanceCount = this._maxInstanceCount;\n\t\t\tobject.maxVertexCount = this._maxVertexCount;\n\t\t\tobject.maxIndexCount = this._maxIndexCount;\n\n\t\t\tobject.geometryInitialized = this._geometryInitialized;\n\t\t\tobject.geometryCount = this._geometryCount;\n\n\t\t\tobject.matricesTexture = this._matricesTexture.toJSON( meta );\n\n\t\t\tif ( this._colorsTexture !== null ) object.colorsTexture = this._colorsTexture.toJSON( meta );\n\n\t\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\t\tobject.boundingSphere = {\n\t\t\t\t\tcenter: object.boundingSphere.center.toArray(),\n\t\t\t\t\tradius: object.boundingSphere.radius\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tif ( this.boundingBox !== null ) {\n\n\t\t\t\tobject.boundingBox = {\n\t\t\t\t\tmin: object.boundingBox.min.toArray(),\n\t\t\t\t\tmax: object.boundingBox.max.toArray()\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tfunction serialize( library, element ) {\n\n\t\t\tif ( library[ element.uuid ] === undefined ) {\n\n\t\t\t\tlibrary[ element.uuid ] = element.toJSON( meta );\n\n\t\t\t}\n\n\t\t\treturn element.uuid;\n\n\t\t}\n\n\t\tif ( this.isScene ) {\n\n\t\t\tif ( this.background ) {\n\n\t\t\t\tif ( this.background.isColor ) {\n\n\t\t\t\t\tobject.background = this.background.toJSON();\n\n\t\t\t\t} else if ( this.background.isTexture ) {\n\n\t\t\t\t\tobject.background = this.background.toJSON( meta ).uuid;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true ) {\n\n\t\t\t\tobject.environment = this.environment.toJSON( meta ).uuid;\n\n\t\t\t}\n\n\t\t} else if ( this.isMesh || this.isLine || this.isPoints ) {\n\n\t\t\tobject.geometry = serialize( meta.geometries, this.geometry );\n\n\t\t\tconst parameters = this.geometry.parameters;\n\n\t\t\tif ( parameters !== undefined && parameters.shapes !== undefined ) {\n\n\t\t\t\tconst shapes = parameters.shapes;\n\n\t\t\t\tif ( Array.isArray( shapes ) ) {\n\n\t\t\t\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst shape = shapes[ i ];\n\n\t\t\t\t\t\tserialize( meta.shapes, shape );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tserialize( meta.shapes, shapes );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.isSkinnedMesh ) {\n\n\t\t\tobject.bindMode = this.bindMode;\n\t\t\tobject.bindMatrix = this.bindMatrix.toArray();\n\n\t\t\tif ( this.skeleton !== undefined ) {\n\n\t\t\t\tserialize( meta.skeletons, this.skeleton );\n\n\t\t\t\tobject.skeleton = this.skeleton.uuid;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.material !== undefined ) {\n\n\t\t\tif ( Array.isArray( this.material ) ) {\n\n\t\t\t\tconst uuids = [];\n\n\t\t\t\tfor ( let i = 0, l = this.material.length; i < l; i ++ ) {\n\n\t\t\t\t\tuuids.push( serialize( meta.materials, this.material[ i ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tobject.material = uuids;\n\n\t\t\t} else {\n\n\t\t\t\tobject.material = serialize( meta.materials, this.material );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.children.length > 0 ) {\n\n\t\t\tobject.children = [];\n\n\t\t\tfor ( let i = 0; i < this.children.length; i ++ ) {\n\n\t\t\t\tobject.children.push( this.children[ i ].toJSON( meta ).object );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.animations.length > 0 ) {\n\n\t\t\tobject.animations = [];\n\n\t\t\tfor ( let i = 0; i < this.animations.length; i ++ ) {\n\n\t\t\t\tconst animation = this.animations[ i ];\n\n\t\t\t\tobject.animations.push( serialize( meta.animations, animation ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( isRootObject ) {\n\n\t\t\tconst geometries = extractFromCache( meta.geometries );\n\t\t\tconst materials = extractFromCache( meta.materials );\n\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\tconst images = extractFromCache( meta.images );\n\t\t\tconst shapes = extractFromCache( meta.shapes );\n\t\t\tconst skeletons = extractFromCache( meta.skeletons );\n\t\t\tconst animations = extractFromCache( meta.animations );\n\t\t\tconst nodes = extractFromCache( meta.nodes );\n\n\t\t\tif ( geometries.length > 0 ) output.geometries = geometries;\n\t\t\tif ( materials.length > 0 ) output.materials = materials;\n\t\t\tif ( textures.length > 0 ) output.textures = textures;\n\t\t\tif ( images.length > 0 ) output.images = images;\n\t\t\tif ( shapes.length > 0 ) output.shapes = shapes;\n\t\t\tif ( skeletons.length > 0 ) output.skeletons = skeletons;\n\t\t\tif ( animations.length > 0 ) output.animations = animations;\n\t\t\tif ( nodes.length > 0 ) output.nodes = nodes;\n\n\t\t}\n\n\t\toutput.object = object;\n\n\t\treturn output;\n\n\t\t// extract data from the cache hash\n\t\t// remove metadata on each item\n\t\t// and return as array\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tconst values = [];\n\t\t\tfor ( const key in cache ) {\n\n\t\t\t\tconst data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t}\n\n\tclone( recursive ) {\n\n\t\treturn new this.constructor().copy( this, recursive );\n\n\t}\n\n\tcopy( source, recursive = true ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.up.copy( source.up );\n\n\t\tthis.position.copy( source.position );\n\t\tthis.rotation.order = source.rotation.order;\n\t\tthis.quaternion.copy( source.quaternion );\n\t\tthis.scale.copy( source.scale );\n\n\t\tthis.matrix.copy( source.matrix );\n\t\tthis.matrixWorld.copy( source.matrixWorld );\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\n\t\tthis.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;\n\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\n\t\tthis.layers.mask = source.layers.mask;\n\t\tthis.visible = source.visible;\n\n\t\tthis.castShadow = source.castShadow;\n\t\tthis.receiveShadow = source.receiveShadow;\n\n\t\tthis.frustumCulled = source.frustumCulled;\n\t\tthis.renderOrder = source.renderOrder;\n\n\t\tthis.animations = source.animations.slice();\n\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\tif ( recursive === true ) {\n\n\t\t\tfor ( let i = 0; i < source.children.length; i ++ ) {\n\n\t\t\t\tconst child = source.children[ i ];\n\t\t\t\tthis.add( child.clone() );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nObject3D.DEFAULT_UP = /*@__PURE__*/ new Vector3( 0, 1, 0 );\nObject3D.DEFAULT_MATRIX_AUTO_UPDATE = true;\nObject3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;\n\nconst _v0$1 = /*@__PURE__*/ new Vector3();\nconst _v1$3 = /*@__PURE__*/ new Vector3();\nconst _v2$2 = /*@__PURE__*/ new Vector3();\nconst _v3$2 = /*@__PURE__*/ new Vector3();\n\nconst _vab = /*@__PURE__*/ new Vector3();\nconst _vac = /*@__PURE__*/ new Vector3();\nconst _vbc = /*@__PURE__*/ new Vector3();\nconst _vap = /*@__PURE__*/ new Vector3();\nconst _vbp = /*@__PURE__*/ new Vector3();\nconst _vcp = /*@__PURE__*/ new Vector3();\n\nconst _v40 = /*@__PURE__*/ new Vector4();\nconst _v41 = /*@__PURE__*/ new Vector4();\nconst _v42 = /*@__PURE__*/ new Vector4();\n\nclass Triangle {\n\n\tconstructor( a = new Vector3(), b = new Vector3(), c = new Vector3() ) {\n\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\n\t}\n\n\tstatic getNormal( a, b, c, target ) {\n\n\t\ttarget.subVectors( c, b );\n\t\t_v0$1.subVectors( a, b );\n\t\ttarget.cross( _v0$1 );\n\n\t\tconst targetLengthSq = target.lengthSq();\n\t\tif ( targetLengthSq > 0 ) {\n\n\t\t\treturn target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );\n\n\t\t}\n\n\t\treturn target.set( 0, 0, 0 );\n\n\t}\n\n\t// static/instance method to calculate barycentric coordinates\n\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n\tstatic getBarycoord( point, a, b, c, target ) {\n\n\t\t_v0$1.subVectors( c, a );\n\t\t_v1$3.subVectors( b, a );\n\t\t_v2$2.subVectors( point, a );\n\n\t\tconst dot00 = _v0$1.dot( _v0$1 );\n\t\tconst dot01 = _v0$1.dot( _v1$3 );\n\t\tconst dot02 = _v0$1.dot( _v2$2 );\n\t\tconst dot11 = _v1$3.dot( _v1$3 );\n\t\tconst dot12 = _v1$3.dot( _v2$2 );\n\n\t\tconst denom = ( dot00 * dot11 - dot01 * dot01 );\n\n\t\t// collinear or singular triangle\n\t\tif ( denom === 0 ) {\n\n\t\t\ttarget.set( 0, 0, 0 );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst invDenom = 1 / denom;\n\t\tconst u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\t\tconst v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\n\t\t// barycentric coordinates must always sum to 1\n\t\treturn target.set( 1 - u - v, v, u );\n\n\t}\n\n\tstatic containsPoint( point, a, b, c ) {\n\n\t\t// if the triangle is degenerate then we can't contain a point\n\t\tif ( this.getBarycoord( point, a, b, c, _v3$2 ) === null ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn ( _v3$2.x >= 0 ) && ( _v3$2.y >= 0 ) && ( ( _v3$2.x + _v3$2.y ) <= 1 );\n\n\t}\n\n\tstatic getInterpolation( point, p1, p2, p3, v1, v2, v3, target ) {\n\n\t\tif ( this.getBarycoord( point, p1, p2, p3, _v3$2 ) === null ) {\n\n\t\t\ttarget.x = 0;\n\t\t\ttarget.y = 0;\n\t\t\tif ( 'z' in target ) target.z = 0;\n\t\t\tif ( 'w' in target ) target.w = 0;\n\t\t\treturn null;\n\n\t\t}\n\n\t\ttarget.setScalar( 0 );\n\t\ttarget.addScaledVector( v1, _v3$2.x );\n\t\ttarget.addScaledVector( v2, _v3$2.y );\n\t\ttarget.addScaledVector( v3, _v3$2.z );\n\n\t\treturn target;\n\n\t}\n\n\tstatic getInterpolatedAttribute( attr, i1, i2, i3, barycoord, target ) {\n\n\t\t_v40.setScalar( 0 );\n\t\t_v41.setScalar( 0 );\n\t\t_v42.setScalar( 0 );\n\n\t\t_v40.fromBufferAttribute( attr, i1 );\n\t\t_v41.fromBufferAttribute( attr, i2 );\n\t\t_v42.fromBufferAttribute( attr, i3 );\n\n\t\ttarget.setScalar( 0 );\n\t\ttarget.addScaledVector( _v40, barycoord.x );\n\t\ttarget.addScaledVector( _v41, barycoord.y );\n\t\ttarget.addScaledVector( _v42, barycoord.z );\n\n\t\treturn target;\n\n\t}\n\n\tstatic isFrontFacing( a, b, c, direction ) {\n\n\t\t_v0$1.subVectors( c, b );\n\t\t_v1$3.subVectors( a, b );\n\n\t\t// strictly front facing\n\t\treturn ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;\n\n\t}\n\n\tset( a, b, c ) {\n\n\t\tthis.a.copy( a );\n\t\tthis.b.copy( b );\n\t\tthis.c.copy( c );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPointsAndIndices( points, i0, i1, i2 ) {\n\n\t\tthis.a.copy( points[ i0 ] );\n\t\tthis.b.copy( points[ i1 ] );\n\t\tthis.c.copy( points[ i2 ] );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromAttributeAndIndices( attribute, i0, i1, i2 ) {\n\n\t\tthis.a.fromBufferAttribute( attribute, i0 );\n\t\tthis.b.fromBufferAttribute( attribute, i1 );\n\t\tthis.c.fromBufferAttribute( attribute, i2 );\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( triangle ) {\n\n\t\tthis.a.copy( triangle.a );\n\t\tthis.b.copy( triangle.b );\n\t\tthis.c.copy( triangle.c );\n\n\t\treturn this;\n\n\t}\n\n\tgetArea() {\n\n\t\t_v0$1.subVectors( this.c, this.b );\n\t\t_v1$3.subVectors( this.a, this.b );\n\n\t\treturn _v0$1.cross( _v1$3 ).length() * 0.5;\n\n\t}\n\n\tgetMidpoint( target ) {\n\n\t\treturn target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\n\n\t}\n\n\tgetNormal( target ) {\n\n\t\treturn Triangle.getNormal( this.a, this.b, this.c, target );\n\n\t}\n\n\tgetPlane( target ) {\n\n\t\treturn target.setFromCoplanarPoints( this.a, this.b, this.c );\n\n\t}\n\n\tgetBarycoord( point, target ) {\n\n\t\treturn Triangle.getBarycoord( point, this.a, this.b, this.c, target );\n\n\t}\n\n\tgetInterpolation( point, v1, v2, v3, target ) {\n\n\t\treturn Triangle.getInterpolation( point, this.a, this.b, this.c, v1, v2, v3, target );\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn Triangle.containsPoint( point, this.a, this.b, this.c );\n\n\t}\n\n\tisFrontFacing( direction ) {\n\n\t\treturn Triangle.isFrontFacing( this.a, this.b, this.c, direction );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn box.intersectsTriangle( this );\n\n\t}\n\n\tclosestPointToPoint( p, target ) {\n\n\t\tconst a = this.a, b = this.b, c = this.c;\n\t\tlet v, w;\n\n\t\t// algorithm thanks to Real-Time Collision Detection by Christer Ericson,\n\t\t// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,\n\t\t// under the accompanying license; see chapter 5.1.5 for detailed explanation.\n\t\t// basically, we're distinguishing which of the voronoi regions of the triangle\n\t\t// the point lies in with the minimum amount of redundant computation.\n\n\t\t_vab.subVectors( b, a );\n\t\t_vac.subVectors( c, a );\n\t\t_vap.subVectors( p, a );\n\t\tconst d1 = _vab.dot( _vap );\n\t\tconst d2 = _vac.dot( _vap );\n\t\tif ( d1 <= 0 && d2 <= 0 ) {\n\n\t\t\t// vertex region of A; barycentric coords (1, 0, 0)\n\t\t\treturn target.copy( a );\n\n\t\t}\n\n\t\t_vbp.subVectors( p, b );\n\t\tconst d3 = _vab.dot( _vbp );\n\t\tconst d4 = _vac.dot( _vbp );\n\t\tif ( d3 >= 0 && d4 <= d3 ) {\n\n\t\t\t// vertex region of B; barycentric coords (0, 1, 0)\n\t\t\treturn target.copy( b );\n\n\t\t}\n\n\t\tconst vc = d1 * d4 - d3 * d2;\n\t\tif ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {\n\n\t\t\tv = d1 / ( d1 - d3 );\n\t\t\t// edge region of AB; barycentric coords (1-v, v, 0)\n\t\t\treturn target.copy( a ).addScaledVector( _vab, v );\n\n\t\t}\n\n\t\t_vcp.subVectors( p, c );\n\t\tconst d5 = _vab.dot( _vcp );\n\t\tconst d6 = _vac.dot( _vcp );\n\t\tif ( d6 >= 0 && d5 <= d6 ) {\n\n\t\t\t// vertex region of C; barycentric coords (0, 0, 1)\n\t\t\treturn target.copy( c );\n\n\t\t}\n\n\t\tconst vb = d5 * d2 - d1 * d6;\n\t\tif ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {\n\n\t\t\tw = d2 / ( d2 - d6 );\n\t\t\t// edge region of AC; barycentric coords (1-w, 0, w)\n\t\t\treturn target.copy( a ).addScaledVector( _vac, w );\n\n\t\t}\n\n\t\tconst va = d3 * d6 - d5 * d4;\n\t\tif ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {\n\n\t\t\t_vbc.subVectors( c, b );\n\t\t\tw = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );\n\t\t\t// edge region of BC; barycentric coords (0, 1-w, w)\n\t\t\treturn target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC\n\n\t\t}\n\n\t\t// face region\n\t\tconst denom = 1 / ( va + vb + vc );\n\t\t// u = va * denom\n\t\tv = vb * denom;\n\t\tw = vc * denom;\n\n\t\treturn target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );\n\n\t}\n\n\tequals( triangle ) {\n\n\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\n\n\t}\n\n}\n\nconst _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\n\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\n\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\n\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\n\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\n\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\n\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\n\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\n\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\n\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\n\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\n\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\n\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\n\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\n\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\n\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\n\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\n\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\n\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\n\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\n\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\n\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\n\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\n\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\n\nconst _hslA = { h: 0, s: 0, l: 0 };\nconst _hslB = { h: 0, s: 0, l: 0 };\n\nfunction hue2rgb( p, q, t ) {\n\n\tif ( t < 0 ) t += 1;\n\tif ( t > 1 ) t -= 1;\n\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\n\tif ( t < 1 / 2 ) return q;\n\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\n\treturn p;\n\n}\n\nclass Color {\n\n\tconstructor( r, g, b ) {\n\n\t\tthis.isColor = true;\n\n\t\tthis.r = 1;\n\t\tthis.g = 1;\n\t\tthis.b = 1;\n\n\t\treturn this.set( r, g, b );\n\n\t}\n\n\tset( r, g, b ) {\n\n\t\tif ( g === undefined && b === undefined ) {\n\n\t\t\t// r is THREE.Color, hex or string\n\n\t\t\tconst value = r;\n\n\t\t\tif ( value && value.isColor ) {\n\n\t\t\t\tthis.copy( value );\n\n\t\t\t} else if ( typeof value === 'number' ) {\n\n\t\t\t\tthis.setHex( value );\n\n\t\t\t} else if ( typeof value === 'string' ) {\n\n\t\t\t\tthis.setStyle( value );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.setRGB( r, g, b );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetScalar( scalar ) {\n\n\t\tthis.r = scalar;\n\t\tthis.g = scalar;\n\t\tthis.b = scalar;\n\n\t\treturn this;\n\n\t}\n\n\tsetHex( hex, colorSpace = SRGBColorSpace ) {\n\n\t\thex = Math.floor( hex );\n\n\t\tthis.r = ( hex >> 16 & 255 ) / 255;\n\t\tthis.g = ( hex >> 8 & 255 ) / 255;\n\t\tthis.b = ( hex & 255 ) / 255;\n\n\t\tColorManagement.toWorkingColorSpace( this, colorSpace );\n\n\t\treturn this;\n\n\t}\n\n\tsetRGB( r, g, b, colorSpace = ColorManagement.workingColorSpace ) {\n\n\t\tthis.r = r;\n\t\tthis.g = g;\n\t\tthis.b = b;\n\n\t\tColorManagement.toWorkingColorSpace( this, colorSpace );\n\n\t\treturn this;\n\n\t}\n\n\tsetHSL( h, s, l, colorSpace = ColorManagement.workingColorSpace ) {\n\n\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\th = euclideanModulo( h, 1 );\n\t\ts = clamp( s, 0, 1 );\n\t\tl = clamp( l, 0, 1 );\n\n\t\tif ( s === 0 ) {\n\n\t\t\tthis.r = this.g = this.b = l;\n\n\t\t} else {\n\n\t\t\tconst p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\n\t\t\tconst q = ( 2 * l ) - p;\n\n\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\n\t\t\tthis.g = hue2rgb( q, p, h );\n\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\n\n\t\t}\n\n\t\tColorManagement.toWorkingColorSpace( this, colorSpace );\n\n\t\treturn this;\n\n\t}\n\n\tsetStyle( style, colorSpace = SRGBColorSpace ) {\n\n\t\tfunction handleAlpha( string ) {\n\n\t\t\tif ( string === undefined ) return;\n\n\t\t\tif ( parseFloat( string ) < 1 ) {\n\n\t\t\t\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tlet m;\n\n\t\tif ( m = /^(\\w+)\\(([^\\)]*)\\)/.exec( style ) ) {\n\n\t\t\t// rgb / hsl\n\n\t\t\tlet color;\n\t\t\tconst name = m[ 1 ];\n\t\t\tconst components = m[ 2 ];\n\n\t\t\tswitch ( name ) {\n\n\t\t\t\tcase 'rgb':\n\t\t\t\tcase 'rgba':\n\n\t\t\t\t\tif ( color = /^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\n\n\t\t\t\t\t\thandleAlpha( color[ 4 ] );\n\n\t\t\t\t\t\treturn this.setRGB(\n\t\t\t\t\t\t\tMath.min( 255, parseInt( color[ 1 ], 10 ) ) / 255,\n\t\t\t\t\t\t\tMath.min( 255, parseInt( color[ 2 ], 10 ) ) / 255,\n\t\t\t\t\t\t\tMath.min( 255, parseInt( color[ 3 ], 10 ) ) / 255,\n\t\t\t\t\t\t\tcolorSpace\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( color = /^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n\n\t\t\t\t\t\thandleAlpha( color[ 4 ] );\n\n\t\t\t\t\t\treturn this.setRGB(\n\t\t\t\t\t\t\tMath.min( 100, parseInt( color[ 1 ], 10 ) ) / 100,\n\t\t\t\t\t\t\tMath.min( 100, parseInt( color[ 2 ], 10 ) ) / 100,\n\t\t\t\t\t\t\tMath.min( 100, parseInt( color[ 3 ], 10 ) ) / 100,\n\t\t\t\t\t\t\tcolorSpace\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'hsl':\n\t\t\t\tcase 'hsla':\n\n\t\t\t\t\tif ( color = /^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n\n\t\t\t\t\t\thandleAlpha( color[ 4 ] );\n\n\t\t\t\t\t\treturn this.setHSL(\n\t\t\t\t\t\t\tparseFloat( color[ 1 ] ) / 360,\n\t\t\t\t\t\t\tparseFloat( color[ 2 ] ) / 100,\n\t\t\t\t\t\t\tparseFloat( color[ 3 ] ) / 100,\n\t\t\t\t\t\t\tcolorSpace\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tconsole.warn( 'THREE.Color: Unknown color model ' + style );\n\n\t\t\t}\n\n\t\t} else if ( m = /^\\#([A-Fa-f\\d]+)$/.exec( style ) ) {\n\n\t\t\t// hex color\n\n\t\t\tconst hex = m[ 1 ];\n\t\t\tconst size = hex.length;\n\n\t\t\tif ( size === 3 ) {\n\n\t\t\t\t// #ff0\n\t\t\t\treturn this.setRGB(\n\t\t\t\t\tparseInt( hex.charAt( 0 ), 16 ) / 15,\n\t\t\t\t\tparseInt( hex.charAt( 1 ), 16 ) / 15,\n\t\t\t\t\tparseInt( hex.charAt( 2 ), 16 ) / 15,\n\t\t\t\t\tcolorSpace\n\t\t\t\t);\n\n\t\t\t} else if ( size === 6 ) {\n\n\t\t\t\t// #ff0000\n\t\t\t\treturn this.setHex( parseInt( hex, 16 ), colorSpace );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.Color: Invalid hex color ' + style );\n\n\t\t\t}\n\n\t\t} else if ( style && style.length > 0 ) {\n\n\t\t\treturn this.setColorName( style, colorSpace );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetColorName( style, colorSpace = SRGBColorSpace ) {\n\n\t\t// color keywords\n\t\tconst hex = _colorKeywords[ style.toLowerCase() ];\n\n\t\tif ( hex !== undefined ) {\n\n\t\t\t// red\n\t\t\tthis.setHex( hex, colorSpace );\n\n\t\t} else {\n\n\t\t\t// unknown color\n\t\t\tconsole.warn( 'THREE.Color: Unknown color ' + style );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.r, this.g, this.b );\n\n\t}\n\n\tcopy( color ) {\n\n\t\tthis.r = color.r;\n\t\tthis.g = color.g;\n\t\tthis.b = color.b;\n\n\t\treturn this;\n\n\t}\n\n\tcopySRGBToLinear( color ) {\n\n\t\tthis.r = SRGBToLinear( color.r );\n\t\tthis.g = SRGBToLinear( color.g );\n\t\tthis.b = SRGBToLinear( color.b );\n\n\t\treturn this;\n\n\t}\n\n\tcopyLinearToSRGB( color ) {\n\n\t\tthis.r = LinearToSRGB( color.r );\n\t\tthis.g = LinearToSRGB( color.g );\n\t\tthis.b = LinearToSRGB( color.b );\n\n\t\treturn this;\n\n\t}\n\n\tconvertSRGBToLinear() {\n\n\t\tthis.copySRGBToLinear( this );\n\n\t\treturn this;\n\n\t}\n\n\tconvertLinearToSRGB() {\n\n\t\tthis.copyLinearToSRGB( this );\n\n\t\treturn this;\n\n\t}\n\n\tgetHex( colorSpace = SRGBColorSpace ) {\n\n\t\tColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );\n\n\t\treturn Math.round( clamp( _color.r * 255, 0, 255 ) ) * 65536 + Math.round( clamp( _color.g * 255, 0, 255 ) ) * 256 + Math.round( clamp( _color.b * 255, 0, 255 ) );\n\n\t}\n\n\tgetHexString( colorSpace = SRGBColorSpace ) {\n\n\t\treturn ( '000000' + this.getHex( colorSpace ).toString( 16 ) ).slice( - 6 );\n\n\t}\n\n\tgetHSL( target, colorSpace = ColorManagement.workingColorSpace ) {\n\n\t\t// h,s,l ranges are in 0.0 - 1.0\n\n\t\tColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );\n\n\t\tconst r = _color.r, g = _color.g, b = _color.b;\n\n\t\tconst max = Math.max( r, g, b );\n\t\tconst min = Math.min( r, g, b );\n\n\t\tlet hue, saturation;\n\t\tconst lightness = ( min + max ) / 2.0;\n\n\t\tif ( min === max ) {\n\n\t\t\thue = 0;\n\t\t\tsaturation = 0;\n\n\t\t} else {\n\n\t\t\tconst delta = max - min;\n\n\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\n\n\t\t\tswitch ( max ) {\n\n\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\n\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\n\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\n\n\t\t\t}\n\n\t\t\thue /= 6;\n\n\t\t}\n\n\t\ttarget.h = hue;\n\t\ttarget.s = saturation;\n\t\ttarget.l = lightness;\n\n\t\treturn target;\n\n\t}\n\n\tgetRGB( target, colorSpace = ColorManagement.workingColorSpace ) {\n\n\t\tColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );\n\n\t\ttarget.r = _color.r;\n\t\ttarget.g = _color.g;\n\t\ttarget.b = _color.b;\n\n\t\treturn target;\n\n\t}\n\n\tgetStyle( colorSpace = SRGBColorSpace ) {\n\n\t\tColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );\n\n\t\tconst r = _color.r, g = _color.g, b = _color.b;\n\n\t\tif ( colorSpace !== SRGBColorSpace ) {\n\n\t\t\t// Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).\n\t\t\treturn `color(${ colorSpace } ${ r.toFixed( 3 ) } ${ g.toFixed( 3 ) } ${ b.toFixed( 3 ) })`;\n\n\t\t}\n\n\t\treturn `rgb(${ Math.round( r * 255 ) },${ Math.round( g * 255 ) },${ Math.round( b * 255 ) })`;\n\n\t}\n\n\toffsetHSL( h, s, l ) {\n\n\t\tthis.getHSL( _hslA );\n\n\t\treturn this.setHSL( _hslA.h + h, _hslA.s + s, _hslA.l + l );\n\n\t}\n\n\tadd( color ) {\n\n\t\tthis.r += color.r;\n\t\tthis.g += color.g;\n\t\tthis.b += color.b;\n\n\t\treturn this;\n\n\t}\n\n\taddColors( color1, color2 ) {\n\n\t\tthis.r = color1.r + color2.r;\n\t\tthis.g = color1.g + color2.g;\n\t\tthis.b = color1.b + color2.b;\n\n\t\treturn this;\n\n\t}\n\n\taddScalar( s ) {\n\n\t\tthis.r += s;\n\t\tthis.g += s;\n\t\tthis.b += s;\n\n\t\treturn this;\n\n\t}\n\n\tsub( color ) {\n\n\t\tthis.r = Math.max( 0, this.r - color.r );\n\t\tthis.g = Math.max( 0, this.g - color.g );\n\t\tthis.b = Math.max( 0, this.b - color.b );\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( color ) {\n\n\t\tthis.r *= color.r;\n\t\tthis.g *= color.g;\n\t\tthis.b *= color.b;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( s ) {\n\n\t\tthis.r *= s;\n\t\tthis.g *= s;\n\t\tthis.b *= s;\n\n\t\treturn this;\n\n\t}\n\n\tlerp( color, alpha ) {\n\n\t\tthis.r += ( color.r - this.r ) * alpha;\n\t\tthis.g += ( color.g - this.g ) * alpha;\n\t\tthis.b += ( color.b - this.b ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpColors( color1, color2, alpha ) {\n\n\t\tthis.r = color1.r + ( color2.r - color1.r ) * alpha;\n\t\tthis.g = color1.g + ( color2.g - color1.g ) * alpha;\n\t\tthis.b = color1.b + ( color2.b - color1.b ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpHSL( color, alpha ) {\n\n\t\tthis.getHSL( _hslA );\n\t\tcolor.getHSL( _hslB );\n\n\t\tconst h = lerp( _hslA.h, _hslB.h, alpha );\n\t\tconst s = lerp( _hslA.s, _hslB.s, alpha );\n\t\tconst l = lerp( _hslA.l, _hslB.l, alpha );\n\n\t\tthis.setHSL( h, s, l );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromVector3( v ) {\n\n\t\tthis.r = v.x;\n\t\tthis.g = v.y;\n\t\tthis.b = v.z;\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix3( m ) {\n\n\t\tconst r = this.r, g = this.g, b = this.b;\n\t\tconst e = m.elements;\n\n\t\tthis.r = e[ 0 ] * r + e[ 3 ] * g + e[ 6 ] * b;\n\t\tthis.g = e[ 1 ] * r + e[ 4 ] * g + e[ 7 ] * b;\n\t\tthis.b = e[ 2 ] * r + e[ 5 ] * g + e[ 8 ] * b;\n\n\t\treturn this;\n\n\t}\n\n\tequals( c ) {\n\n\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.r = array[ offset ];\n\t\tthis.g = array[ offset + 1 ];\n\t\tthis.b = array[ offset + 2 ];\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.r;\n\t\tarray[ offset + 1 ] = this.g;\n\t\tarray[ offset + 2 ] = this.b;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis.r = attribute.getX( index );\n\t\tthis.g = attribute.getY( index );\n\t\tthis.b = attribute.getZ( index );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\treturn this.getHex();\n\n\t}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this.r;\n\t\tyield this.g;\n\t\tyield this.b;\n\n\t}\n\n}\n\nconst _color = /*@__PURE__*/ new Color();\n\nColor.NAMES = _colorKeywords;\n\nlet _materialId = 0;\n\nclass Material extends EventDispatcher {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isMaterial = true;\n\n\t\tObject.defineProperty( this, 'id', { value: _materialId ++ } );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'Material';\n\n\t\tthis.blending = NormalBlending;\n\t\tthis.side = FrontSide;\n\t\tthis.vertexColors = false;\n\n\t\tthis.opacity = 1;\n\t\tthis.transparent = false;\n\t\tthis.alphaHash = false;\n\n\t\tthis.blendSrc = SrcAlphaFactor;\n\t\tthis.blendDst = OneMinusSrcAlphaFactor;\n\t\tthis.blendEquation = AddEquation;\n\t\tthis.blendSrcAlpha = null;\n\t\tthis.blendDstAlpha = null;\n\t\tthis.blendEquationAlpha = null;\n\t\tthis.blendColor = new Color( 0, 0, 0 );\n\t\tthis.blendAlpha = 0;\n\n\t\tthis.depthFunc = LessEqualDepth;\n\t\tthis.depthTest = true;\n\t\tthis.depthWrite = true;\n\n\t\tthis.stencilWriteMask = 0xff;\n\t\tthis.stencilFunc = AlwaysStencilFunc;\n\t\tthis.stencilRef = 0;\n\t\tthis.stencilFuncMask = 0xff;\n\t\tthis.stencilFail = KeepStencilOp;\n\t\tthis.stencilZFail = KeepStencilOp;\n\t\tthis.stencilZPass = KeepStencilOp;\n\t\tthis.stencilWrite = false;\n\n\t\tthis.clippingPlanes = null;\n\t\tthis.clipIntersection = false;\n\t\tthis.clipShadows = false;\n\n\t\tthis.shadowSide = null;\n\n\t\tthis.colorWrite = true;\n\n\t\tthis.precision = null; // override the renderer's default precision for this material\n\n\t\tthis.polygonOffset = false;\n\t\tthis.polygonOffsetFactor = 0;\n\t\tthis.polygonOffsetUnits = 0;\n\n\t\tthis.dithering = false;\n\n\t\tthis.alphaToCoverage = false;\n\t\tthis.premultipliedAlpha = false;\n\t\tthis.forceSinglePass = false;\n\n\t\tthis.visible = true;\n\n\t\tthis.toneMapped = true;\n\n\t\tthis.userData = {};\n\n\t\tthis.version = 0;\n\n\t\tthis._alphaTest = 0;\n\n\t}\n\n\tget alphaTest() {\n\n\t\treturn this._alphaTest;\n\n\t}\n\n\tset alphaTest( value ) {\n\n\t\tif ( this._alphaTest > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._alphaTest = value;\n\n\t}\n\n\t// onBeforeRender and onBeforeCompile only supported in WebGLRenderer\n\n\tonBeforeRender( /* renderer, scene, camera, geometry, object, group */ ) {}\n\n\tonBeforeCompile( /* shaderobject, renderer */ ) {}\n\n\tcustomProgramCacheKey() {\n\n\t\treturn this.onBeforeCompile.toString();\n\n\t}\n\n\tsetValues( values ) {\n\n\t\tif ( values === undefined ) return;\n\n\t\tfor ( const key in values ) {\n\n\t\t\tconst newValue = values[ key ];\n\n\t\t\tif ( newValue === undefined ) {\n\n\t\t\t\tconsole.warn( `THREE.Material: parameter '${ key }' has value of undefined.` );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst currentValue = this[ key ];\n\n\t\t\tif ( currentValue === undefined ) {\n\n\t\t\t\tconsole.warn( `THREE.Material: '${ key }' is not a property of THREE.${ this.type }.` );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( currentValue && currentValue.isColor ) {\n\n\t\t\t\tcurrentValue.set( newValue );\n\n\t\t\t} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {\n\n\t\t\t\tcurrentValue.copy( newValue );\n\n\t\t\t} else {\n\n\t\t\t\tthis[ key ] = newValue;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( isRootObject ) {\n\n\t\t\tmeta = {\n\t\t\t\ttextures: {},\n\t\t\t\timages: {}\n\t\t\t};\n\n\t\t}\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'Material',\n\t\t\t\tgenerator: 'Material.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard Material serialization\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\n\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\tif ( this.color && this.color.isColor ) data.color = this.color.getHex();\n\n\t\tif ( this.roughness !== undefined ) data.roughness = this.roughness;\n\t\tif ( this.metalness !== undefined ) data.metalness = this.metalness;\n\n\t\tif ( this.sheen !== undefined ) data.sheen = this.sheen;\n\t\tif ( this.sheenColor && this.sheenColor.isColor ) data.sheenColor = this.sheenColor.getHex();\n\t\tif ( this.sheenRoughness !== undefined ) data.sheenRoughness = this.sheenRoughness;\n\t\tif ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();\n\t\tif ( this.emissiveIntensity !== undefined && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;\n\n\t\tif ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();\n\t\tif ( this.specularIntensity !== undefined ) data.specularIntensity = this.specularIntensity;\n\t\tif ( this.specularColor && this.specularColor.isColor ) data.specularColor = this.specularColor.getHex();\n\t\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\n\t\tif ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;\n\t\tif ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;\n\n\t\tif ( this.clearcoatMap && this.clearcoatMap.isTexture ) {\n\n\t\t\tdata.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {\n\n\t\t\tdata.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {\n\n\t\t\tdata.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;\n\t\t\tdata.clearcoatNormalScale = this.clearcoatNormalScale.toArray();\n\n\t\t}\n\n\t\tif ( this.dispersion !== undefined ) data.dispersion = this.dispersion;\n\n\t\tif ( this.iridescence !== undefined ) data.iridescence = this.iridescence;\n\t\tif ( this.iridescenceIOR !== undefined ) data.iridescenceIOR = this.iridescenceIOR;\n\t\tif ( this.iridescenceThicknessRange !== undefined ) data.iridescenceThicknessRange = this.iridescenceThicknessRange;\n\n\t\tif ( this.iridescenceMap && this.iridescenceMap.isTexture ) {\n\n\t\t\tdata.iridescenceMap = this.iridescenceMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture ) {\n\n\t\t\tdata.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.anisotropy !== undefined ) data.anisotropy = this.anisotropy;\n\t\tif ( this.anisotropyRotation !== undefined ) data.anisotropyRotation = this.anisotropyRotation;\n\n\t\tif ( this.anisotropyMap && this.anisotropyMap.isTexture ) {\n\n\t\t\tdata.anisotropyMap = this.anisotropyMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;\n\t\tif ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;\n\t\tif ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\n\n\t\tif ( this.lightMap && this.lightMap.isTexture ) {\n\n\t\t\tdata.lightMap = this.lightMap.toJSON( meta ).uuid;\n\t\t\tdata.lightMapIntensity = this.lightMapIntensity;\n\n\t\t}\n\n\t\tif ( this.aoMap && this.aoMap.isTexture ) {\n\n\t\t\tdata.aoMap = this.aoMap.toJSON( meta ).uuid;\n\t\t\tdata.aoMapIntensity = this.aoMapIntensity;\n\n\t\t}\n\n\t\tif ( this.bumpMap && this.bumpMap.isTexture ) {\n\n\t\t\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\n\t\t\tdata.bumpScale = this.bumpScale;\n\n\t\t}\n\n\t\tif ( this.normalMap && this.normalMap.isTexture ) {\n\n\t\t\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\n\t\t\tdata.normalMapType = this.normalMapType;\n\t\t\tdata.normalScale = this.normalScale.toArray();\n\n\t\t}\n\n\t\tif ( this.displacementMap && this.displacementMap.isTexture ) {\n\n\t\t\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\n\t\t\tdata.displacementScale = this.displacementScale;\n\t\t\tdata.displacementBias = this.displacementBias;\n\n\t\t}\n\n\t\tif ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\n\t\tif ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\n\n\t\tif ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\n\t\tif ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\n\t\tif ( this.specularIntensityMap && this.specularIntensityMap.isTexture ) data.specularIntensityMap = this.specularIntensityMap.toJSON( meta ).uuid;\n\t\tif ( this.specularColorMap && this.specularColorMap.isTexture ) data.specularColorMap = this.specularColorMap.toJSON( meta ).uuid;\n\n\t\tif ( this.envMap && this.envMap.isTexture ) {\n\n\t\t\tdata.envMap = this.envMap.toJSON( meta ).uuid;\n\n\t\t\tif ( this.combine !== undefined ) data.combine = this.combine;\n\n\t\t}\n\n\t\tif ( this.envMapRotation !== undefined ) data.envMapRotation = this.envMapRotation.toArray();\n\t\tif ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;\n\t\tif ( this.reflectivity !== undefined ) data.reflectivity = this.reflectivity;\n\t\tif ( this.refractionRatio !== undefined ) data.refractionRatio = this.refractionRatio;\n\n\t\tif ( this.gradientMap && this.gradientMap.isTexture ) {\n\n\t\t\tdata.gradientMap = this.gradientMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.transmission !== undefined ) data.transmission = this.transmission;\n\t\tif ( this.transmissionMap && this.transmissionMap.isTexture ) data.transmissionMap = this.transmissionMap.toJSON( meta ).uuid;\n\t\tif ( this.thickness !== undefined ) data.thickness = this.thickness;\n\t\tif ( this.thicknessMap && this.thicknessMap.isTexture ) data.thicknessMap = this.thicknessMap.toJSON( meta ).uuid;\n\t\tif ( this.attenuationDistance !== undefined && this.attenuationDistance !== Infinity ) data.attenuationDistance = this.attenuationDistance;\n\t\tif ( this.attenuationColor !== undefined ) data.attenuationColor = this.attenuationColor.getHex();\n\n\t\tif ( this.size !== undefined ) data.size = this.size;\n\t\tif ( this.shadowSide !== null ) data.shadowSide = this.shadowSide;\n\t\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\n\n\t\tif ( this.blending !== NormalBlending ) data.blending = this.blending;\n\t\tif ( this.side !== FrontSide ) data.side = this.side;\n\t\tif ( this.vertexColors === true ) data.vertexColors = true;\n\n\t\tif ( this.opacity < 1 ) data.opacity = this.opacity;\n\t\tif ( this.transparent === true ) data.transparent = true;\n\n\t\tif ( this.blendSrc !== SrcAlphaFactor ) data.blendSrc = this.blendSrc;\n\t\tif ( this.blendDst !== OneMinusSrcAlphaFactor ) data.blendDst = this.blendDst;\n\t\tif ( this.blendEquation !== AddEquation ) data.blendEquation = this.blendEquation;\n\t\tif ( this.blendSrcAlpha !== null ) data.blendSrcAlpha = this.blendSrcAlpha;\n\t\tif ( this.blendDstAlpha !== null ) data.blendDstAlpha = this.blendDstAlpha;\n\t\tif ( this.blendEquationAlpha !== null ) data.blendEquationAlpha = this.blendEquationAlpha;\n\t\tif ( this.blendColor && this.blendColor.isColor ) data.blendColor = this.blendColor.getHex();\n\t\tif ( this.blendAlpha !== 0 ) data.blendAlpha = this.blendAlpha;\n\n\t\tif ( this.depthFunc !== LessEqualDepth ) data.depthFunc = this.depthFunc;\n\t\tif ( this.depthTest === false ) data.depthTest = this.depthTest;\n\t\tif ( this.depthWrite === false ) data.depthWrite = this.depthWrite;\n\t\tif ( this.colorWrite === false ) data.colorWrite = this.colorWrite;\n\n\t\tif ( this.stencilWriteMask !== 0xff ) data.stencilWriteMask = this.stencilWriteMask;\n\t\tif ( this.stencilFunc !== AlwaysStencilFunc ) data.stencilFunc = this.stencilFunc;\n\t\tif ( this.stencilRef !== 0 ) data.stencilRef = this.stencilRef;\n\t\tif ( this.stencilFuncMask !== 0xff ) data.stencilFuncMask = this.stencilFuncMask;\n\t\tif ( this.stencilFail !== KeepStencilOp ) data.stencilFail = this.stencilFail;\n\t\tif ( this.stencilZFail !== KeepStencilOp ) data.stencilZFail = this.stencilZFail;\n\t\tif ( this.stencilZPass !== KeepStencilOp ) data.stencilZPass = this.stencilZPass;\n\t\tif ( this.stencilWrite === true ) data.stencilWrite = this.stencilWrite;\n\n\t\t// rotation (SpriteMaterial)\n\t\tif ( this.rotation !== undefined && this.rotation !== 0 ) data.rotation = this.rotation;\n\n\t\tif ( this.polygonOffset === true ) data.polygonOffset = true;\n\t\tif ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;\n\t\tif ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;\n\n\t\tif ( this.linewidth !== undefined && this.linewidth !== 1 ) data.linewidth = this.linewidth;\n\t\tif ( this.dashSize !== undefined ) data.dashSize = this.dashSize;\n\t\tif ( this.gapSize !== undefined ) data.gapSize = this.gapSize;\n\t\tif ( this.scale !== undefined ) data.scale = this.scale;\n\n\t\tif ( this.dithering === true ) data.dithering = true;\n\n\t\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\n\t\tif ( this.alphaHash === true ) data.alphaHash = true;\n\t\tif ( this.alphaToCoverage === true ) data.alphaToCoverage = true;\n\t\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = true;\n\t\tif ( this.forceSinglePass === true ) data.forceSinglePass = true;\n\n\t\tif ( this.wireframe === true ) data.wireframe = true;\n\t\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\n\t\tif ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;\n\t\tif ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;\n\n\t\tif ( this.flatShading === true ) data.flatShading = true;\n\n\t\tif ( this.visible === false ) data.visible = false;\n\n\t\tif ( this.toneMapped === false ) data.toneMapped = false;\n\n\t\tif ( this.fog === false ) data.fog = false;\n\n\t\tif ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;\n\n\t\t// TODO: Copied from Object3D.toJSON\n\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tconst values = [];\n\n\t\t\tfor ( const key in cache ) {\n\n\t\t\t\tconst data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t\tif ( isRootObject ) {\n\n\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\tconst images = extractFromCache( meta.images );\n\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\tif ( images.length > 0 ) data.images = images;\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.blending = source.blending;\n\t\tthis.side = source.side;\n\t\tthis.vertexColors = source.vertexColors;\n\n\t\tthis.opacity = source.opacity;\n\t\tthis.transparent = source.transparent;\n\n\t\tthis.blendSrc = source.blendSrc;\n\t\tthis.blendDst = source.blendDst;\n\t\tthis.blendEquation = source.blendEquation;\n\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\n\t\tthis.blendDstAlpha = source.blendDstAlpha;\n\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\n\t\tthis.blendColor.copy( source.blendColor );\n\t\tthis.blendAlpha = source.blendAlpha;\n\n\t\tthis.depthFunc = source.depthFunc;\n\t\tthis.depthTest = source.depthTest;\n\t\tthis.depthWrite = source.depthWrite;\n\n\t\tthis.stencilWriteMask = source.stencilWriteMask;\n\t\tthis.stencilFunc = source.stencilFunc;\n\t\tthis.stencilRef = source.stencilRef;\n\t\tthis.stencilFuncMask = source.stencilFuncMask;\n\t\tthis.stencilFail = source.stencilFail;\n\t\tthis.stencilZFail = source.stencilZFail;\n\t\tthis.stencilZPass = source.stencilZPass;\n\t\tthis.stencilWrite = source.stencilWrite;\n\n\t\tconst srcPlanes = source.clippingPlanes;\n\t\tlet dstPlanes = null;\n\n\t\tif ( srcPlanes !== null ) {\n\n\t\t\tconst n = srcPlanes.length;\n\t\t\tdstPlanes = new Array( n );\n\n\t\t\tfor ( let i = 0; i !== n; ++ i ) {\n\n\t\t\t\tdstPlanes[ i ] = srcPlanes[ i ].clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.clippingPlanes = dstPlanes;\n\t\tthis.clipIntersection = source.clipIntersection;\n\t\tthis.clipShadows = source.clipShadows;\n\n\t\tthis.shadowSide = source.shadowSide;\n\n\t\tthis.colorWrite = source.colorWrite;\n\n\t\tthis.precision = source.precision;\n\n\t\tthis.polygonOffset = source.polygonOffset;\n\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\n\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\n\n\t\tthis.dithering = source.dithering;\n\n\t\tthis.alphaTest = source.alphaTest;\n\t\tthis.alphaHash = source.alphaHash;\n\t\tthis.alphaToCoverage = source.alphaToCoverage;\n\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\n\t\tthis.forceSinglePass = source.forceSinglePass;\n\n\t\tthis.visible = source.visible;\n\n\t\tthis.toneMapped = source.toneMapped;\n\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\tonBuild( /* shaderobject, renderer */ ) {\n\n\t\tconsole.warn( 'Material: onBuild() has been removed.' ); // @deprecated, r166\n\n\t}\n\n}\n\nclass MeshBasicMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshBasicMaterial = true;\n\n\t\tthis.type = 'MeshBasicMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // emissive\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.envMapRotation = new Euler();\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.envMapRotation.copy( source.envMapRotation );\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\n// Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf\n\nconst _tables = /*@__PURE__*/ _generateTables();\n\nfunction _generateTables() {\n\n\t// float32 to float16 helpers\n\n\tconst buffer = new ArrayBuffer( 4 );\n\tconst floatView = new Float32Array( buffer );\n\tconst uint32View = new Uint32Array( buffer );\n\n\tconst baseTable = new Uint32Array( 512 );\n\tconst shiftTable = new Uint32Array( 512 );\n\n\tfor ( let i = 0; i < 256; ++ i ) {\n\n\t\tconst e = i - 127;\n\n\t\t// very small number (0, -0)\n\n\t\tif ( e < - 27 ) {\n\n\t\t\tbaseTable[ i ] = 0x0000;\n\t\t\tbaseTable[ i | 0x100 ] = 0x8000;\n\t\t\tshiftTable[ i ] = 24;\n\t\t\tshiftTable[ i | 0x100 ] = 24;\n\n\t\t\t// small number (denorm)\n\n\t\t} else if ( e < - 14 ) {\n\n\t\t\tbaseTable[ i ] = 0x0400 >> ( - e - 14 );\n\t\t\tbaseTable[ i | 0x100 ] = ( 0x0400 >> ( - e - 14 ) ) | 0x8000;\n\t\t\tshiftTable[ i ] = - e - 1;\n\t\t\tshiftTable[ i | 0x100 ] = - e - 1;\n\n\t\t\t// normal number\n\n\t\t} else if ( e <= 15 ) {\n\n\t\t\tbaseTable[ i ] = ( e + 15 ) << 10;\n\t\t\tbaseTable[ i | 0x100 ] = ( ( e + 15 ) << 10 ) | 0x8000;\n\t\t\tshiftTable[ i ] = 13;\n\t\t\tshiftTable[ i | 0x100 ] = 13;\n\n\t\t\t// large number (Infinity, -Infinity)\n\n\t\t} else if ( e < 128 ) {\n\n\t\t\tbaseTable[ i ] = 0x7c00;\n\t\t\tbaseTable[ i | 0x100 ] = 0xfc00;\n\t\t\tshiftTable[ i ] = 24;\n\t\t\tshiftTable[ i | 0x100 ] = 24;\n\n\t\t\t// stay (NaN, Infinity, -Infinity)\n\n\t\t} else {\n\n\t\t\tbaseTable[ i ] = 0x7c00;\n\t\t\tbaseTable[ i | 0x100 ] = 0xfc00;\n\t\t\tshiftTable[ i ] = 13;\n\t\t\tshiftTable[ i | 0x100 ] = 13;\n\n\t\t}\n\n\t}\n\n\t// float16 to float32 helpers\n\n\tconst mantissaTable = new Uint32Array( 2048 );\n\tconst exponentTable = new Uint32Array( 64 );\n\tconst offsetTable = new Uint32Array( 64 );\n\n\tfor ( let i = 1; i < 1024; ++ i ) {\n\n\t\tlet m = i << 13; // zero pad mantissa bits\n\t\tlet e = 0; // zero exponent\n\n\t\t// normalized\n\t\twhile ( ( m & 0x00800000 ) === 0 ) {\n\n\t\t\tm <<= 1;\n\t\t\te -= 0x00800000; // decrement exponent\n\n\t\t}\n\n\t\tm &= ~ 0x00800000; // clear leading 1 bit\n\t\te += 0x38800000; // adjust bias\n\n\t\tmantissaTable[ i ] = m | e;\n\n\t}\n\n\tfor ( let i = 1024; i < 2048; ++ i ) {\n\n\t\tmantissaTable[ i ] = 0x38000000 + ( ( i - 1024 ) << 13 );\n\n\t}\n\n\tfor ( let i = 1; i < 31; ++ i ) {\n\n\t\texponentTable[ i ] = i << 23;\n\n\t}\n\n\texponentTable[ 31 ] = 0x47800000;\n\texponentTable[ 32 ] = 0x80000000;\n\n\tfor ( let i = 33; i < 63; ++ i ) {\n\n\t\texponentTable[ i ] = 0x80000000 + ( ( i - 32 ) << 23 );\n\n\t}\n\n\texponentTable[ 63 ] = 0xc7800000;\n\n\tfor ( let i = 1; i < 64; ++ i ) {\n\n\t\tif ( i !== 32 ) {\n\n\t\t\toffsetTable[ i ] = 1024;\n\n\t\t}\n\n\t}\n\n\treturn {\n\t\tfloatView: floatView,\n\t\tuint32View: uint32View,\n\t\tbaseTable: baseTable,\n\t\tshiftTable: shiftTable,\n\t\tmantissaTable: mantissaTable,\n\t\texponentTable: exponentTable,\n\t\toffsetTable: offsetTable\n\t};\n\n}\n\n// float32 to float16\n\nfunction toHalfFloat( val ) {\n\n\tif ( Math.abs( val ) > 65504 ) console.warn( 'THREE.DataUtils.toHalfFloat(): Value out of range.' );\n\n\tval = clamp( val, - 65504, 65504 );\n\n\t_tables.floatView[ 0 ] = val;\n\tconst f = _tables.uint32View[ 0 ];\n\tconst e = ( f >> 23 ) & 0x1ff;\n\treturn _tables.baseTable[ e ] + ( ( f & 0x007fffff ) >> _tables.shiftTable[ e ] );\n\n}\n\n// float16 to float32\n\nfunction fromHalfFloat( val ) {\n\n\tconst m = val >> 10;\n\t_tables.uint32View[ 0 ] = _tables.mantissaTable[ _tables.offsetTable[ m ] + ( val & 0x3ff ) ] + _tables.exponentTable[ m ];\n\treturn _tables.floatView[ 0 ];\n\n}\n\nconst DataUtils = {\n\ttoHalfFloat: toHalfFloat,\n\tfromHalfFloat: fromHalfFloat,\n};\n\nconst _vector$9 = /*@__PURE__*/ new Vector3();\nconst _vector2$1 = /*@__PURE__*/ new Vector2();\n\nclass BufferAttribute {\n\n\tconstructor( array, itemSize, normalized = false ) {\n\n\t\tif ( Array.isArray( array ) ) {\n\n\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\n\t\t}\n\n\t\tthis.isBufferAttribute = true;\n\n\t\tthis.name = '';\n\n\t\tthis.array = array;\n\t\tthis.itemSize = itemSize;\n\t\tthis.count = array !== undefined ? array.length / itemSize : 0;\n\t\tthis.normalized = normalized;\n\n\t\tthis.usage = StaticDrawUsage;\n\t\tthis.updateRanges = [];\n\t\tthis.gpuType = FloatType;\n\n\t\tthis.version = 0;\n\n\t}\n\n\tonUploadCallback() {}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\tsetUsage( value ) {\n\n\t\tthis.usage = value;\n\n\t\treturn this;\n\n\t}\n\n\taddUpdateRange( start, count ) {\n\n\t\tthis.updateRanges.push( { start, count } );\n\n\t}\n\n\tclearUpdateRanges() {\n\n\t\tthis.updateRanges.length = 0;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.name = source.name;\n\t\tthis.array = new source.array.constructor( source.array );\n\t\tthis.itemSize = source.itemSize;\n\t\tthis.count = source.count;\n\t\tthis.normalized = source.normalized;\n\n\t\tthis.usage = source.usage;\n\t\tthis.gpuType = source.gpuType;\n\n\t\treturn this;\n\n\t}\n\n\tcopyAt( index1, attribute, index2 ) {\n\n\t\tindex1 *= this.itemSize;\n\t\tindex2 *= attribute.itemSize;\n\n\t\tfor ( let i = 0, l = this.itemSize; i < l; i ++ ) {\n\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tcopyArray( array ) {\n\n\t\tthis.array.set( array );\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix3( m ) {\n\n\t\tif ( this.itemSize === 2 ) {\n\n\t\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t\t_vector2$1.fromBufferAttribute( this, i );\n\t\t\t\t_vector2$1.applyMatrix3( m );\n\n\t\t\t\tthis.setXY( i, _vector2$1.x, _vector2$1.y );\n\n\t\t\t}\n\n\t\t} else if ( this.itemSize === 3 ) {\n\n\t\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t\t_vector$9.fromBufferAttribute( this, i );\n\t\t\t\t_vector$9.applyMatrix3( m );\n\n\t\t\t\tthis.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix4( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$9.fromBufferAttribute( this, i );\n\n\t\t\t_vector$9.applyMatrix4( m );\n\n\t\t\tthis.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tapplyNormalMatrix( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$9.fromBufferAttribute( this, i );\n\n\t\t\t_vector$9.applyNormalMatrix( m );\n\n\t\t\tthis.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttransformDirection( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$9.fromBufferAttribute( this, i );\n\n\t\t\t_vector$9.transformDirection( m );\n\n\t\t\tthis.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tset( value, offset = 0 ) {\n\n\t\t// Matching BufferAttribute constructor, do not normalize the array.\n\t\tthis.array.set( value, offset );\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index, component ) {\n\n\t\tlet value = this.array[ index * this.itemSize + component ];\n\n\t\tif ( this.normalized ) value = denormalize( value, this.array );\n\n\t\treturn value;\n\n\t}\n\n\tsetComponent( index, component, value ) {\n\n\t\tif ( this.normalized ) value = normalize( value, this.array );\n\n\t\tthis.array[ index * this.itemSize + component ] = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetX( index ) {\n\n\t\tlet x = this.array[ index * this.itemSize ];\n\n\t\tif ( this.normalized ) x = denormalize( x, this.array );\n\n\t\treturn x;\n\n\t}\n\n\tsetX( index, x ) {\n\n\t\tif ( this.normalized ) x = normalize( x, this.array );\n\n\t\tthis.array[ index * this.itemSize ] = x;\n\n\t\treturn this;\n\n\t}\n\n\tgetY( index ) {\n\n\t\tlet y = this.array[ index * this.itemSize + 1 ];\n\n\t\tif ( this.normalized ) y = denormalize( y, this.array );\n\n\t\treturn y;\n\n\t}\n\n\tsetY( index, y ) {\n\n\t\tif ( this.normalized ) y = normalize( y, this.array );\n\n\t\tthis.array[ index * this.itemSize + 1 ] = y;\n\n\t\treturn this;\n\n\t}\n\n\tgetZ( index ) {\n\n\t\tlet z = this.array[ index * this.itemSize + 2 ];\n\n\t\tif ( this.normalized ) z = denormalize( z, this.array );\n\n\t\treturn z;\n\n\t}\n\n\tsetZ( index, z ) {\n\n\t\tif ( this.normalized ) z = normalize( z, this.array );\n\n\t\tthis.array[ index * this.itemSize + 2 ] = z;\n\n\t\treturn this;\n\n\t}\n\n\tgetW( index ) {\n\n\t\tlet w = this.array[ index * this.itemSize + 3 ];\n\n\t\tif ( this.normalized ) w = denormalize( w, this.array );\n\n\t\treturn w;\n\n\t}\n\n\tsetW( index, w ) {\n\n\t\tif ( this.normalized ) w = normalize( w, this.array );\n\n\t\tthis.array[ index * this.itemSize + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n\tsetXY( index, x, y ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZ( index, x, y, z ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\t\tthis.array[ index + 2 ] = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZW( index, x, y, z, w ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\t\t\tw = normalize( w, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\t\tthis.array[ index + 2 ] = z;\n\t\tthis.array[ index + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n\tonUpload( callback ) {\n\n\t\tthis.onUploadCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.array, this.itemSize ).copy( this );\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\titemSize: this.itemSize,\n\t\t\ttype: this.array.constructor.name,\n\t\t\tarray: Array.from( this.array ),\n\t\t\tnormalized: this.normalized\n\t\t};\n\n\t\tif ( this.name !== '' ) data.name = this.name;\n\t\tif ( this.usage !== StaticDrawUsage ) data.usage = this.usage;\n\n\t\treturn data;\n\n\t}\n\n}\n\n//\n\nclass Int8BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Int8Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Uint8BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint8Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Uint8ClampedBufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint8ClampedArray( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Int16BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Int16Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Uint16BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint16Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Int32BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Int32Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Uint32BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint32Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Float16BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint16Array( array ), itemSize, normalized );\n\n\t\tthis.isFloat16BufferAttribute = true;\n\n\t}\n\n\tgetX( index ) {\n\n\t\tlet x = fromHalfFloat( this.array[ index * this.itemSize ] );\n\n\t\tif ( this.normalized ) x = denormalize( x, this.array );\n\n\t\treturn x;\n\n\t}\n\n\tsetX( index, x ) {\n\n\t\tif ( this.normalized ) x = normalize( x, this.array );\n\n\t\tthis.array[ index * this.itemSize ] = toHalfFloat( x );\n\n\t\treturn this;\n\n\t}\n\n\tgetY( index ) {\n\n\t\tlet y = fromHalfFloat( this.array[ index * this.itemSize + 1 ] );\n\n\t\tif ( this.normalized ) y = denormalize( y, this.array );\n\n\t\treturn y;\n\n\t}\n\n\tsetY( index, y ) {\n\n\t\tif ( this.normalized ) y = normalize( y, this.array );\n\n\t\tthis.array[ index * this.itemSize + 1 ] = toHalfFloat( y );\n\n\t\treturn this;\n\n\t}\n\n\tgetZ( index ) {\n\n\t\tlet z = fromHalfFloat( this.array[ index * this.itemSize + 2 ] );\n\n\t\tif ( this.normalized ) z = denormalize( z, this.array );\n\n\t\treturn z;\n\n\t}\n\n\tsetZ( index, z ) {\n\n\t\tif ( this.normalized ) z = normalize( z, this.array );\n\n\t\tthis.array[ index * this.itemSize + 2 ] = toHalfFloat( z );\n\n\t\treturn this;\n\n\t}\n\n\tgetW( index ) {\n\n\t\tlet w = fromHalfFloat( this.array[ index * this.itemSize + 3 ] );\n\n\t\tif ( this.normalized ) w = denormalize( w, this.array );\n\n\t\treturn w;\n\n\t}\n\n\tsetW( index, w ) {\n\n\t\tif ( this.normalized ) w = normalize( w, this.array );\n\n\t\tthis.array[ index * this.itemSize + 3 ] = toHalfFloat( w );\n\n\t\treturn this;\n\n\t}\n\n\tsetXY( index, x, y ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = toHalfFloat( x );\n\t\tthis.array[ index + 1 ] = toHalfFloat( y );\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZ( index, x, y, z ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = toHalfFloat( x );\n\t\tthis.array[ index + 1 ] = toHalfFloat( y );\n\t\tthis.array[ index + 2 ] = toHalfFloat( z );\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZW( index, x, y, z, w ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\t\t\tw = normalize( w, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = toHalfFloat( x );\n\t\tthis.array[ index + 1 ] = toHalfFloat( y );\n\t\tthis.array[ index + 2 ] = toHalfFloat( z );\n\t\tthis.array[ index + 3 ] = toHalfFloat( w );\n\n\t\treturn this;\n\n\t}\n\n}\n\n\nclass Float32BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Float32Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nlet _id$1 = 0;\n\nconst _m1 = /*@__PURE__*/ new Matrix4();\nconst _obj = /*@__PURE__*/ new Object3D();\nconst _offset = /*@__PURE__*/ new Vector3();\nconst _box$2 = /*@__PURE__*/ new Box3();\nconst _boxMorphTargets = /*@__PURE__*/ new Box3();\nconst _vector$8 = /*@__PURE__*/ new Vector3();\n\nclass BufferGeometry extends EventDispatcher {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isBufferGeometry = true;\n\n\t\tObject.defineProperty( this, 'id', { value: _id$1 ++ } );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\tthis.index = null;\n\t\tthis.indirect = null;\n\t\tthis.attributes = {};\n\n\t\tthis.morphAttributes = {};\n\t\tthis.morphTargetsRelative = false;\n\n\t\tthis.groups = [];\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\tthis.userData = {};\n\n\t}\n\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetIndirect( indirect ) {\n\n\t\tthis.indirect = indirect;\n\n\t\treturn this;\n\n\t}\n\n\tgetIndirect() {\n\n\t\treturn this.indirect;\n\n\t}\n\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\tsetAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}\n\n\tdeleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}\n\n\thasAttribute( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t}\n\n\taddGroup( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t}\n\n\tclearGroups() {\n\n\t\tthis.groups = [];\n\n\t}\n\n\tsetDrawRange( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tconst position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tconst normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tconst tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tapplyQuaternion( q ) {\n\n\t\t_m1.makeRotationFromQuaternion( q );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateX( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateY( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateZ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\tscale( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1.makeScale( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\tlookAt( vector ) {\n\n\t\t_obj.lookAt( vector );\n\n\t\t_obj.updateMatrix();\n\n\t\tthis.applyMatrix4( _obj.matrix );\n\n\t\treturn this;\n\n\t}\n\n\tcenter() {\n\n\t\tthis.computeBoundingBox();\n\n\t\tthis.boundingBox.getCenter( _offset ).negate();\n\n\t\tthis.translate( _offset.x, _offset.y, _offset.z );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute === undefined ) {\n\n\t\t\tconst position = [];\n\n\t\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tconst point = points[ i ];\n\t\t\t\tposition.push( point.x, point.y, point.z || 0 );\n\n\t\t\t}\n\n\t\t\tthis.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\n\t\t} else {\n\n\t\t\tconst l = Math.min( points.length, positionAttribute.count ); // make sure data do not exceed buffer size\n\n\t\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t\tconst point = points[ i ];\n\t\t\t\tpositionAttribute.setXYZ( i, point.x, point.y, point.z || 0 );\n\n\t\t\t}\n\n\t\t\tif ( points.length > positionAttribute.count ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.' );\n\n\t\t\t}\n\n\t\t\tpositionAttribute.needsUpdate = true;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this );\n\n\t\t\tthis.boundingBox.set(\n\t\t\t\tnew Vector3( - Infinity, - Infinity, - Infinity ),\n\t\t\t\tnew Vector3( + Infinity, + Infinity, + Infinity )\n\t\t\t);\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_box$2.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector$8.addVectors( this.boundingBox.min, _box$2.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector$8 );\n\n\t\t\t\t\t\t_vector$8.addVectors( this.boundingBox.max, _box$2.max );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector$8 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box$2.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box$2.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t}\n\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this );\n\n\t\t\tthis.boundingSphere.set( new Vector3(), Infinity );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position ) {\n\n\t\t\t// first, find the center of the bounding sphere\n\n\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\t_box$2.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_boxMorphTargets.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector$8.addVectors( _box$2.min, _boxMorphTargets.min );\n\t\t\t\t\t\t_box$2.expandByPoint( _vector$8 );\n\n\t\t\t\t\t\t_vector$8.addVectors( _box$2.max, _boxMorphTargets.max );\n\t\t\t\t\t\t_box$2.expandByPoint( _vector$8 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_box$2.expandByPoint( _boxMorphTargets.min );\n\t\t\t\t\t\t_box$2.expandByPoint( _boxMorphTargets.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_box$2.getCenter( center );\n\n\t\t\t// second, try to find a boundingSphere with a radius smaller than the\n\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor ( let i = 0, il = position.count; i < il; i ++ ) {\n\n\t\t\t\t_vector$8.fromBufferAttribute( position, i );\n\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );\n\n\t\t\t}\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\tconst morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t\t\t\tfor ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t_vector$8.fromBufferAttribute( morphAttribute, j );\n\n\t\t\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t\t\t_offset.fromBufferAttribute( position, j );\n\t\t\t\t\t\t\t_vector$8.add( _offset );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcomputeTangents() {\n\n\t\tconst index = this.index;\n\t\tconst attributes = this.attributes;\n\n\t\t// based on http://www.terathon.com/code/tangent.html\n\t\t// (per vertex tangents)\n\n\t\tif ( index === null ||\n\t\t\t attributes.position === undefined ||\n\t\t\t attributes.normal === undefined ||\n\t\t\t attributes.uv === undefined ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst positionAttribute = attributes.position;\n\t\tconst normalAttribute = attributes.normal;\n\t\tconst uvAttribute = attributes.uv;\n\n\t\tif ( this.hasAttribute( 'tangent' ) === false ) {\n\n\t\t\tthis.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * positionAttribute.count ), 4 ) );\n\n\t\t}\n\n\t\tconst tangentAttribute = this.getAttribute( 'tangent' );\n\n\t\tconst tan1 = [], tan2 = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\ttan1[ i ] = new Vector3();\n\t\t\ttan2[ i ] = new Vector3();\n\n\t\t}\n\n\t\tconst vA = new Vector3(),\n\t\t\tvB = new Vector3(),\n\t\t\tvC = new Vector3(),\n\n\t\t\tuvA = new Vector2(),\n\t\t\tuvB = new Vector2(),\n\t\t\tuvC = new Vector2(),\n\n\t\t\tsdir = new Vector3(),\n\t\t\ttdir = new Vector3();\n\n\t\tfunction handleTriangle( a, b, c ) {\n\n\t\t\tvA.fromBufferAttribute( positionAttribute, a );\n\t\t\tvB.fromBufferAttribute( positionAttribute, b );\n\t\t\tvC.fromBufferAttribute( positionAttribute, c );\n\n\t\t\tuvA.fromBufferAttribute( uvAttribute, a );\n\t\t\tuvB.fromBufferAttribute( uvAttribute, b );\n\t\t\tuvC.fromBufferAttribute( uvAttribute, c );\n\n\t\t\tvB.sub( vA );\n\t\t\tvC.sub( vA );\n\n\t\t\tuvB.sub( uvA );\n\t\t\tuvC.sub( uvA );\n\n\t\t\tconst r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );\n\n\t\t\t// silently ignore degenerate uv triangles having coincident or colinear vertices\n\n\t\t\tif ( ! isFinite( r ) ) return;\n\n\t\t\tsdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );\n\t\t\ttdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );\n\n\t\t\ttan1[ a ].add( sdir );\n\t\t\ttan1[ b ].add( sdir );\n\t\t\ttan1[ c ].add( sdir );\n\n\t\t\ttan2[ a ].add( tdir );\n\t\t\ttan2[ b ].add( tdir );\n\t\t\ttan2[ c ].add( tdir );\n\n\t\t}\n\n\t\tlet groups = this.groups;\n\n\t\tif ( groups.length === 0 ) {\n\n\t\t\tgroups = [ {\n\t\t\t\tstart: 0,\n\t\t\t\tcount: index.count\n\t\t\t} ];\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleTriangle(\n\t\t\t\t\tindex.getX( j + 0 ),\n\t\t\t\t\tindex.getX( j + 1 ),\n\t\t\t\t\tindex.getX( j + 2 )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst tmp = new Vector3(), tmp2 = new Vector3();\n\t\tconst n = new Vector3(), n2 = new Vector3();\n\n\t\tfunction handleVertex( v ) {\n\n\t\t\tn.fromBufferAttribute( normalAttribute, v );\n\t\t\tn2.copy( n );\n\n\t\t\tconst t = tan1[ v ];\n\n\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\ttmp.copy( t );\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t// Calculate handedness\n\n\t\t\ttmp2.crossVectors( n2, t );\n\t\t\tconst test = tmp2.dot( tan2[ v ] );\n\t\t\tconst w = ( test < 0.0 ) ? - 1.0 : 1.0;\n\n\t\t\ttangentAttribute.setXYZW( v, tmp.x, tmp.y, tmp.z, w );\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleVertex( index.getX( j + 0 ) );\n\t\t\t\thandleVertex( index.getX( j + 1 ) );\n\t\t\t\thandleVertex( index.getX( j + 2 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcomputeVertexNormals() {\n\n\t\tconst index = this.index;\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute !== undefined ) {\n\n\t\t\tlet normalAttribute = this.getAttribute( 'normal' );\n\n\t\t\tif ( normalAttribute === undefined ) {\n\n\t\t\t\tnormalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );\n\t\t\t\tthis.setAttribute( 'normal', normalAttribute );\n\n\t\t\t} else {\n\n\t\t\t\t// reset existing normals to zero\n\n\t\t\t\tfor ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {\n\n\t\t\t\t\tnormalAttribute.setXYZ( i, 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n\t\t\tconst nA = new Vector3(), nB = new Vector3(), nC = new Vector3();\n\t\t\tconst cb = new Vector3(), ab = new Vector3();\n\n\t\t\t// indexed elements\n\n\t\t\tif ( index ) {\n\n\t\t\t\tfor ( let i = 0, il = index.count; i < il; i += 3 ) {\n\n\t\t\t\t\tconst vA = index.getX( i + 0 );\n\t\t\t\t\tconst vB = index.getX( i + 1 );\n\t\t\t\t\tconst vC = index.getX( i + 2 );\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, vA );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, vB );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, vC );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnA.fromBufferAttribute( normalAttribute, vA );\n\t\t\t\t\tnB.fromBufferAttribute( normalAttribute, vB );\n\t\t\t\t\tnC.fromBufferAttribute( normalAttribute, vC );\n\n\t\t\t\t\tnA.add( cb );\n\t\t\t\t\tnB.add( cb );\n\t\t\t\t\tnC.add( cb );\n\n\t\t\t\t\tnormalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\tfor ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, i + 0 );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, i + 1 );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, i + 2 );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tnormalAttribute.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\tnormalizeNormals() {\n\n\t\tconst normals = this.attributes.normal;\n\n\t\tfor ( let i = 0, il = normals.count; i < il; i ++ ) {\n\n\t\t\t_vector$8.fromBufferAttribute( normals, i );\n\n\t\t\t_vector$8.normalize();\n\n\t\t\tnormals.setXYZ( i, _vector$8.x, _vector$8.y, _vector$8.z );\n\n\t\t}\n\n\t}\n\n\ttoNonIndexed() {\n\n\t\tfunction convertBufferAttribute( attribute, indices ) {\n\n\t\t\tconst array = attribute.array;\n\t\t\tconst itemSize = attribute.itemSize;\n\t\t\tconst normalized = attribute.normalized;\n\n\t\t\tconst array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tlet index = 0, index2 = 0;\n\n\t\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\tindex = indices[ i ] * attribute.data.stride + attribute.offset;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( array2, itemSize, normalized );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.index === null ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst geometry2 = new BufferGeometry();\n\n\t\tconst indices = this.index.array;\n\t\tconst attributes = this.attributes;\n\n\t\t// attributes\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\n\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\tgeometry2.setAttribute( name, newAttribute );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = this.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst morphArray = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = morphAttribute[ i ];\n\n\t\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\t\tmorphArray.push( newAttribute );\n\n\t\t\t}\n\n\t\t\tgeometry2.morphAttributes[ name ] = morphArray;\n\n\t\t}\n\n\t\tgeometry2.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = this.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tgeometry2.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\treturn geometry2;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard BufferGeometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\t\tif ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tconst parameters = this.parameters;\n\n\t\t\tfor ( const key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\t// for simplicity the code assumes attributes are not shared across geometries, see #15811\n\n\t\tdata.data = { attributes: {} };\n\n\t\tconst index = this.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tdata.data.index = {\n\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\tarray: Array.prototype.slice.call( index.array )\n\t\t\t};\n\n\t\t}\n\n\t\tconst attributes = this.attributes;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attribute = attributes[ key ];\n\n\t\t\tdata.data.attributes[ key ] = attribute.toJSON( data.data );\n\n\t\t}\n\n\t\tconst morphAttributes = {};\n\t\tlet hasMorphAttributes = false;\n\n\t\tfor ( const key in this.morphAttributes ) {\n\n\t\t\tconst attributeArray = this.morphAttributes[ key ];\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0, il = attributeArray.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = attributeArray[ i ];\n\n\t\t\t\tarray.push( attribute.toJSON( data.data ) );\n\n\t\t\t}\n\n\t\t\tif ( array.length > 0 ) {\n\n\t\t\t\tmorphAttributes[ key ] = array;\n\n\t\t\t\thasMorphAttributes = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( hasMorphAttributes ) {\n\n\t\t\tdata.data.morphAttributes = morphAttributes;\n\t\t\tdata.data.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t}\n\n\t\tconst groups = this.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\n\t\t}\n\n\t\tconst boundingSphere = this.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tdata.data.boundingSphere = {\n\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\tradius: boundingSphere.radius\n\t\t\t};\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\t// reset\n\n\t\tthis.index = null;\n\t\tthis.attributes = {};\n\t\tthis.morphAttributes = {};\n\t\tthis.groups = [];\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// used for storing cloned, shared data\n\n\t\tconst data = {};\n\n\t\t// name\n\n\t\tthis.name = source.name;\n\n\t\t// index\n\n\t\tconst index = source.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.setIndex( index.clone( data ) );\n\n\t\t}\n\n\t\t// attributes\n\n\t\tconst attributes = source.attributes;\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\t\t\tthis.setAttribute( name, attribute.clone( data ) );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = source.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst array = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {\n\n\t\t\t\tarray.push( morphAttribute[ i ].clone( data ) );\n\n\t\t\t}\n\n\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t}\n\n\t\tthis.morphTargetsRelative = source.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = source.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\t// bounding box\n\n\t\tconst boundingBox = source.boundingBox;\n\n\t\tif ( boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = boundingBox.clone();\n\n\t\t}\n\n\t\t// bounding sphere\n\n\t\tconst boundingSphere = source.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = boundingSphere.clone();\n\n\t\t}\n\n\t\t// draw range\n\n\t\tthis.drawRange.start = source.drawRange.start;\n\t\tthis.drawRange.count = source.drawRange.count;\n\n\t\t// user data\n\n\t\tthis.userData = source.userData;\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n}\n\nconst _inverseMatrix$3 = /*@__PURE__*/ new Matrix4();\nconst _ray$3 = /*@__PURE__*/ new Ray();\nconst _sphere$6 = /*@__PURE__*/ new Sphere();\nconst _sphereHitAt = /*@__PURE__*/ new Vector3();\n\nconst _vA$1 = /*@__PURE__*/ new Vector3();\nconst _vB$1 = /*@__PURE__*/ new Vector3();\nconst _vC$1 = /*@__PURE__*/ new Vector3();\n\nconst _tempA = /*@__PURE__*/ new Vector3();\nconst _morphA = /*@__PURE__*/ new Vector3();\n\nconst _intersectionPoint = /*@__PURE__*/ new Vector3();\nconst _intersectionPointWorld = /*@__PURE__*/ new Vector3();\n\nclass Mesh extends Object3D {\n\n\tconstructor( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {\n\n\t\tsuper();\n\n\t\tthis.isMesh = true;\n\n\t\tthis.type = 'Mesh';\n\n\t\tthis.geometry = geometry;\n\t\tthis.material = material;\n\n\t\tthis.updateMorphTargets();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tif ( source.morphTargetInfluences !== undefined ) {\n\n\t\t\tthis.morphTargetInfluences = source.morphTargetInfluences.slice();\n\n\t\t}\n\n\t\tif ( source.morphTargetDictionary !== undefined ) {\n\n\t\t\tthis.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );\n\n\t\t}\n\n\t\tthis.material = Array.isArray( source.material ) ? source.material.slice() : source.material;\n\t\tthis.geometry = source.geometry;\n\n\t\treturn this;\n\n\t}\n\n\tupdateMorphTargets() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst morphAttributes = geometry.morphAttributes;\n\t\tconst keys = Object.keys( morphAttributes );\n\n\t\tif ( keys.length > 0 ) {\n\n\t\t\tconst morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\tfor ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\tconst name = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tgetVertexPosition( index, target ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst position = geometry.attributes.position;\n\t\tconst morphPosition = geometry.morphAttributes.position;\n\t\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\n\t\ttarget.fromBufferAttribute( position, index );\n\n\t\tconst morphInfluences = this.morphTargetInfluences;\n\n\t\tif ( morphPosition && morphInfluences ) {\n\n\t\t\t_morphA.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0, il = morphPosition.length; i < il; i ++ ) {\n\n\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\tconst morphAttribute = morphPosition[ i ];\n\n\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute( morphAttribute, index );\n\n\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( target ), influence );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttarget.add( _morphA );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst material = this.material;\n\t\tconst matrixWorld = this.matrixWorld;\n\n\t\tif ( material === undefined ) return;\n\n\t\t// test with bounding sphere in world space\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere$6.copy( geometry.boundingSphere );\n\t\t_sphere$6.applyMatrix4( matrixWorld );\n\n\t\t// check distance from ray origin to bounding sphere\n\n\t\t_ray$3.copy( raycaster.ray ).recast( raycaster.near );\n\n\t\tif ( _sphere$6.containsPoint( _ray$3.origin ) === false ) {\n\n\t\t\tif ( _ray$3.intersectSphere( _sphere$6, _sphereHitAt ) === null ) return;\n\n\t\t\tif ( _ray$3.origin.distanceToSquared( _sphereHitAt ) > ( raycaster.far - raycaster.near ) ** 2 ) return;\n\n\t\t}\n\n\t\t// convert ray to local space of mesh\n\n\t\t_inverseMatrix$3.copy( matrixWorld ).invert();\n\t\t_ray$3.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$3 );\n\n\t\t// test with bounding box in local space\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tif ( _ray$3.intersectsBox( geometry.boundingBox ) === false ) return;\n\n\t\t}\n\n\t\t// test for intersections with geometry\n\n\t\tthis._computeIntersections( raycaster, intersects, _ray$3 );\n\n\t}\n\n\t_computeIntersections( raycaster, intersects, rayLocalSpace ) {\n\n\t\tlet intersection;\n\n\t\tconst geometry = this.geometry;\n\t\tconst material = this.material;\n\n\t\tconst index = geometry.index;\n\t\tconst position = geometry.attributes.position;\n\t\tconst uv = geometry.attributes.uv;\n\t\tconst uv1 = geometry.attributes.uv1;\n\t\tconst normal = geometry.attributes.normal;\n\t\tconst groups = geometry.groups;\n\t\tconst drawRange = geometry.drawRange;\n\n\t\tif ( index !== null ) {\n\n\t\t\t// indexed buffer geometry\n\n\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\tconst start = Math.max( group.start, drawRange.start );\n\t\t\t\t\tconst end = Math.min( index.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );\n\n\t\t\t\t\tfor ( let j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\t\tconst a = index.getX( j );\n\t\t\t\t\t\tconst b = index.getX( j + 1 );\n\t\t\t\t\t\tconst c = index.getX( j + 2 );\n\n\t\t\t\t\t\tintersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics\n\t\t\t\t\t\t\tintersection.face.materialIndex = group.materialIndex;\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\t\tconst end = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( let i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\t\tconst a = index.getX( i );\n\t\t\t\t\tconst b = index.getX( i + 1 );\n\t\t\t\t\tconst c = index.getX( i + 2 );\n\n\t\t\t\t\tintersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );\n\n\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics\n\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( position !== undefined ) {\n\n\t\t\t// non-indexed buffer geometry\n\n\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\tconst start = Math.max( group.start, drawRange.start );\n\t\t\t\t\tconst end = Math.min( position.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );\n\n\t\t\t\t\tfor ( let j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\t\tconst a = j;\n\t\t\t\t\t\tconst b = j + 1;\n\t\t\t\t\t\tconst c = j + 2;\n\n\t\t\t\t\t\tintersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics\n\t\t\t\t\t\t\tintersection.face.materialIndex = group.materialIndex;\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\t\tconst end = Math.min( position.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( let i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\t\tconst a = i;\n\t\t\t\t\tconst b = i + 1;\n\t\t\t\t\tconst c = i + 2;\n\n\t\t\t\t\tintersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );\n\n\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics\n\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nfunction checkIntersection$1( object, material, raycaster, ray, pA, pB, pC, point ) {\n\n\tlet intersect;\n\n\tif ( material.side === BackSide ) {\n\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t} else {\n\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, ( material.side === FrontSide ), point );\n\n\t}\n\n\tif ( intersect === null ) return null;\n\n\t_intersectionPointWorld.copy( point );\n\t_intersectionPointWorld.applyMatrix4( object.matrixWorld );\n\n\tconst distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );\n\n\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\n\n\treturn {\n\t\tdistance: distance,\n\t\tpoint: _intersectionPointWorld.clone(),\n\t\tobject: object\n\t};\n\n}\n\nfunction checkGeometryIntersection( object, material, raycaster, ray, uv, uv1, normal, a, b, c ) {\n\n\tobject.getVertexPosition( a, _vA$1 );\n\tobject.getVertexPosition( b, _vB$1 );\n\tobject.getVertexPosition( c, _vC$1 );\n\n\tconst intersection = checkIntersection$1( object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint );\n\n\tif ( intersection ) {\n\n\t\tconst barycoord = new Vector3();\n\t\tTriangle.getBarycoord( _intersectionPoint, _vA$1, _vB$1, _vC$1, barycoord );\n\n\t\tif ( uv ) {\n\n\t\t\tintersection.uv = Triangle.getInterpolatedAttribute( uv, a, b, c, barycoord, new Vector2() );\n\n\t\t}\n\n\t\tif ( uv1 ) {\n\n\t\t\tintersection.uv1 = Triangle.getInterpolatedAttribute( uv1, a, b, c, barycoord, new Vector2() );\n\n\t\t}\n\n\t\tif ( normal ) {\n\n\t\t\tintersection.normal = Triangle.getInterpolatedAttribute( normal, a, b, c, barycoord, new Vector3() );\n\n\t\t\tif ( intersection.normal.dot( ray.direction ) > 0 ) {\n\n\t\t\t\tintersection.normal.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst face = {\n\t\t\ta: a,\n\t\t\tb: b,\n\t\t\tc: c,\n\t\t\tnormal: new Vector3(),\n\t\t\tmaterialIndex: 0\n\t\t};\n\n\t\tTriangle.getNormal( _vA$1, _vB$1, _vC$1, face.normal );\n\n\t\tintersection.face = face;\n\t\tintersection.barycoord = barycoord;\n\n\t}\n\n\treturn intersection;\n\n}\n\nclass BoxGeometry extends BufferGeometry {\n\n\tconstructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'BoxGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tdepth: depth,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tdepthSegments: depthSegments\n\t\t};\n\n\t\tconst scope = this;\n\n\t\t// segments\n\n\t\twidthSegments = Math.floor( widthSegments );\n\t\theightSegments = Math.floor( heightSegments );\n\t\tdepthSegments = Math.floor( depthSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tlet numberOfVertices = 0;\n\t\tlet groupStart = 0;\n\n\t\t// build each side of the box geometry\n\n\t\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px\n\t\tbuildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx\n\t\tbuildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py\n\t\tbuildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny\n\t\tbuildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz\n\t\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\tfunction buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\n\n\t\t\tconst segmentWidth = width / gridX;\n\t\t\tconst segmentHeight = height / gridY;\n\n\t\t\tconst widthHalf = width / 2;\n\t\t\tconst heightHalf = height / 2;\n\t\t\tconst depthHalf = depth / 2;\n\n\t\t\tconst gridX1 = gridX + 1;\n\t\t\tconst gridY1 = gridY + 1;\n\n\t\t\tlet vertexCounter = 0;\n\t\t\tlet groupCount = 0;\n\n\t\t\tconst vector = new Vector3();\n\n\t\t\t// generate vertices, normals and uvs\n\n\t\t\tfor ( let iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\t\tconst y = iy * segmentHeight - heightHalf;\n\n\t\t\t\tfor ( let ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\t\tconst x = ix * segmentWidth - widthHalf;\n\n\t\t\t\t\t// set values to correct vector component\n\n\t\t\t\t\tvector[ u ] = x * udir;\n\t\t\t\t\tvector[ v ] = y * vdir;\n\t\t\t\t\tvector[ w ] = depthHalf;\n\n\t\t\t\t\t// now apply vector to vertex buffer\n\n\t\t\t\t\tvertices.push( vector.x, vector.y, vector.z );\n\n\t\t\t\t\t// set values to correct vector component\n\n\t\t\t\t\tvector[ u ] = 0;\n\t\t\t\t\tvector[ v ] = 0;\n\t\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\n\n\t\t\t\t\t// now apply vector to normal buffer\n\n\t\t\t\t\tnormals.push( vector.x, vector.y, vector.z );\n\n\t\t\t\t\t// uvs\n\n\t\t\t\t\tuvs.push( ix / gridX );\n\t\t\t\t\tuvs.push( 1 - ( iy / gridY ) );\n\n\t\t\t\t\t// counters\n\n\t\t\t\t\tvertexCounter += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// indices\n\n\t\t\t// 1. you need three indices to draw a single face\n\t\t\t// 2. a single segment consists of two faces\n\t\t\t// 3. so we need to generate six (2*3) indices per segment\n\n\t\t\tfor ( let iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\t\tfor ( let ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\t\tconst a = numberOfVertices + ix + gridX1 * iy;\n\t\t\t\t\tconst b = numberOfVertices + ix + gridX1 * ( iy + 1 );\n\t\t\t\t\tconst c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\t\tconst d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t\t// increase counter\n\n\t\t\t\t\tgroupCount += 6;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, materialIndex );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t\t// update total number of vertices\n\n\t\t\tnumberOfVertices += vertexCounter;\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new BoxGeometry( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments );\n\n\t}\n\n}\n\n/**\n * Uniform Utilities\n */\n\nfunction cloneUniforms( src ) {\n\n\tconst dst = {};\n\n\tfor ( const u in src ) {\n\n\t\tdst[ u ] = {};\n\n\t\tfor ( const p in src[ u ] ) {\n\n\t\t\tconst property = src[ u ][ p ];\n\n\t\t\tif ( property && ( property.isColor ||\n\t\t\t\tproperty.isMatrix3 || property.isMatrix4 ||\n\t\t\t\tproperty.isVector2 || property.isVector3 || property.isVector4 ||\n\t\t\t\tproperty.isTexture || property.isQuaternion ) ) {\n\n\t\t\t\tif ( property.isRenderTargetTexture ) {\n\n\t\t\t\t\tconsole.warn( 'UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().' );\n\t\t\t\t\tdst[ u ][ p ] = null;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdst[ u ][ p ] = property.clone();\n\n\t\t\t\t}\n\n\t\t\t} else if ( Array.isArray( property ) ) {\n\n\t\t\t\tdst[ u ][ p ] = property.slice();\n\n\t\t\t} else {\n\n\t\t\t\tdst[ u ][ p ] = property;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn dst;\n\n}\n\nfunction mergeUniforms( uniforms ) {\n\n\tconst merged = {};\n\n\tfor ( let u = 0; u < uniforms.length; u ++ ) {\n\n\t\tconst tmp = cloneUniforms( uniforms[ u ] );\n\n\t\tfor ( const p in tmp ) {\n\n\t\t\tmerged[ p ] = tmp[ p ];\n\n\t\t}\n\n\t}\n\n\treturn merged;\n\n}\n\nfunction cloneUniformsGroups( src ) {\n\n\tconst dst = [];\n\n\tfor ( let u = 0; u < src.length; u ++ ) {\n\n\t\tdst.push( src[ u ].clone() );\n\n\t}\n\n\treturn dst;\n\n}\n\nfunction getUnlitUniformColorSpace( renderer ) {\n\n\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\tif ( currentRenderTarget === null ) {\n\n\t\t// https://github.com/mrdoob/three.js/pull/23937#issuecomment-1111067398\n\t\treturn renderer.outputColorSpace;\n\n\t}\n\n\t// https://github.com/mrdoob/three.js/issues/27868\n\tif ( currentRenderTarget.isXRRenderTarget === true ) {\n\n\t\treturn currentRenderTarget.texture.colorSpace;\n\n\t}\n\n\treturn ColorManagement.workingColorSpace;\n\n}\n\n// Legacy\n\nconst UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };\n\nvar default_vertex = \"void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\";\n\nvar default_fragment = \"void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}\";\n\nclass ShaderMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isShaderMaterial = true;\n\n\t\tthis.type = 'ShaderMaterial';\n\n\t\tthis.defines = {};\n\t\tthis.uniforms = {};\n\t\tthis.uniformsGroups = [];\n\n\t\tthis.vertexShader = default_vertex;\n\t\tthis.fragmentShader = default_fragment;\n\n\t\tthis.linewidth = 1;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.fog = false; // set to use scene fog\n\t\tthis.lights = false; // set to use scene lights\n\t\tthis.clipping = false; // set to use user-defined clipping planes\n\n\t\tthis.forceSinglePass = true;\n\n\t\tthis.extensions = {\n\t\t\tclipCullDistance: false, // set to use vertex shader clipping\n\t\t\tmultiDraw: false // set to use vertex shader multi_draw / enable gl_DrawID\n\t\t};\n\n\t\t// When rendered geometry doesn't include these attributes but the material does,\n\t\t// use these default values in WebGL. This avoids errors when buffer data is missing.\n\t\tthis.defaultAttributeValues = {\n\t\t\t'color': [ 1, 1, 1 ],\n\t\t\t'uv': [ 0, 0 ],\n\t\t\t'uv1': [ 0, 0 ]\n\t\t};\n\n\t\tthis.index0AttributeName = undefined;\n\t\tthis.uniformsNeedUpdate = false;\n\n\t\tthis.glslVersion = null;\n\n\t\tif ( parameters !== undefined ) {\n\n\t\t\tthis.setValues( parameters );\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.fragmentShader = source.fragmentShader;\n\t\tthis.vertexShader = source.vertexShader;\n\n\t\tthis.uniforms = cloneUniforms( source.uniforms );\n\t\tthis.uniformsGroups = cloneUniformsGroups( source.uniformsGroups );\n\n\t\tthis.defines = Object.assign( {}, source.defines );\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\tthis.fog = source.fog;\n\t\tthis.lights = source.lights;\n\t\tthis.clipping = source.clipping;\n\n\t\tthis.extensions = Object.assign( {}, source.extensions );\n\n\t\tthis.glslVersion = source.glslVersion;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.glslVersion = this.glslVersion;\n\t\tdata.uniforms = {};\n\n\t\tfor ( const name in this.uniforms ) {\n\n\t\t\tconst uniform = this.uniforms[ name ];\n\t\t\tconst value = uniform.value;\n\n\t\t\tif ( value && value.isTexture ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 't',\n\t\t\t\t\tvalue: value.toJSON( meta ).uuid\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isColor ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'c',\n\t\t\t\t\tvalue: value.getHex()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isVector2 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'v2',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isVector3 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'v3',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isVector4 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'v4',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isMatrix3 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'm3',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isMatrix4 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'm4',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\tvalue: value\n\t\t\t\t};\n\n\t\t\t\t// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;\n\n\t\tdata.vertexShader = this.vertexShader;\n\t\tdata.fragmentShader = this.fragmentShader;\n\n\t\tdata.lights = this.lights;\n\t\tdata.clipping = this.clipping;\n\n\t\tconst extensions = {};\n\n\t\tfor ( const key in this.extensions ) {\n\n\t\t\tif ( this.extensions[ key ] === true ) extensions[ key ] = true;\n\n\t\t}\n\n\t\tif ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass Camera extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isCamera = true;\n\n\t\tthis.type = 'Camera';\n\n\t\tthis.matrixWorldInverse = new Matrix4();\n\n\t\tthis.projectionMatrix = new Matrix4();\n\t\tthis.projectionMatrixInverse = new Matrix4();\n\n\t\tthis.coordinateSystem = WebGLCoordinateSystem;\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\n\n\t\tthis.projectionMatrix.copy( source.projectionMatrix );\n\t\tthis.projectionMatrixInverse.copy( source.projectionMatrixInverse );\n\n\t\tthis.coordinateSystem = source.coordinateSystem;\n\n\t\treturn this;\n\n\t}\n\n\tgetWorldDirection( target ) {\n\n\t\treturn super.getWorldDirection( target ).negate();\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tthis.matrixWorldInverse.copy( this.matrixWorld ).invert();\n\n\t}\n\n\tupdateWorldMatrix( updateParents, updateChildren ) {\n\n\t\tsuper.updateWorldMatrix( updateParents, updateChildren );\n\n\t\tthis.matrixWorldInverse.copy( this.matrixWorld ).invert();\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nconst _v3$1 = /*@__PURE__*/ new Vector3();\nconst _minTarget = /*@__PURE__*/ new Vector2();\nconst _maxTarget = /*@__PURE__*/ new Vector2();\n\n\nclass PerspectiveCamera extends Camera {\n\n\tconstructor( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {\n\n\t\tsuper();\n\n\t\tthis.isPerspectiveCamera = true;\n\n\t\tthis.type = 'PerspectiveCamera';\n\n\t\tthis.fov = fov;\n\t\tthis.zoom = 1;\n\n\t\tthis.near = near;\n\t\tthis.far = far;\n\t\tthis.focus = 10;\n\n\t\tthis.aspect = aspect;\n\t\tthis.view = null;\n\n\t\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\n\t\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.fov = source.fov;\n\t\tthis.zoom = source.zoom;\n\n\t\tthis.near = source.near;\n\t\tthis.far = source.far;\n\t\tthis.focus = source.focus;\n\n\t\tthis.aspect = source.aspect;\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\tthis.filmGauge = source.filmGauge;\n\t\tthis.filmOffset = source.filmOffset;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the FOV by focal length in respect to the current .filmGauge.\n\t *\n\t * The default film gauge is 35, so that the focal length can be specified for\n\t * a 35mm (full frame) camera.\n\t *\n\t * Values for focal length and film gauge must have the same unit.\n\t */\n\tsetFocalLength( focalLength ) {\n\n\t\t/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */\n\t\tconst vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n\n\t\tthis.fov = RAD2DEG * 2 * Math.atan( vExtentSlope );\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\t/**\n\t * Calculates the focal length from the current .fov and .filmGauge.\n\t */\n\tgetFocalLength() {\n\n\t\tconst vExtentSlope = Math.tan( DEG2RAD * 0.5 * this.fov );\n\n\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\n\n\t}\n\n\tgetEffectiveFOV() {\n\n\t\treturn RAD2DEG * 2 * Math.atan(\n\t\t\tMath.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom );\n\n\t}\n\n\tgetFilmWidth() {\n\n\t\t// film not completely covered in portrait format (aspect < 1)\n\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\n\n\t}\n\n\tgetFilmHeight() {\n\n\t\t// film not completely covered in landscape format (aspect > 1)\n\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\n\n\t}\n\n\t/**\n\t * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.\n\t * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.\n\t */\n\tgetViewBounds( distance, minTarget, maxTarget ) {\n\n\t\t_v3$1.set( - 1, - 1, 0.5 ).applyMatrix4( this.projectionMatrixInverse );\n\n\t\tminTarget.set( _v3$1.x, _v3$1.y ).multiplyScalar( - distance / _v3$1.z );\n\n\t\t_v3$1.set( 1, 1, 0.5 ).applyMatrix4( this.projectionMatrixInverse );\n\n\t\tmaxTarget.set( _v3$1.x, _v3$1.y ).multiplyScalar( - distance / _v3$1.z );\n\n\t}\n\n\t/**\n\t * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.\n\t * Copies the result into the target Vector2, where x is width and y is height.\n\t */\n\tgetViewSize( distance, target ) {\n\n\t\tthis.getViewBounds( distance, _minTarget, _maxTarget );\n\n\t\treturn target.subVectors( _maxTarget, _minTarget );\n\n\t}\n\n\t/**\n\t * Sets an offset in a larger frustum. This is useful for multi-window or\n\t * multi-monitor/multi-machine setups.\n\t *\n\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\t * the monitors are in grid like this\n\t *\n\t *   +---+---+---+\n\t *   | A | B | C |\n\t *   +---+---+---+\n\t *   | D | E | F |\n\t *   +---+---+---+\n\t *\n\t * then for each monitor you would call it like this\n\t *\n\t *   const w = 1920;\n\t *   const h = 1080;\n\t *   const fullWidth = w * 3;\n\t *   const fullHeight = h * 2;\n\t *\n\t *   --A--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\t *   --B--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\t *   --C--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\t *   --D--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\t *   --E--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\t *   --F--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\t *\n\t *   Note there is no reason monitors have to be the same size or in a grid.\n\t */\n\tsetViewOffset( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\tthis.aspect = fullWidth / fullHeight;\n\n\t\tif ( this.view === null ) {\n\n\t\t\tthis.view = {\n\t\t\t\tenabled: true,\n\t\t\t\tfullWidth: 1,\n\t\t\t\tfullHeight: 1,\n\t\t\t\toffsetX: 0,\n\t\t\t\toffsetY: 0,\n\t\t\t\twidth: 1,\n\t\t\t\theight: 1\n\t\t\t};\n\n\t\t}\n\n\t\tthis.view.enabled = true;\n\t\tthis.view.fullWidth = fullWidth;\n\t\tthis.view.fullHeight = fullHeight;\n\t\tthis.view.offsetX = x;\n\t\tthis.view.offsetY = y;\n\t\tthis.view.width = width;\n\t\tthis.view.height = height;\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tclearViewOffset() {\n\n\t\tif ( this.view !== null ) {\n\n\t\t\tthis.view.enabled = false;\n\n\t\t}\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tupdateProjectionMatrix() {\n\n\t\tconst near = this.near;\n\t\tlet top = near * Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom;\n\t\tlet height = 2 * top;\n\t\tlet width = this.aspect * height;\n\t\tlet left = - 0.5 * width;\n\t\tconst view = this.view;\n\n\t\tif ( this.view !== null && this.view.enabled ) {\n\n\t\t\tconst fullWidth = view.fullWidth,\n\t\t\t\tfullHeight = view.fullHeight;\n\n\t\t\tleft += view.offsetX * width / fullWidth;\n\t\t\ttop -= view.offsetY * height / fullHeight;\n\t\t\twidth *= view.width / fullWidth;\n\t\t\theight *= view.height / fullHeight;\n\n\t\t}\n\n\t\tconst skew = this.filmOffset;\n\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\n\n\t\tthis.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far, this.coordinateSystem );\n\n\t\tthis.projectionMatrixInverse.copy( this.projectionMatrix ).invert();\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.fov = this.fov;\n\t\tdata.object.zoom = this.zoom;\n\n\t\tdata.object.near = this.near;\n\t\tdata.object.far = this.far;\n\t\tdata.object.focus = this.focus;\n\n\t\tdata.object.aspect = this.aspect;\n\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\tdata.object.filmGauge = this.filmGauge;\n\t\tdata.object.filmOffset = this.filmOffset;\n\n\t\treturn data;\n\n\t}\n\n}\n\nconst fov = - 90; // negative fov is not an error\nconst aspect = 1;\n\nclass CubeCamera extends Object3D {\n\n\tconstructor( near, far, renderTarget ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CubeCamera';\n\n\t\tthis.renderTarget = renderTarget;\n\t\tthis.coordinateSystem = null;\n\t\tthis.activeMipmapLevel = 0;\n\n\t\tconst cameraPX = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPX.layers = this.layers;\n\t\tthis.add( cameraPX );\n\n\t\tconst cameraNX = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNX.layers = this.layers;\n\t\tthis.add( cameraNX );\n\n\t\tconst cameraPY = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPY.layers = this.layers;\n\t\tthis.add( cameraPY );\n\n\t\tconst cameraNY = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNY.layers = this.layers;\n\t\tthis.add( cameraNY );\n\n\t\tconst cameraPZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPZ.layers = this.layers;\n\t\tthis.add( cameraPZ );\n\n\t\tconst cameraNZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNZ.layers = this.layers;\n\t\tthis.add( cameraNZ );\n\n\t}\n\n\tupdateCoordinateSystem() {\n\n\t\tconst coordinateSystem = this.coordinateSystem;\n\n\t\tconst cameras = this.children.concat();\n\n\t\tconst [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = cameras;\n\n\t\tfor ( const camera of cameras ) this.remove( camera );\n\n\t\tif ( coordinateSystem === WebGLCoordinateSystem ) {\n\n\t\t\tcameraPX.up.set( 0, 1, 0 );\n\t\t\tcameraPX.lookAt( 1, 0, 0 );\n\n\t\t\tcameraNX.up.set( 0, 1, 0 );\n\t\t\tcameraNX.lookAt( - 1, 0, 0 );\n\n\t\t\tcameraPY.up.set( 0, 0, - 1 );\n\t\t\tcameraPY.lookAt( 0, 1, 0 );\n\n\t\t\tcameraNY.up.set( 0, 0, 1 );\n\t\t\tcameraNY.lookAt( 0, - 1, 0 );\n\n\t\t\tcameraPZ.up.set( 0, 1, 0 );\n\t\t\tcameraPZ.lookAt( 0, 0, 1 );\n\n\t\t\tcameraNZ.up.set( 0, 1, 0 );\n\t\t\tcameraNZ.lookAt( 0, 0, - 1 );\n\n\t\t} else if ( coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\tcameraPX.up.set( 0, - 1, 0 );\n\t\t\tcameraPX.lookAt( - 1, 0, 0 );\n\n\t\t\tcameraNX.up.set( 0, - 1, 0 );\n\t\t\tcameraNX.lookAt( 1, 0, 0 );\n\n\t\t\tcameraPY.up.set( 0, 0, 1 );\n\t\t\tcameraPY.lookAt( 0, 1, 0 );\n\n\t\t\tcameraNY.up.set( 0, 0, - 1 );\n\t\t\tcameraNY.lookAt( 0, - 1, 0 );\n\n\t\t\tcameraPZ.up.set( 0, - 1, 0 );\n\t\t\tcameraPZ.lookAt( 0, 0, 1 );\n\n\t\t\tcameraNZ.up.set( 0, - 1, 0 );\n\t\t\tcameraNZ.lookAt( 0, 0, - 1 );\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' + coordinateSystem );\n\n\t\t}\n\n\t\tfor ( const camera of cameras ) {\n\n\t\t\tthis.add( camera );\n\n\t\t\tcamera.updateMatrixWorld();\n\n\t\t}\n\n\t}\n\n\tupdate( renderer, scene ) {\n\n\t\tif ( this.parent === null ) this.updateMatrixWorld();\n\n\t\tconst { renderTarget, activeMipmapLevel } = this;\n\n\t\tif ( this.coordinateSystem !== renderer.coordinateSystem ) {\n\n\t\t\tthis.coordinateSystem = renderer.coordinateSystem;\n\n\t\t\tthis.updateCoordinateSystem();\n\n\t\t}\n\n\t\tconst [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = this.children;\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst currentActiveCubeFace = renderer.getActiveCubeFace();\n\t\tconst currentActiveMipmapLevel = renderer.getActiveMipmapLevel();\n\n\t\tconst currentXrEnabled = renderer.xr.enabled;\n\n\t\trenderer.xr.enabled = false;\n\n\t\tconst generateMipmaps = renderTarget.texture.generateMipmaps;\n\n\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\trenderer.setRenderTarget( renderTarget, 0, activeMipmapLevel );\n\t\trenderer.render( scene, cameraPX );\n\n\t\trenderer.setRenderTarget( renderTarget, 1, activeMipmapLevel );\n\t\trenderer.render( scene, cameraNX );\n\n\t\trenderer.setRenderTarget( renderTarget, 2, activeMipmapLevel );\n\t\trenderer.render( scene, cameraPY );\n\n\t\trenderer.setRenderTarget( renderTarget, 3, activeMipmapLevel );\n\t\trenderer.render( scene, cameraNY );\n\n\t\trenderer.setRenderTarget( renderTarget, 4, activeMipmapLevel );\n\t\trenderer.render( scene, cameraPZ );\n\n\t\t// mipmaps are generated during the last call of render()\n\t\t// at this point, all sides of the cube render target are defined\n\n\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\n\n\t\trenderer.setRenderTarget( renderTarget, 5, activeMipmapLevel );\n\t\trenderer.render( scene, cameraNZ );\n\n\t\trenderer.setRenderTarget( currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel );\n\n\t\trenderer.xr.enabled = currentXrEnabled;\n\n\t\trenderTarget.texture.needsPMREMUpdate = true;\n\n\t}\n\n}\n\nclass CubeTexture extends Texture {\n\n\tconstructor( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace ) {\n\n\t\timages = images !== undefined ? images : [];\n\t\tmapping = mapping !== undefined ? mapping : CubeReflectionMapping;\n\n\t\tsuper( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );\n\n\t\tthis.isCubeTexture = true;\n\n\t\tthis.flipY = false;\n\n\t}\n\n\tget images() {\n\n\t\treturn this.image;\n\n\t}\n\n\tset images( value ) {\n\n\t\tthis.image = value;\n\n\t}\n\n}\n\nclass WebGLCubeRenderTarget extends WebGLRenderTarget {\n\n\tconstructor( size = 1, options = {} ) {\n\n\t\tsuper( size, size, options );\n\n\t\tthis.isWebGLCubeRenderTarget = true;\n\n\t\tconst image = { width: size, height: size, depth: 1 };\n\t\tconst images = [ image, image, image, image, image, image ];\n\n\t\tthis.texture = new CubeTexture( images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace );\n\n\t\t// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)\n\t\t// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,\n\t\t// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.\n\n\t\t// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped\n\t\t// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture\n\t\t// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).\n\n\t\tthis.texture.isRenderTargetTexture = true;\n\n\t\tthis.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;\n\t\tthis.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;\n\n\t}\n\n\tfromEquirectangularTexture( renderer, texture ) {\n\n\t\tthis.texture.type = texture.type;\n\t\tthis.texture.colorSpace = texture.colorSpace;\n\n\t\tthis.texture.generateMipmaps = texture.generateMipmaps;\n\t\tthis.texture.minFilter = texture.minFilter;\n\t\tthis.texture.magFilter = texture.magFilter;\n\n\t\tconst shader = {\n\n\t\t\tuniforms: {\n\t\t\t\ttEquirect: { value: null },\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t`\n\t\t};\n\n\t\tconst geometry = new BoxGeometry( 5, 5, 5 );\n\n\t\tconst material = new ShaderMaterial( {\n\n\t\t\tname: 'CubemapFromEquirect',\n\n\t\t\tuniforms: cloneUniforms( shader.uniforms ),\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tside: BackSide,\n\t\t\tblending: NoBlending\n\n\t\t} );\n\n\t\tmaterial.uniforms.tEquirect.value = texture;\n\n\t\tconst mesh = new Mesh( geometry, material );\n\n\t\tconst currentMinFilter = texture.minFilter;\n\n\t\t// Avoid blurred poles\n\t\tif ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;\n\n\t\tconst camera = new CubeCamera( 1, 10, this );\n\t\tcamera.update( renderer, mesh );\n\n\t\ttexture.minFilter = currentMinFilter;\n\n\t\tmesh.geometry.dispose();\n\t\tmesh.material.dispose();\n\n\t\treturn this;\n\n\t}\n\n\tclear( renderer, color, depth, stencil ) {\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\trenderer.setRenderTarget( this, i );\n\n\t\t\trenderer.clear( color, depth, stencil );\n\n\t\t}\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t}\n\n}\n\nclass FogExp2 {\n\n\tconstructor( color, density = 0.00025 ) {\n\n\t\tthis.isFogExp2 = true;\n\n\t\tthis.name = '';\n\n\t\tthis.color = new Color( color );\n\t\tthis.density = density;\n\n\t}\n\n\tclone() {\n\n\t\treturn new FogExp2( this.color, this.density );\n\n\t}\n\n\ttoJSON( /* meta */ ) {\n\n\t\treturn {\n\t\t\ttype: 'FogExp2',\n\t\t\tname: this.name,\n\t\t\tcolor: this.color.getHex(),\n\t\t\tdensity: this.density\n\t\t};\n\n\t}\n\n}\n\nclass Fog {\n\n\tconstructor( color, near = 1, far = 1000 ) {\n\n\t\tthis.isFog = true;\n\n\t\tthis.name = '';\n\n\t\tthis.color = new Color( color );\n\n\t\tthis.near = near;\n\t\tthis.far = far;\n\n\t}\n\n\tclone() {\n\n\t\treturn new Fog( this.color, this.near, this.far );\n\n\t}\n\n\ttoJSON( /* meta */ ) {\n\n\t\treturn {\n\t\t\ttype: 'Fog',\n\t\t\tname: this.name,\n\t\t\tcolor: this.color.getHex(),\n\t\t\tnear: this.near,\n\t\t\tfar: this.far\n\t\t};\n\n\t}\n\n}\n\nclass Scene extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isScene = true;\n\n\t\tthis.type = 'Scene';\n\n\t\tthis.background = null;\n\t\tthis.environment = null;\n\t\tthis.fog = null;\n\n\t\tthis.backgroundBlurriness = 0;\n\t\tthis.backgroundIntensity = 1;\n\t\tthis.backgroundRotation = new Euler();\n\n\t\tthis.environmentIntensity = 1;\n\t\tthis.environmentRotation = new Euler();\n\n\t\tthis.overrideMaterial = null;\n\n\t\tif ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {\n\n\t\t\t__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );\n\n\t\t}\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tif ( source.background !== null ) this.background = source.background.clone();\n\t\tif ( source.environment !== null ) this.environment = source.environment.clone();\n\t\tif ( source.fog !== null ) this.fog = source.fog.clone();\n\n\t\tthis.backgroundBlurriness = source.backgroundBlurriness;\n\t\tthis.backgroundIntensity = source.backgroundIntensity;\n\t\tthis.backgroundRotation.copy( source.backgroundRotation );\n\n\t\tthis.environmentIntensity = source.environmentIntensity;\n\t\tthis.environmentRotation.copy( source.environmentRotation );\n\n\t\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tif ( this.fog !== null ) data.object.fog = this.fog.toJSON();\n\n\t\tif ( this.backgroundBlurriness > 0 ) data.object.backgroundBlurriness = this.backgroundBlurriness;\n\t\tif ( this.backgroundIntensity !== 1 ) data.object.backgroundIntensity = this.backgroundIntensity;\n\t\tdata.object.backgroundRotation = this.backgroundRotation.toArray();\n\n\t\tif ( this.environmentIntensity !== 1 ) data.object.environmentIntensity = this.environmentIntensity;\n\t\tdata.object.environmentRotation = this.environmentRotation.toArray();\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass InterleavedBuffer {\n\n\tconstructor( array, stride ) {\n\n\t\tthis.isInterleavedBuffer = true;\n\n\t\tthis.array = array;\n\t\tthis.stride = stride;\n\t\tthis.count = array !== undefined ? array.length / stride : 0;\n\n\t\tthis.usage = StaticDrawUsage;\n\t\tthis.updateRanges = [];\n\n\t\tthis.version = 0;\n\n\t\tthis.uuid = generateUUID();\n\n\t}\n\n\tonUploadCallback() {}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\tsetUsage( value ) {\n\n\t\tthis.usage = value;\n\n\t\treturn this;\n\n\t}\n\n\taddUpdateRange( start, count ) {\n\n\t\tthis.updateRanges.push( { start, count } );\n\n\t}\n\n\tclearUpdateRanges() {\n\n\t\tthis.updateRanges.length = 0;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.array = new source.array.constructor( source.array );\n\t\tthis.count = source.count;\n\t\tthis.stride = source.stride;\n\t\tthis.usage = source.usage;\n\n\t\treturn this;\n\n\t}\n\n\tcopyAt( index1, attribute, index2 ) {\n\n\t\tindex1 *= this.stride;\n\t\tindex2 *= attribute.stride;\n\n\t\tfor ( let i = 0, l = this.stride; i < l; i ++ ) {\n\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tset( value, offset = 0 ) {\n\n\t\tthis.array.set( value, offset );\n\n\t\treturn this;\n\n\t}\n\n\tclone( data ) {\n\n\t\tif ( data.arrayBuffers === undefined ) {\n\n\t\t\tdata.arrayBuffers = {};\n\n\t\t}\n\n\t\tif ( this.array.buffer._uuid === undefined ) {\n\n\t\t\tthis.array.buffer._uuid = generateUUID();\n\n\t\t}\n\n\t\tif ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {\n\n\t\t\tdata.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;\n\n\t\t}\n\n\t\tconst array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );\n\n\t\tconst ib = new this.constructor( array, this.stride );\n\t\tib.setUsage( this.usage );\n\n\t\treturn ib;\n\n\t}\n\n\tonUpload( callback ) {\n\n\t\tthis.onUploadCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( data ) {\n\n\t\tif ( data.arrayBuffers === undefined ) {\n\n\t\t\tdata.arrayBuffers = {};\n\n\t\t}\n\n\t\t// generate UUID for array buffer if necessary\n\n\t\tif ( this.array.buffer._uuid === undefined ) {\n\n\t\t\tthis.array.buffer._uuid = generateUUID();\n\n\t\t}\n\n\t\tif ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {\n\n\t\t\tdata.arrayBuffers[ this.array.buffer._uuid ] = Array.from( new Uint32Array( this.array.buffer ) );\n\n\t\t}\n\n\t\t//\n\n\t\treturn {\n\t\t\tuuid: this.uuid,\n\t\t\tbuffer: this.array.buffer._uuid,\n\t\t\ttype: this.array.constructor.name,\n\t\t\tstride: this.stride\n\t\t};\n\n\t}\n\n}\n\nconst _vector$7 = /*@__PURE__*/ new Vector3();\n\nclass InterleavedBufferAttribute {\n\n\tconstructor( interleavedBuffer, itemSize, offset, normalized = false ) {\n\n\t\tthis.isInterleavedBufferAttribute = true;\n\n\t\tthis.name = '';\n\n\t\tthis.data = interleavedBuffer;\n\t\tthis.itemSize = itemSize;\n\t\tthis.offset = offset;\n\n\t\tthis.normalized = normalized;\n\n\t}\n\n\tget count() {\n\n\t\treturn this.data.count;\n\n\t}\n\n\tget array() {\n\n\t\treturn this.data.array;\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tthis.data.needsUpdate = value;\n\n\t}\n\n\tapplyMatrix4( m ) {\n\n\t\tfor ( let i = 0, l = this.data.count; i < l; i ++ ) {\n\n\t\t\t_vector$7.fromBufferAttribute( this, i );\n\n\t\t\t_vector$7.applyMatrix4( m );\n\n\t\t\tthis.setXYZ( i, _vector$7.x, _vector$7.y, _vector$7.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tapplyNormalMatrix( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$7.fromBufferAttribute( this, i );\n\n\t\t\t_vector$7.applyNormalMatrix( m );\n\n\t\t\tthis.setXYZ( i, _vector$7.x, _vector$7.y, _vector$7.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttransformDirection( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$7.fromBufferAttribute( this, i );\n\n\t\t\t_vector$7.transformDirection( m );\n\n\t\t\tthis.setXYZ( i, _vector$7.x, _vector$7.y, _vector$7.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index, component ) {\n\n\t\tlet value = this.array[ index * this.data.stride + this.offset + component ];\n\n\t\tif ( this.normalized ) value = denormalize( value, this.array );\n\n\t\treturn value;\n\n\t}\n\n\tsetComponent( index, component, value ) {\n\n\t\tif ( this.normalized ) value = normalize( value, this.array );\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + component ] = value;\n\n\t\treturn this;\n\n\t}\n\n\tsetX( index, x ) {\n\n\t\tif ( this.normalized ) x = normalize( x, this.array );\n\n\t\tthis.data.array[ index * this.data.stride + this.offset ] = x;\n\n\t\treturn this;\n\n\t}\n\n\tsetY( index, y ) {\n\n\t\tif ( this.normalized ) y = normalize( y, this.array );\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetZ( index, z ) {\n\n\t\tif ( this.normalized ) z = normalize( z, this.array );\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetW( index, w ) {\n\n\t\tif ( this.normalized ) w = normalize( w, this.array );\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n\tgetX( index ) {\n\n\t\tlet x = this.data.array[ index * this.data.stride + this.offset ];\n\n\t\tif ( this.normalized ) x = denormalize( x, this.array );\n\n\t\treturn x;\n\n\t}\n\n\tgetY( index ) {\n\n\t\tlet y = this.data.array[ index * this.data.stride + this.offset + 1 ];\n\n\t\tif ( this.normalized ) y = denormalize( y, this.array );\n\n\t\treturn y;\n\n\t}\n\n\tgetZ( index ) {\n\n\t\tlet z = this.data.array[ index * this.data.stride + this.offset + 2 ];\n\n\t\tif ( this.normalized ) z = denormalize( z, this.array );\n\n\t\treturn z;\n\n\t}\n\n\tgetW( index ) {\n\n\t\tlet w = this.data.array[ index * this.data.stride + this.offset + 3 ];\n\n\t\tif ( this.normalized ) w = denormalize( w, this.array );\n\n\t\treturn w;\n\n\t}\n\n\tsetXY( index, x, y ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\n\t\t}\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZ( index, x, y, z ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\n\t\t}\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\t\tthis.data.array[ index + 2 ] = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZW( index, x, y, z, w ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\t\t\tw = normalize( w, this.array );\n\n\t\t}\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\t\tthis.data.array[ index + 2 ] = z;\n\t\tthis.data.array[ index + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n\tclone( data ) {\n\n\t\tif ( data === undefined ) {\n\n\t\t\tconsole.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.' );\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0; i < this.count; i ++ ) {\n\n\t\t\t\tconst index = i * this.data.stride + this.offset;\n\n\t\t\t\tfor ( let j = 0; j < this.itemSize; j ++ ) {\n\n\t\t\t\t\tarray.push( this.data.array[ index + j ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );\n\n\t\t} else {\n\n\t\t\tif ( data.interleavedBuffers === undefined ) {\n\n\t\t\t\tdata.interleavedBuffers = {};\n\n\t\t\t}\n\n\t\t\tif ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {\n\n\t\t\t\tdata.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );\n\n\t\t\t}\n\n\t\t\treturn new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );\n\n\t\t}\n\n\t}\n\n\ttoJSON( data ) {\n\n\t\tif ( data === undefined ) {\n\n\t\t\tconsole.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.' );\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0; i < this.count; i ++ ) {\n\n\t\t\t\tconst index = i * this.data.stride + this.offset;\n\n\t\t\t\tfor ( let j = 0; j < this.itemSize; j ++ ) {\n\n\t\t\t\t\tarray.push( this.data.array[ index + j ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// de-interleave data and save it as an ordinary buffer attribute for now\n\n\t\t\treturn {\n\t\t\t\titemSize: this.itemSize,\n\t\t\t\ttype: this.array.constructor.name,\n\t\t\t\tarray: array,\n\t\t\t\tnormalized: this.normalized\n\t\t\t};\n\n\t\t} else {\n\n\t\t\t// save as true interleaved attribute\n\n\t\t\tif ( data.interleavedBuffers === undefined ) {\n\n\t\t\t\tdata.interleavedBuffers = {};\n\n\t\t\t}\n\n\t\t\tif ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {\n\n\t\t\t\tdata.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tisInterleavedBufferAttribute: true,\n\t\t\t\titemSize: this.itemSize,\n\t\t\t\tdata: this.data.uuid,\n\t\t\t\toffset: this.offset,\n\t\t\t\tnormalized: this.normalized\n\t\t\t};\n\n\t\t}\n\n\t}\n\n}\n\nclass SpriteMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isSpriteMaterial = true;\n\n\t\tthis.type = 'SpriteMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.rotation = 0;\n\n\t\tthis.sizeAttenuation = true;\n\n\t\tthis.transparent = true;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.rotation = source.rotation;\n\n\t\tthis.sizeAttenuation = source.sizeAttenuation;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nlet _geometry;\n\nconst _intersectPoint = /*@__PURE__*/ new Vector3();\nconst _worldScale = /*@__PURE__*/ new Vector3();\nconst _mvPosition = /*@__PURE__*/ new Vector3();\n\nconst _alignedPosition = /*@__PURE__*/ new Vector2();\nconst _rotatedPosition = /*@__PURE__*/ new Vector2();\nconst _viewWorldMatrix = /*@__PURE__*/ new Matrix4();\n\nconst _vA = /*@__PURE__*/ new Vector3();\nconst _vB = /*@__PURE__*/ new Vector3();\nconst _vC = /*@__PURE__*/ new Vector3();\n\nconst _uvA = /*@__PURE__*/ new Vector2();\nconst _uvB = /*@__PURE__*/ new Vector2();\nconst _uvC = /*@__PURE__*/ new Vector2();\n\nclass Sprite extends Object3D {\n\n\tconstructor( material = new SpriteMaterial() ) {\n\n\t\tsuper();\n\n\t\tthis.isSprite = true;\n\n\t\tthis.type = 'Sprite';\n\n\t\tif ( _geometry === undefined ) {\n\n\t\t\t_geometry = new BufferGeometry();\n\n\t\t\tconst float32Array = new Float32Array( [\n\t\t\t\t- 0.5, - 0.5, 0, 0, 0,\n\t\t\t\t0.5, - 0.5, 0, 1, 0,\n\t\t\t\t0.5, 0.5, 0, 1, 1,\n\t\t\t\t- 0.5, 0.5, 0, 0, 1\n\t\t\t] );\n\n\t\t\tconst interleavedBuffer = new InterleavedBuffer( float32Array, 5 );\n\n\t\t\t_geometry.setIndex( [ 0, 1, 2,\t0, 2, 3 ] );\n\t\t\t_geometry.setAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );\n\t\t\t_geometry.setAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );\n\n\t\t}\n\n\t\tthis.geometry = _geometry;\n\t\tthis.material = material;\n\n\t\tthis.center = new Vector2( 0.5, 0.5 );\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tif ( raycaster.camera === null ) {\n\n\t\t\tconsole.error( 'THREE.Sprite: \"Raycaster.camera\" needs to be set in order to raycast against sprites.' );\n\n\t\t}\n\n\t\t_worldScale.setFromMatrixScale( this.matrixWorld );\n\n\t\t_viewWorldMatrix.copy( raycaster.camera.matrixWorld );\n\t\tthis.modelViewMatrix.multiplyMatrices( raycaster.camera.matrixWorldInverse, this.matrixWorld );\n\n\t\t_mvPosition.setFromMatrixPosition( this.modelViewMatrix );\n\n\t\tif ( raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false ) {\n\n\t\t\t_worldScale.multiplyScalar( - _mvPosition.z );\n\n\t\t}\n\n\t\tconst rotation = this.material.rotation;\n\t\tlet sin, cos;\n\n\t\tif ( rotation !== 0 ) {\n\n\t\t\tcos = Math.cos( rotation );\n\t\t\tsin = Math.sin( rotation );\n\n\t\t}\n\n\t\tconst center = this.center;\n\n\t\ttransformVertex( _vA.set( - 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );\n\t\ttransformVertex( _vB.set( 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );\n\t\ttransformVertex( _vC.set( 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );\n\n\t\t_uvA.set( 0, 0 );\n\t\t_uvB.set( 1, 0 );\n\t\t_uvC.set( 1, 1 );\n\n\t\t// check first triangle\n\t\tlet intersect = raycaster.ray.intersectTriangle( _vA, _vB, _vC, false, _intersectPoint );\n\n\t\tif ( intersect === null ) {\n\n\t\t\t// check second triangle\n\t\t\ttransformVertex( _vB.set( - 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );\n\t\t\t_uvB.set( 0, 1 );\n\n\t\t\tintersect = raycaster.ray.intersectTriangle( _vA, _vC, _vB, false, _intersectPoint );\n\t\t\tif ( intersect === null ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst distance = raycaster.ray.origin.distanceTo( _intersectPoint );\n\n\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\t\tintersects.push( {\n\n\t\t\tdistance: distance,\n\t\t\tpoint: _intersectPoint.clone(),\n\t\t\tuv: Triangle.getInterpolation( _intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() ),\n\t\t\tface: null,\n\t\t\tobject: this\n\n\t\t} );\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tif ( source.center !== undefined ) this.center.copy( source.center );\n\n\t\tthis.material = source.material;\n\n\t\treturn this;\n\n\t}\n\n}\n\nfunction transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {\n\n\t// compute position in camera space\n\t_alignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );\n\n\t// to check if rotation is not zero\n\tif ( sin !== undefined ) {\n\n\t\t_rotatedPosition.x = ( cos * _alignedPosition.x ) - ( sin * _alignedPosition.y );\n\t\t_rotatedPosition.y = ( sin * _alignedPosition.x ) + ( cos * _alignedPosition.y );\n\n\t} else {\n\n\t\t_rotatedPosition.copy( _alignedPosition );\n\n\t}\n\n\n\tvertexPosition.copy( mvPosition );\n\tvertexPosition.x += _rotatedPosition.x;\n\tvertexPosition.y += _rotatedPosition.y;\n\n\t// transform to world space\n\tvertexPosition.applyMatrix4( _viewWorldMatrix );\n\n}\n\nconst _v1$2 = /*@__PURE__*/ new Vector3();\nconst _v2$1 = /*@__PURE__*/ new Vector3();\n\nclass LOD extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis._currentLevel = 0;\n\n\t\tthis.type = 'LOD';\n\n\t\tObject.defineProperties( this, {\n\t\t\tlevels: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: []\n\t\t\t},\n\t\t\tisLOD: {\n\t\t\t\tvalue: true,\n\t\t\t}\n\t\t} );\n\n\t\tthis.autoUpdate = true;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source, false );\n\n\t\tconst levels = source.levels;\n\n\t\tfor ( let i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\tconst level = levels[ i ];\n\n\t\t\tthis.addLevel( level.object.clone(), level.distance, level.hysteresis );\n\n\t\t}\n\n\t\tthis.autoUpdate = source.autoUpdate;\n\n\t\treturn this;\n\n\t}\n\n\taddLevel( object, distance = 0, hysteresis = 0 ) {\n\n\t\tdistance = Math.abs( distance );\n\n\t\tconst levels = this.levels;\n\n\t\tlet l;\n\n\t\tfor ( l = 0; l < levels.length; l ++ ) {\n\n\t\t\tif ( distance < levels[ l ].distance ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlevels.splice( l, 0, { distance: distance, hysteresis: hysteresis, object: object } );\n\n\t\tthis.add( object );\n\n\t\treturn this;\n\n\t}\n\n\tremoveLevel( distance ) {\n\n\t\tconst levels = this.levels;\n\n\t\tfor ( let i = 0; i < levels.length; i ++ ) {\n\n\t\t\tif ( levels[ i ].distance === distance ) {\n\n\t\t\t\tconst removedElements = levels.splice( i, 1 );\n\t\t\t\tthis.remove( removedElements[ 0 ].object );\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tgetCurrentLevel() {\n\n\t\treturn this._currentLevel;\n\n\t}\n\n\n\n\tgetObjectForDistance( distance ) {\n\n\t\tconst levels = this.levels;\n\n\t\tif ( levels.length > 0 ) {\n\n\t\t\tlet i, l;\n\n\t\t\tfor ( i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\tlet levelDistance = levels[ i ].distance;\n\n\t\t\t\tif ( levels[ i ].object.visible ) {\n\n\t\t\t\t\tlevelDistance -= levelDistance * levels[ i ].hysteresis;\n\n\t\t\t\t}\n\n\t\t\t\tif ( distance < levelDistance ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn levels[ i - 1 ].object;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst levels = this.levels;\n\n\t\tif ( levels.length > 0 ) {\n\n\t\t\t_v1$2.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tconst distance = raycaster.ray.origin.distanceTo( _v1$2 );\n\n\t\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\n\n\t\t}\n\n\t}\n\n\tupdate( camera ) {\n\n\t\tconst levels = this.levels;\n\n\t\tif ( levels.length > 1 ) {\n\n\t\t\t_v1$2.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t_v2$1.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tconst distance = _v1$2.distanceTo( _v2$1 ) / camera.zoom;\n\n\t\t\tlevels[ 0 ].object.visible = true;\n\n\t\t\tlet i, l;\n\n\t\t\tfor ( i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\tlet levelDistance = levels[ i ].distance;\n\n\t\t\t\tif ( levels[ i ].object.visible ) {\n\n\t\t\t\t\tlevelDistance -= levelDistance * levels[ i ].hysteresis;\n\n\t\t\t\t}\n\n\t\t\t\tif ( distance >= levelDistance ) {\n\n\t\t\t\t\tlevels[ i - 1 ].object.visible = false;\n\t\t\t\t\tlevels[ i ].object.visible = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._currentLevel = i - 1;\n\n\t\t\tfor ( ; i < l; i ++ ) {\n\n\t\t\t\tlevels[ i ].object.visible = false;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tif ( this.autoUpdate === false ) data.object.autoUpdate = false;\n\n\t\tdata.object.levels = [];\n\n\t\tconst levels = this.levels;\n\n\t\tfor ( let i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\tconst level = levels[ i ];\n\n\t\t\tdata.object.levels.push( {\n\t\t\t\tobject: level.object.uuid,\n\t\t\t\tdistance: level.distance,\n\t\t\t\thysteresis: level.hysteresis\n\t\t\t} );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n}\n\nconst _basePosition = /*@__PURE__*/ new Vector3();\n\nconst _skinIndex = /*@__PURE__*/ new Vector4();\nconst _skinWeight = /*@__PURE__*/ new Vector4();\n\nconst _vector3 = /*@__PURE__*/ new Vector3();\nconst _matrix4 = /*@__PURE__*/ new Matrix4();\nconst _vertex = /*@__PURE__*/ new Vector3();\n\nconst _sphere$5 = /*@__PURE__*/ new Sphere();\nconst _inverseMatrix$2 = /*@__PURE__*/ new Matrix4();\nconst _ray$2 = /*@__PURE__*/ new Ray();\n\nclass SkinnedMesh extends Mesh {\n\n\tconstructor( geometry, material ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isSkinnedMesh = true;\n\n\t\tthis.type = 'SkinnedMesh';\n\n\t\tthis.bindMode = AttachedBindMode;\n\t\tthis.bindMatrix = new Matrix4();\n\t\tthis.bindMatrixInverse = new Matrix4();\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tthis.boundingBox.makeEmpty();\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\tthis.getVertexPosition( i, _vertex );\n\t\t\tthis.boundingBox.expandByPoint( _vertex );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tthis.boundingSphere.makeEmpty();\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\tthis.getVertexPosition( i, _vertex );\n\t\t\tthis.boundingSphere.expandByPoint( _vertex );\n\n\t\t}\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.bindMode = source.bindMode;\n\t\tthis.bindMatrix.copy( source.bindMatrix );\n\t\tthis.bindMatrixInverse.copy( source.bindMatrixInverse );\n\n\t\tthis.skeleton = source.skeleton;\n\n\t\tif ( source.boundingBox !== null ) this.boundingBox = source.boundingBox.clone();\n\t\tif ( source.boundingSphere !== null ) this.boundingSphere = source.boundingSphere.clone();\n\n\t\treturn this;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst material = this.material;\n\t\tconst matrixWorld = this.matrixWorld;\n\n\t\tif ( material === undefined ) return;\n\n\t\t// test with bounding sphere in world space\n\n\t\tif ( this.boundingSphere === null ) this.computeBoundingSphere();\n\n\t\t_sphere$5.copy( this.boundingSphere );\n\t\t_sphere$5.applyMatrix4( matrixWorld );\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere$5 ) === false ) return;\n\n\t\t// convert ray to local space of skinned mesh\n\n\t\t_inverseMatrix$2.copy( matrixWorld ).invert();\n\t\t_ray$2.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$2 );\n\n\t\t// test with bounding box in local space\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tif ( _ray$2.intersectsBox( this.boundingBox ) === false ) return;\n\n\t\t}\n\n\t\t// test for intersections with geometry\n\n\t\tthis._computeIntersections( raycaster, intersects, _ray$2 );\n\n\t}\n\n\tgetVertexPosition( index, target ) {\n\n\t\tsuper.getVertexPosition( index, target );\n\n\t\tthis.applyBoneTransform( index, target );\n\n\t\treturn target;\n\n\t}\n\n\tbind( skeleton, bindMatrix ) {\n\n\t\tthis.skeleton = skeleton;\n\n\t\tif ( bindMatrix === undefined ) {\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\tthis.skeleton.calculateInverses();\n\n\t\t\tbindMatrix = this.matrixWorld;\n\n\t\t}\n\n\t\tthis.bindMatrix.copy( bindMatrix );\n\t\tthis.bindMatrixInverse.copy( bindMatrix ).invert();\n\n\t}\n\n\tpose() {\n\n\t\tthis.skeleton.pose();\n\n\t}\n\n\tnormalizeSkinWeights() {\n\n\t\tconst vector = new Vector4();\n\n\t\tconst skinWeight = this.geometry.attributes.skinWeight;\n\n\t\tfor ( let i = 0, l = skinWeight.count; i < l; i ++ ) {\n\n\t\t\tvector.fromBufferAttribute( skinWeight, i );\n\n\t\t\tconst scale = 1.0 / vector.manhattanLength();\n\n\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\tvector.multiplyScalar( scale );\n\n\t\t\t} else {\n\n\t\t\t\tvector.set( 1, 0, 0, 0 ); // do something reasonable\n\n\t\t\t}\n\n\t\t\tskinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );\n\n\t\t}\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tif ( this.bindMode === AttachedBindMode ) {\n\n\t\t\tthis.bindMatrixInverse.copy( this.matrixWorld ).invert();\n\n\t\t} else if ( this.bindMode === DetachedBindMode ) {\n\n\t\t\tthis.bindMatrixInverse.copy( this.bindMatrix ).invert();\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );\n\n\t\t}\n\n\t}\n\n\tapplyBoneTransform( index, vector ) {\n\n\t\tconst skeleton = this.skeleton;\n\t\tconst geometry = this.geometry;\n\n\t\t_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );\n\t\t_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );\n\n\t\t_basePosition.copy( vector ).applyMatrix4( this.bindMatrix );\n\n\t\tvector.set( 0, 0, 0 );\n\n\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\tconst weight = _skinWeight.getComponent( i );\n\n\t\t\tif ( weight !== 0 ) {\n\n\t\t\t\tconst boneIndex = _skinIndex.getComponent( i );\n\n\t\t\t\t_matrix4.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );\n\n\t\t\t\tvector.addScaledVector( _vector3.copy( _basePosition ).applyMatrix4( _matrix4 ), weight );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn vector.applyMatrix4( this.bindMatrixInverse );\n\n\t}\n\n}\n\nclass Bone extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isBone = true;\n\n\t\tthis.type = 'Bone';\n\n\t}\n\n}\n\nclass DataTexture extends Texture {\n\n\tconstructor( data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace ) {\n\n\t\tsuper( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );\n\n\t\tthis.isDataTexture = true;\n\n\t\tthis.image = { data: data, width: width, height: height };\n\n\t\tthis.generateMipmaps = false;\n\t\tthis.flipY = false;\n\t\tthis.unpackAlignment = 1;\n\n\t}\n\n}\n\nconst _offsetMatrix = /*@__PURE__*/ new Matrix4();\nconst _identityMatrix = /*@__PURE__*/ new Matrix4();\n\nclass Skeleton {\n\n\tconstructor( bones = [], boneInverses = [] ) {\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.bones = bones.slice( 0 );\n\t\tthis.boneInverses = boneInverses;\n\t\tthis.boneMatrices = null;\n\n\t\tthis.boneTexture = null;\n\n\t\tthis.init();\n\n\t}\n\n\tinit() {\n\n\t\tconst bones = this.bones;\n\t\tconst boneInverses = this.boneInverses;\n\n\t\tthis.boneMatrices = new Float32Array( bones.length * 16 );\n\n\t\t// calculate inverse bone matrices if necessary\n\n\t\tif ( boneInverses.length === 0 ) {\n\n\t\t\tthis.calculateInverses();\n\n\t\t} else {\n\n\t\t\t// handle special case\n\n\t\t\tif ( bones.length !== boneInverses.length ) {\n\n\t\t\t\tconsole.warn( 'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.' );\n\n\t\t\t\tthis.boneInverses = [];\n\n\t\t\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\t\t\tthis.boneInverses.push( new Matrix4() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcalculateInverses() {\n\n\t\tthis.boneInverses.length = 0;\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst inverse = new Matrix4();\n\n\t\t\tif ( this.bones[ i ] ) {\n\n\t\t\t\tinverse.copy( this.bones[ i ].matrixWorld ).invert();\n\n\t\t\t}\n\n\t\t\tthis.boneInverses.push( inverse );\n\n\t\t}\n\n\t}\n\n\tpose() {\n\n\t\t// recover the bind-time world matrices\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst bone = this.bones[ i ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tbone.matrixWorld.copy( this.boneInverses[ i ] ).invert();\n\n\t\t\t}\n\n\t\t}\n\n\t\t// compute the local matrices, positions, rotations and scales\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst bone = this.bones[ i ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\t\tbone.matrix.copy( bone.parent.matrixWorld ).invert();\n\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdate() {\n\n\t\tconst bones = this.bones;\n\t\tconst boneInverses = this.boneInverses;\n\t\tconst boneMatrices = this.boneMatrices;\n\t\tconst boneTexture = this.boneTexture;\n\n\t\t// flatten bone matrices to array\n\n\t\tfor ( let i = 0, il = bones.length; i < il; i ++ ) {\n\n\t\t\t// compute the offset between the current and the original transform\n\n\t\t\tconst matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix;\n\n\t\t\t_offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );\n\t\t\t_offsetMatrix.toArray( boneMatrices, i * 16 );\n\n\t\t}\n\n\t\tif ( boneTexture !== null ) {\n\n\t\t\tboneTexture.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new Skeleton( this.bones, this.boneInverses );\n\n\t}\n\n\tcomputeBoneTexture() {\n\n\t\t// layout (1 matrix = 4 pixels)\n\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\n\t\tlet size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix\n\t\tsize = Math.ceil( size / 4 ) * 4;\n\t\tsize = Math.max( size, 4 );\n\n\t\tconst boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel\n\t\tboneMatrices.set( this.boneMatrices ); // copy current values\n\n\t\tconst boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );\n\t\tboneTexture.needsUpdate = true;\n\n\t\tthis.boneMatrices = boneMatrices;\n\t\tthis.boneTexture = boneTexture;\n\n\t\treturn this;\n\n\t}\n\n\tgetBoneByName( name ) {\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst bone = this.bones[ i ];\n\n\t\t\tif ( bone.name === name ) {\n\n\t\t\t\treturn bone;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn undefined;\n\n\t}\n\n\tdispose( ) {\n\n\t\tif ( this.boneTexture !== null ) {\n\n\t\t\tthis.boneTexture.dispose();\n\n\t\t\tthis.boneTexture = null;\n\n\t\t}\n\n\t}\n\n\tfromJSON( json, bones ) {\n\n\t\tthis.uuid = json.uuid;\n\n\t\tfor ( let i = 0, l = json.bones.length; i < l; i ++ ) {\n\n\t\t\tconst uuid = json.bones[ i ];\n\t\t\tlet bone = bones[ uuid ];\n\n\t\t\tif ( bone === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Skeleton: No bone found with UUID:', uuid );\n\t\t\t\tbone = new Bone();\n\n\t\t\t}\n\n\t\t\tthis.bones.push( bone );\n\t\t\tthis.boneInverses.push( new Matrix4().fromArray( json.boneInverses[ i ] ) );\n\n\t\t}\n\n\t\tthis.init();\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'Skeleton',\n\t\t\t\tgenerator: 'Skeleton.toJSON'\n\t\t\t},\n\t\t\tbones: [],\n\t\t\tboneInverses: []\n\t\t};\n\n\t\tdata.uuid = this.uuid;\n\n\t\tconst bones = this.bones;\n\t\tconst boneInverses = this.boneInverses;\n\n\t\tfor ( let i = 0, l = bones.length; i < l; i ++ ) {\n\n\t\t\tconst bone = bones[ i ];\n\t\t\tdata.bones.push( bone.uuid );\n\n\t\t\tconst boneInverse = boneInverses[ i ];\n\t\t\tdata.boneInverses.push( boneInverse.toArray() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass InstancedBufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized, meshPerAttribute = 1 ) {\n\n\t\tsuper( array, itemSize, normalized );\n\n\t\tthis.isInstancedBufferAttribute = true;\n\n\t\tthis.meshPerAttribute = meshPerAttribute;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.meshPerAttribute = this.meshPerAttribute;\n\n\t\tdata.isInstancedBufferAttribute = true;\n\n\t\treturn data;\n\n\t}\n\n}\n\nconst _instanceLocalMatrix = /*@__PURE__*/ new Matrix4();\nconst _instanceWorldMatrix = /*@__PURE__*/ new Matrix4();\n\nconst _instanceIntersects = [];\n\nconst _box3 = /*@__PURE__*/ new Box3();\nconst _identity = /*@__PURE__*/ new Matrix4();\nconst _mesh$1 = /*@__PURE__*/ new Mesh();\nconst _sphere$4 = /*@__PURE__*/ new Sphere();\n\nclass InstancedMesh extends Mesh {\n\n\tconstructor( geometry, material, count ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isInstancedMesh = true;\n\n\t\tthis.instanceMatrix = new InstancedBufferAttribute( new Float32Array( count * 16 ), 16 );\n\t\tthis.instanceColor = null;\n\t\tthis.morphTexture = null;\n\n\t\tthis.count = count;\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tthis.setMatrixAt( i, _identity );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tconst geometry = this.geometry;\n\t\tconst count = this.count;\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tif ( geometry.boundingBox === null ) {\n\n\t\t\tgeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tthis.boundingBox.makeEmpty();\n\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tthis.getMatrixAt( i, _instanceLocalMatrix );\n\n\t\t\t_box3.copy( geometry.boundingBox ).applyMatrix4( _instanceLocalMatrix );\n\n\t\t\tthis.boundingBox.union( _box3 );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tconst geometry = this.geometry;\n\t\tconst count = this.count;\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tif ( geometry.boundingSphere === null ) {\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t}\n\n\t\tthis.boundingSphere.makeEmpty();\n\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tthis.getMatrixAt( i, _instanceLocalMatrix );\n\n\t\t\t_sphere$4.copy( geometry.boundingSphere ).applyMatrix4( _instanceLocalMatrix );\n\n\t\t\tthis.boundingSphere.union( _sphere$4 );\n\n\t\t}\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.instanceMatrix.copy( source.instanceMatrix );\n\n\t\tif ( source.morphTexture !== null ) this.morphTexture = source.morphTexture.clone();\n\t\tif ( source.instanceColor !== null ) this.instanceColor = source.instanceColor.clone();\n\n\t\tthis.count = source.count;\n\n\t\tif ( source.boundingBox !== null ) this.boundingBox = source.boundingBox.clone();\n\t\tif ( source.boundingSphere !== null ) this.boundingSphere = source.boundingSphere.clone();\n\n\t\treturn this;\n\n\t}\n\n\tgetColorAt( index, color ) {\n\n\t\tcolor.fromArray( this.instanceColor.array, index * 3 );\n\n\t}\n\n\tgetMatrixAt( index, matrix ) {\n\n\t\tmatrix.fromArray( this.instanceMatrix.array, index * 16 );\n\n\t}\n\n\tgetMorphAt( index, object ) {\n\n\t\tconst objectInfluences = object.morphTargetInfluences;\n\n\t\tconst array = this.morphTexture.source.data.data;\n\n\t\tconst len = objectInfluences.length + 1; // All influences + the baseInfluenceSum\n\n\t\tconst dataIndex = index * len + 1; // Skip the baseInfluenceSum at the beginning\n\n\t\tfor ( let i = 0; i < objectInfluences.length; i ++ ) {\n\n\t\t\tobjectInfluences[ i ] = array[ dataIndex + i ];\n\n\t\t}\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst raycastTimes = this.count;\n\n\t\t_mesh$1.geometry = this.geometry;\n\t\t_mesh$1.material = this.material;\n\n\t\tif ( _mesh$1.material === undefined ) return;\n\n\t\t// test with bounding sphere first\n\n\t\tif ( this.boundingSphere === null ) this.computeBoundingSphere();\n\n\t\t_sphere$4.copy( this.boundingSphere );\n\t\t_sphere$4.applyMatrix4( matrixWorld );\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere$4 ) === false ) return;\n\n\t\t// now test each instance\n\n\t\tfor ( let instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {\n\n\t\t\t// calculate the world matrix for each instance\n\n\t\t\tthis.getMatrixAt( instanceId, _instanceLocalMatrix );\n\n\t\t\t_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );\n\n\t\t\t// the mesh represents this single instance\n\n\t\t\t_mesh$1.matrixWorld = _instanceWorldMatrix;\n\n\t\t\t_mesh$1.raycast( raycaster, _instanceIntersects );\n\n\t\t\t// process the result of raycast\n\n\t\t\tfor ( let i = 0, l = _instanceIntersects.length; i < l; i ++ ) {\n\n\t\t\t\tconst intersect = _instanceIntersects[ i ];\n\t\t\t\tintersect.instanceId = instanceId;\n\t\t\t\tintersect.object = this;\n\t\t\t\tintersects.push( intersect );\n\n\t\t\t}\n\n\t\t\t_instanceIntersects.length = 0;\n\n\t\t}\n\n\t}\n\n\tsetColorAt( index, color ) {\n\n\t\tif ( this.instanceColor === null ) {\n\n\t\t\tthis.instanceColor = new InstancedBufferAttribute( new Float32Array( this.instanceMatrix.count * 3 ).fill( 1 ), 3 );\n\n\t\t}\n\n\t\tcolor.toArray( this.instanceColor.array, index * 3 );\n\n\t}\n\n\tsetMatrixAt( index, matrix ) {\n\n\t\tmatrix.toArray( this.instanceMatrix.array, index * 16 );\n\n\t}\n\n\tsetMorphAt( index, object ) {\n\n\t\tconst objectInfluences = object.morphTargetInfluences;\n\n\t\tconst len = objectInfluences.length + 1; // morphBaseInfluence + all influences\n\n\t\tif ( this.morphTexture === null ) {\n\n\t\t\tthis.morphTexture = new DataTexture( new Float32Array( len * this.count ), len, this.count, RedFormat, FloatType );\n\n\t\t}\n\n\t\tconst array = this.morphTexture.source.data.data;\n\n\t\tlet morphInfluencesSum = 0;\n\n\t\tfor ( let i = 0; i < objectInfluences.length; i ++ ) {\n\n\t\t\tmorphInfluencesSum += objectInfluences[ i ];\n\n\t\t}\n\n\t\tconst morphBaseInfluence = this.geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n\n\t\tconst dataIndex = len * index;\n\n\t\tarray[ dataIndex ] = morphBaseInfluence;\n\n\t\tarray.set( objectInfluences, dataIndex + 1 );\n\n\t}\n\n\tupdateMorphTargets() {\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\tif ( this.morphTexture !== null ) {\n\n\t\t\tthis.morphTexture.dispose();\n\t\t\tthis.morphTexture = null;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _vector1 = /*@__PURE__*/ new Vector3();\nconst _vector2 = /*@__PURE__*/ new Vector3();\nconst _normalMatrix = /*@__PURE__*/ new Matrix3();\n\nclass Plane {\n\n\tconstructor( normal = new Vector3( 1, 0, 0 ), constant = 0 ) {\n\n\t\tthis.isPlane = true;\n\n\t\t// normal is assumed to be normalized\n\n\t\tthis.normal = normal;\n\t\tthis.constant = constant;\n\n\t}\n\n\tset( normal, constant ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = constant;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponents( x, y, z, w ) {\n\n\t\tthis.normal.set( x, y, z );\n\t\tthis.constant = w;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromNormalAndCoplanarPoint( normal, point ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = - point.dot( this.normal );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCoplanarPoints( a, b, c ) {\n\n\t\tconst normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();\n\n\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( plane ) {\n\n\t\tthis.normal.copy( plane.normal );\n\t\tthis.constant = plane.constant;\n\n\t\treturn this;\n\n\t}\n\n\tnormalize() {\n\n\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\n\t\tconst inverseNormalLength = 1.0 / this.normal.length();\n\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\tthis.constant *= inverseNormalLength;\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.constant *= - 1;\n\t\tthis.normal.negate();\n\n\t\treturn this;\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn this.normal.dot( point ) + this.constant;\n\n\t}\n\n\tdistanceToSphere( sphere ) {\n\n\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\n\t}\n\n\tprojectPoint( point, target ) {\n\n\t\treturn target.copy( point ).addScaledVector( this.normal, - this.distanceToPoint( point ) );\n\n\t}\n\n\tintersectLine( line, target ) {\n\n\t\tconst direction = line.delta( _vector1 );\n\n\t\tconst denominator = this.normal.dot( direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\n\n\t\t\t\treturn target.copy( line.start );\n\n\t\t\t}\n\n\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\n\t\tif ( t < 0 || t > 1 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn target.copy( line.start ).addScaledVector( direction, t );\n\n\t}\n\n\tintersectsLine( line ) {\n\n\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n\t\tconst startSign = this.distanceToPoint( line.start );\n\t\tconst endSign = this.distanceToPoint( line.end );\n\n\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn box.intersectsPlane( this );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn sphere.intersectsPlane( this );\n\n\t}\n\n\tcoplanarPoint( target ) {\n\n\t\treturn target.copy( this.normal ).multiplyScalar( - this.constant );\n\n\t}\n\n\tapplyMatrix4( matrix, optionalNormalMatrix ) {\n\n\t\tconst normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );\n\n\t\tconst referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );\n\n\t\tconst normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\tthis.constant = - referencePoint.dot( normal );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.constant -= offset.dot( this.normal );\n\n\t\treturn this;\n\n\t}\n\n\tequals( plane ) {\n\n\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nconst _sphere$3 = /*@__PURE__*/ new Sphere();\nconst _vector$6 = /*@__PURE__*/ new Vector3();\n\nclass Frustum {\n\n\tconstructor( p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane() ) {\n\n\t\tthis.planes = [ p0, p1, p2, p3, p4, p5 ];\n\n\t}\n\n\tset( p0, p1, p2, p3, p4, p5 ) {\n\n\t\tconst planes = this.planes;\n\n\t\tplanes[ 0 ].copy( p0 );\n\t\tplanes[ 1 ].copy( p1 );\n\t\tplanes[ 2 ].copy( p2 );\n\t\tplanes[ 3 ].copy( p3 );\n\t\tplanes[ 4 ].copy( p4 );\n\t\tplanes[ 5 ].copy( p5 );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( frustum ) {\n\n\t\tconst planes = this.planes;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromProjectionMatrix( m, coordinateSystem = WebGLCoordinateSystem ) {\n\n\t\tconst planes = this.planes;\n\t\tconst me = m.elements;\n\t\tconst me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\n\t\tconst me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\n\t\tconst me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\n\t\tconst me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\n\n\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\n\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\n\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\n\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\n\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\n\n\t\tif ( coordinateSystem === WebGLCoordinateSystem ) {\n\n\t\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\n\n\t\t} else if ( coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\tplanes[ 5 ].setComponents( me2, me6, me10, me14 ).normalize();\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' + coordinateSystem );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tintersectsObject( object ) {\n\n\t\tif ( object.boundingSphere !== undefined ) {\n\n\t\t\tif ( object.boundingSphere === null ) object.computeBoundingSphere();\n\n\t\t\t_sphere$3.copy( object.boundingSphere ).applyMatrix4( object.matrixWorld );\n\n\t\t} else {\n\n\t\t\tconst geometry = object.geometry;\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\t_sphere$3.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );\n\n\t\t}\n\n\t\treturn this.intersectsSphere( _sphere$3 );\n\n\t}\n\n\tintersectsSprite( sprite ) {\n\n\t\t_sphere$3.center.set( 0, 0, 0 );\n\t\t_sphere$3.radius = 0.7071067811865476;\n\t\t_sphere$3.applyMatrix4( sprite.matrixWorld );\n\n\t\treturn this.intersectsSphere( _sphere$3 );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\tconst planes = this.planes;\n\t\tconst center = sphere.center;\n\t\tconst negRadius = - sphere.radius;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst distance = planes[ i ].distanceToPoint( center );\n\n\t\t\tif ( distance < negRadius ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\tconst planes = this.planes;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst plane = planes[ i ];\n\n\t\t\t// corner at max distance\n\n\t\t\t_vector$6.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n\t\t\t_vector$6.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n\t\t\t_vector$6.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\n\t\t\tif ( plane.distanceToPoint( _vector$6 ) < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\tconst planes = this.planes;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nfunction ascIdSort( a, b ) {\n\n\treturn a - b;\n\n}\n\nfunction sortOpaque( a, b ) {\n\n\treturn a.z - b.z;\n\n}\n\nfunction sortTransparent( a, b ) {\n\n\treturn b.z - a.z;\n\n}\n\nclass MultiDrawRenderList {\n\n\tconstructor() {\n\n\t\tthis.index = 0;\n\t\tthis.pool = [];\n\t\tthis.list = [];\n\n\t}\n\n\tpush( start, count, z, index ) {\n\n\t\tconst pool = this.pool;\n\t\tconst list = this.list;\n\t\tif ( this.index >= pool.length ) {\n\n\t\t\tpool.push( {\n\n\t\t\t\tstart: - 1,\n\t\t\t\tcount: - 1,\n\t\t\t\tz: - 1,\n\t\t\t\tindex: - 1,\n\n\t\t\t} );\n\n\t\t}\n\n\t\tconst item = pool[ this.index ];\n\t\tlist.push( item );\n\t\tthis.index ++;\n\n\t\titem.start = start;\n\t\titem.count = count;\n\t\titem.z = z;\n\t\titem.index = index;\n\n\t}\n\n\treset() {\n\n\t\tthis.list.length = 0;\n\t\tthis.index = 0;\n\n\t}\n\n}\n\nconst _matrix$1 = /*@__PURE__*/ new Matrix4();\nconst _whiteColor = /*@__PURE__*/ new Color( 1, 1, 1 );\nconst _frustum = /*@__PURE__*/ new Frustum();\nconst _box$1 = /*@__PURE__*/ new Box3();\nconst _sphere$2 = /*@__PURE__*/ new Sphere();\nconst _vector$5 = /*@__PURE__*/ new Vector3();\nconst _forward = /*@__PURE__*/ new Vector3();\nconst _temp = /*@__PURE__*/ new Vector3();\nconst _renderList = /*@__PURE__*/ new MultiDrawRenderList();\nconst _mesh = /*@__PURE__*/ new Mesh();\nconst _batchIntersects = [];\n\n// copies data from attribute \"src\" into \"target\" starting at \"targetOffset\"\nfunction copyAttributeData( src, target, targetOffset = 0 ) {\n\n\tconst itemSize = target.itemSize;\n\tif ( src.isInterleavedBufferAttribute || src.array.constructor !== target.array.constructor ) {\n\n\t\t// use the component getters and setters if the array data cannot\n\t\t// be copied directly\n\t\tconst vertexCount = src.count;\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tfor ( let c = 0; c < itemSize; c ++ ) {\n\n\t\t\t\ttarget.setComponent( i + targetOffset, c, src.getComponent( i, c ) );\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// faster copy approach using typed array set function\n\t\ttarget.array.set( src.array, targetOffset * itemSize );\n\n\t}\n\n\ttarget.needsUpdate = true;\n\n}\n\n// safely copies array contents to a potentially smaller array\nfunction copyArrayContents( src, target ) {\n\n\tif ( src.constructor !== target.constructor ) {\n\n\t\t// if arrays are of a different type (eg due to index size increasing) then data must be per-element copied\n\t\tconst len = Math.min( src.length, target.length );\n\t\tfor ( let i = 0; i < len; i ++ ) {\n\n\t\t\ttarget[ i ] = src[ i ];\n\n\t\t}\n\n\t} else {\n\n\t\t// if the arrays use the same data layout we can use a fast block copy\n\t\tconst len = Math.min( src.length, target.length );\n\t\ttarget.set( new src.constructor( src.buffer, 0, len ) );\n\n\t}\n\n}\n\nclass BatchedMesh extends Mesh {\n\n\tget maxInstanceCount() {\n\n\t\treturn this._maxInstanceCount;\n\n\t}\n\n\tget instanceCount() {\n\n\t\treturn this._instanceInfo.length - this._availableInstanceIds.length;\n\n\t}\n\n\tget unusedVertexCount() {\n\n\t\treturn this._maxVertexCount - this._nextVertexStart;\n\n\t}\n\n\tget unusedIndexCount() {\n\n\t\treturn this._maxIndexCount - this._nextIndexStart;\n\n\t}\n\n\tconstructor( maxInstanceCount, maxVertexCount, maxIndexCount = maxVertexCount * 2, material ) {\n\n\t\tsuper( new BufferGeometry(), material );\n\n\t\tthis.isBatchedMesh = true;\n\t\tthis.perObjectFrustumCulled = true;\n\t\tthis.sortObjects = true;\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\t\tthis.customSort = null;\n\n\t\t// stores visible, active, and geometry id per instance and reserved buffer ranges for geometries\n\t\tthis._instanceInfo = [];\n\t\tthis._geometryInfo = [];\n\n\t\t// instance, geometry ids that have been set as inactive, and are available to be overwritten\n\t\tthis._availableInstanceIds = [];\n\t\tthis._availableGeometryIds = [];\n\n\t\t// used to track where the next point is that geometry should be inserted\n\t\tthis._nextIndexStart = 0;\n\t\tthis._nextVertexStart = 0;\n\t\tthis._geometryCount = 0;\n\n\t\t// flags\n\t\tthis._visibilityChanged = true;\n\t\tthis._geometryInitialized = false;\n\n\t\t// cached user options\n\t\tthis._maxInstanceCount = maxInstanceCount;\n\t\tthis._maxVertexCount = maxVertexCount;\n\t\tthis._maxIndexCount = maxIndexCount;\n\n\t\t// buffers for multi draw\n\t\tthis._multiDrawCounts = new Int32Array( maxInstanceCount );\n\t\tthis._multiDrawStarts = new Int32Array( maxInstanceCount );\n\t\tthis._multiDrawCount = 0;\n\t\tthis._multiDrawInstances = null;\n\n\t\t// Local matrix per geometry by using data texture\n\t\tthis._matricesTexture = null;\n\t\tthis._indirectTexture = null;\n\t\tthis._colorsTexture = null;\n\n\t\tthis._initMatricesTexture();\n\t\tthis._initIndirectTexture();\n\n\t}\n\n\t_initMatricesTexture() {\n\n\t\t// layout (1 matrix = 4 pixels)\n\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t//  with  8x8  pixel texture max   16 matrices * 4 pixels =  (8 * 8)\n\t\t//       16x16 pixel texture max   64 matrices * 4 pixels = (16 * 16)\n\t\t//       32x32 pixel texture max  256 matrices * 4 pixels = (32 * 32)\n\t\t//       64x64 pixel texture max 1024 matrices * 4 pixels = (64 * 64)\n\n\t\tlet size = Math.sqrt( this._maxInstanceCount * 4 ); // 4 pixels needed for 1 matrix\n\t\tsize = Math.ceil( size / 4 ) * 4;\n\t\tsize = Math.max( size, 4 );\n\n\t\tconst matricesArray = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel\n\t\tconst matricesTexture = new DataTexture( matricesArray, size, size, RGBAFormat, FloatType );\n\n\t\tthis._matricesTexture = matricesTexture;\n\n\t}\n\n\t_initIndirectTexture() {\n\n\t\tlet size = Math.sqrt( this._maxInstanceCount );\n\t\tsize = Math.ceil( size );\n\n\t\tconst indirectArray = new Uint32Array( size * size );\n\t\tconst indirectTexture = new DataTexture( indirectArray, size, size, RedIntegerFormat, UnsignedIntType );\n\n\t\tthis._indirectTexture = indirectTexture;\n\n\t}\n\n\t_initColorsTexture() {\n\n\t\tlet size = Math.sqrt( this._maxInstanceCount );\n\t\tsize = Math.ceil( size );\n\n\t\t// 4 floats per RGBA pixel initialized to white\n\t\tconst colorsArray = new Float32Array( size * size * 4 ).fill( 1 );\n\t\tconst colorsTexture = new DataTexture( colorsArray, size, size, RGBAFormat, FloatType );\n\t\tcolorsTexture.colorSpace = ColorManagement.workingColorSpace;\n\n\t\tthis._colorsTexture = colorsTexture;\n\n\t}\n\n\t_initializeGeometry( reference ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst maxVertexCount = this._maxVertexCount;\n\t\tconst maxIndexCount = this._maxIndexCount;\n\t\tif ( this._geometryInitialized === false ) {\n\n\t\t\tfor ( const attributeName in reference.attributes ) {\n\n\t\t\t\tconst srcAttribute = reference.getAttribute( attributeName );\n\t\t\t\tconst { array, itemSize, normalized } = srcAttribute;\n\n\t\t\t\tconst dstArray = new array.constructor( maxVertexCount * itemSize );\n\t\t\t\tconst dstAttribute = new BufferAttribute( dstArray, itemSize, normalized );\n\n\t\t\t\tgeometry.setAttribute( attributeName, dstAttribute );\n\n\t\t\t}\n\n\t\t\tif ( reference.getIndex() !== null ) {\n\n\t\t\t\t// Reserve last u16 index for primitive restart.\n\t\t\t\tconst indexArray = maxVertexCount > 65535\n\t\t\t\t\t? new Uint32Array( maxIndexCount )\n\t\t\t\t\t: new Uint16Array( maxIndexCount );\n\n\t\t\t\tgeometry.setIndex( new BufferAttribute( indexArray, 1 ) );\n\n\t\t\t}\n\n\t\t\tthis._geometryInitialized = true;\n\n\t\t}\n\n\t}\n\n\t// Make sure the geometry is compatible with the existing combined geometry attributes\n\t_validateGeometry( geometry ) {\n\n\t\t// check to ensure the geometries are using consistent attributes and indices\n\t\tconst batchGeometry = this.geometry;\n\t\tif ( Boolean( geometry.getIndex() ) !== Boolean( batchGeometry.getIndex() ) ) {\n\n\t\t\tthrow new Error( 'THREE.BatchedMesh: All geometries must consistently have \"index\".' );\n\n\t\t}\n\n\t\tfor ( const attributeName in batchGeometry.attributes ) {\n\n\t\t\tif ( ! geometry.hasAttribute( attributeName ) ) {\n\n\t\t\t\tthrow new Error( `THREE.BatchedMesh: Added geometry missing \"${ attributeName }\". All geometries must have consistent attributes.` );\n\n\t\t\t}\n\n\t\t\tconst srcAttribute = geometry.getAttribute( attributeName );\n\t\t\tconst dstAttribute = batchGeometry.getAttribute( attributeName );\n\t\t\tif ( srcAttribute.itemSize !== dstAttribute.itemSize || srcAttribute.normalized !== dstAttribute.normalized ) {\n\n\t\t\t\tthrow new Error( 'THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.' );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tvalidateInstanceId( instanceId ) {\n\n\t\tconst instanceInfo = this._instanceInfo;\n\t\tif ( instanceId < 0 || instanceId >= instanceInfo.length || instanceInfo[ instanceId ].active === false ) {\n\n\t\t\tthrow new Error( `THREE.BatchedMesh: Invalid instanceId ${instanceId}. Instance is either out of range or has been deleted.` );\n\n\t\t}\n\n\t}\n\n\tvalidateGeometryId( geometryId ) {\n\n\t\tconst geometryInfoList = this._geometryInfo;\n\t\tif ( geometryId < 0 || geometryId >= geometryInfoList.length || geometryInfoList[ geometryId ].active === false ) {\n\n\t\t\tthrow new Error( `THREE.BatchedMesh: Invalid geometryId ${geometryId}. Geometry is either out of range or has been deleted.` );\n\n\t\t}\n\n\t}\n\n\n\tsetCustomSort( func ) {\n\n\t\tthis.customSort = func;\n\t\treturn this;\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst boundingBox = this.boundingBox;\n\t\tconst instanceInfo = this._instanceInfo;\n\n\t\tboundingBox.makeEmpty();\n\t\tfor ( let i = 0, l = instanceInfo.length; i < l; i ++ ) {\n\n\t\t\tif ( instanceInfo[ i ].active === false ) continue;\n\n\t\t\tconst geometryId = instanceInfo[ i ].geometryIndex;\n\t\t\tthis.getMatrixAt( i, _matrix$1 );\n\t\t\tthis.getBoundingBoxAt( geometryId, _box$1 ).applyMatrix4( _matrix$1 );\n\t\t\tboundingBox.union( _box$1 );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tconst boundingSphere = this.boundingSphere;\n\t\tconst instanceInfo = this._instanceInfo;\n\n\t\tboundingSphere.makeEmpty();\n\t\tfor ( let i = 0, l = instanceInfo.length; i < l; i ++ ) {\n\n\t\t\tif ( instanceInfo[ i ].active === false ) continue;\n\n\t\t\tconst geometryId = instanceInfo[ i ].geometryIndex;\n\t\t\tthis.getMatrixAt( i, _matrix$1 );\n\t\t\tthis.getBoundingSphereAt( geometryId, _sphere$2 ).applyMatrix4( _matrix$1 );\n\t\t\tboundingSphere.union( _sphere$2 );\n\n\t\t}\n\n\t}\n\n\taddInstance( geometryId ) {\n\n\t\tconst atCapacity = this._instanceInfo.length >= this.maxInstanceCount;\n\n\t\t// ensure we're not over geometry\n\t\tif ( atCapacity && this._availableInstanceIds.length === 0 ) {\n\n\t\t\tthrow new Error( 'THREE.BatchedMesh: Maximum item count reached.' );\n\n\t\t}\n\n\t\tconst instanceInfo = {\n\t\t\tvisible: true,\n\t\t\tactive: true,\n\t\t\tgeometryIndex: geometryId,\n\t\t};\n\n\t\tlet drawId = null;\n\n\t\t// Prioritize using previously freed instance ids\n\t\tif ( this._availableInstanceIds.length > 0 ) {\n\n\t\t\tthis._availableInstanceIds.sort( ascIdSort );\n\n\t\t\tdrawId = this._availableInstanceIds.shift();\n\t\t\tthis._instanceInfo[ drawId ] = instanceInfo;\n\n\t\t} else {\n\n\t\t\tdrawId = this._instanceInfo.length;\n\t\t\tthis._instanceInfo.push( instanceInfo );\n\n\t\t}\n\n\t\tconst matricesTexture = this._matricesTexture;\n\t\t_matrix$1.identity().toArray( matricesTexture.image.data, drawId * 16 );\n\t\tmatricesTexture.needsUpdate = true;\n\n\t\tconst colorsTexture = this._colorsTexture;\n\t\tif ( colorsTexture ) {\n\n\t\t\t_whiteColor.toArray( colorsTexture.image.data, drawId * 4 );\n\t\t\tcolorsTexture.needsUpdate = true;\n\n\t\t}\n\n\t\tthis._visibilityChanged = true;\n\t\treturn drawId;\n\n\t}\n\n\taddGeometry( geometry, reservedVertexCount = - 1, reservedIndexCount = - 1 ) {\n\n\t\tthis._initializeGeometry( geometry );\n\n\t\tthis._validateGeometry( geometry );\n\n\t\tconst geometryInfo = {\n\t\t\t// geometry information\n\t\t\tvertexStart: - 1,\n\t\t\tvertexCount: - 1,\n\t\t\treservedVertexCount: - 1,\n\n\t\t\tindexStart: - 1,\n\t\t\tindexCount: - 1,\n\t\t\treservedIndexCount: - 1,\n\n\t\t\t// draw range information\n\t\t\tstart: - 1,\n\t\t\tcount: - 1,\n\n\t\t\t// state\n\t\t\tboundingBox: null,\n\t\t\tboundingSphere: null,\n\t\t\tactive: true,\n\t\t};\n\n\t\tconst geometryInfoList = this._geometryInfo;\n\t\tgeometryInfo.vertexStart = this._nextVertexStart;\n\t\tgeometryInfo.reservedVertexCount = reservedVertexCount === - 1 ? geometry.getAttribute( 'position' ).count : reservedVertexCount;\n\n\t\tconst index = geometry.getIndex();\n\t\tconst hasIndex = index !== null;\n\t\tif ( hasIndex ) {\n\n\t\t\tgeometryInfo.indexStart = this._nextIndexStart;\n\t\t\tgeometryInfo.reservedIndexCount = reservedIndexCount === - 1 ? index.count : reservedIndexCount;\n\n\t\t}\n\n\t\tif (\n\t\t\tgeometryInfo.indexStart !== - 1 &&\n\t\t\tgeometryInfo.indexStart + geometryInfo.reservedIndexCount > this._maxIndexCount ||\n\t\t\tgeometryInfo.vertexStart + geometryInfo.reservedVertexCount > this._maxVertexCount\n\t\t) {\n\n\t\t\tthrow new Error( 'THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.' );\n\n\t\t}\n\n\t\t// update id\n\t\tlet geometryId;\n\t\tif ( this._availableGeometryIds.length > 0 ) {\n\n\t\t\tthis._availableGeometryIds.sort( ascIdSort );\n\n\t\t\tgeometryId = this._availableGeometryIds.shift();\n\t\t\tgeometryInfoList[ geometryId ] = geometryInfo;\n\n\n\t\t} else {\n\n\t\t\tgeometryId = this._geometryCount;\n\t\t\tthis._geometryCount ++;\n\t\t\tgeometryInfoList.push( geometryInfo );\n\n\t\t}\n\n\t\t// update the geometry\n\t\tthis.setGeometryAt( geometryId, geometry );\n\n\t\t// increment the next geometry position\n\t\tthis._nextIndexStart = geometryInfo.indexStart + geometryInfo.reservedIndexCount;\n\t\tthis._nextVertexStart = geometryInfo.vertexStart + geometryInfo.reservedVertexCount;\n\n\t\treturn geometryId;\n\n\t}\n\n\tsetGeometryAt( geometryId, geometry ) {\n\n\t\tif ( geometryId >= this._geometryCount ) {\n\n\t\t\tthrow new Error( 'THREE.BatchedMesh: Maximum geometry count reached.' );\n\n\t\t}\n\n\t\tthis._validateGeometry( geometry );\n\n\t\tconst batchGeometry = this.geometry;\n\t\tconst hasIndex = batchGeometry.getIndex() !== null;\n\t\tconst dstIndex = batchGeometry.getIndex();\n\t\tconst srcIndex = geometry.getIndex();\n\t\tconst geometryInfo = this._geometryInfo[ geometryId ];\n\t\tif (\n\t\t\thasIndex &&\n\t\t\tsrcIndex.count > geometryInfo.reservedIndexCount ||\n\t\t\tgeometry.attributes.position.count > geometryInfo.reservedVertexCount\n\t\t) {\n\n\t\t\tthrow new Error( 'THREE.BatchedMesh: Reserved space not large enough for provided geometry.' );\n\n\t\t}\n\n\t\t// copy geometry buffer data over\n\t\tconst vertexStart = geometryInfo.vertexStart;\n\t\tconst reservedVertexCount = geometryInfo.reservedVertexCount;\n\t\tgeometryInfo.vertexCount = geometry.getAttribute( 'position' ).count;\n\n\t\tfor ( const attributeName in batchGeometry.attributes ) {\n\n\t\t\t// copy attribute data\n\t\t\tconst srcAttribute = geometry.getAttribute( attributeName );\n\t\t\tconst dstAttribute = batchGeometry.getAttribute( attributeName );\n\t\t\tcopyAttributeData( srcAttribute, dstAttribute, vertexStart );\n\n\t\t\t// fill the rest in with zeroes\n\t\t\tconst itemSize = srcAttribute.itemSize;\n\t\t\tfor ( let i = srcAttribute.count, l = reservedVertexCount; i < l; i ++ ) {\n\n\t\t\t\tconst index = vertexStart + i;\n\t\t\t\tfor ( let c = 0; c < itemSize; c ++ ) {\n\n\t\t\t\t\tdstAttribute.setComponent( index, c, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdstAttribute.needsUpdate = true;\n\t\t\tdstAttribute.addUpdateRange( vertexStart * itemSize, reservedVertexCount * itemSize );\n\n\t\t}\n\n\t\t// copy index\n\t\tif ( hasIndex ) {\n\n\t\t\tconst indexStart = geometryInfo.indexStart;\n\t\t\tconst reservedIndexCount = geometryInfo.reservedIndexCount;\n\t\t\tgeometryInfo.indexCount = geometry.getIndex().count;\n\n\t\t\t// copy index data over\n\t\t\tfor ( let i = 0; i < srcIndex.count; i ++ ) {\n\n\t\t\t\tdstIndex.setX( indexStart + i, vertexStart + srcIndex.getX( i ) );\n\n\t\t\t}\n\n\t\t\t// fill the rest in with zeroes\n\t\t\tfor ( let i = srcIndex.count, l = reservedIndexCount; i < l; i ++ ) {\n\n\t\t\t\tdstIndex.setX( indexStart + i, vertexStart );\n\n\t\t\t}\n\n\t\t\tdstIndex.needsUpdate = true;\n\t\t\tdstIndex.addUpdateRange( indexStart, geometryInfo.reservedIndexCount );\n\n\t\t}\n\n\t\t// update the draw range\n\t\tgeometryInfo.start = hasIndex ? geometryInfo.indexStart : geometryInfo.vertexStart;\n\t\tgeometryInfo.count = hasIndex ? geometryInfo.indexCount : geometryInfo.vertexCount;\n\n\t\t// store the bounding boxes\n\t\tgeometryInfo.boundingBox = null;\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tgeometryInfo.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t\tgeometryInfo.boundingSphere = null;\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tgeometryInfo.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\tthis._visibilityChanged = true;\n\t\treturn geometryId;\n\n\t}\n\n\tdeleteGeometry( geometryId ) {\n\n\t\tconst geometryInfoList = this._geometryInfo;\n\t\tif ( geometryId >= geometryInfoList.length || geometryInfoList[ geometryId ].active === false ) {\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t// delete any instances associated with this geometry\n\t\tconst instanceInfo = this._instanceInfo;\n\t\tfor ( let i = 0, l = instanceInfo.length; i < l; i ++ ) {\n\n\t\t\tif ( instanceInfo[ i ].geometryIndex === geometryId ) {\n\n\t\t\t\tthis.deleteInstance( i );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometryInfoList[ geometryId ].active = false;\n\t\tthis._availableGeometryIds.push( geometryId );\n\t\tthis._visibilityChanged = true;\n\n\t\treturn this;\n\n\t}\n\n\tdeleteInstance( instanceId ) {\n\n\t\tthis.validateInstanceId( instanceId );\n\n\t\tthis._instanceInfo[ instanceId ].active = false;\n\t\tthis._availableInstanceIds.push( instanceId );\n\t\tthis._visibilityChanged = true;\n\n\t\treturn this;\n\n\t}\n\n\toptimize() {\n\n\t\t// track the next indices to copy data to\n\t\tlet nextVertexStart = 0;\n\t\tlet nextIndexStart = 0;\n\n\t\t// Iterate over all geometry ranges in order sorted from earliest in the geometry buffer to latest\n\t\t// in the geometry buffer. Because draw range objects can be reused there is no guarantee of their order.\n\t\tconst geometryInfoList = this._geometryInfo;\n\t\tconst indices = geometryInfoList\n\t\t\t.map( ( e, i ) => i )\n\t\t\t.sort( ( a, b ) => {\n\n\t\t\t\treturn geometryInfoList[ a ].vertexStart - geometryInfoList[ b ].vertexStart;\n\n\t\t\t} );\n\n\t\tconst geometry = this.geometry;\n\t\tfor ( let i = 0, l = geometryInfoList.length; i < l; i ++ ) {\n\n\t\t\t// if a geometry range is inactive then don't copy anything\n\t\t\tconst index = indices[ i ];\n\t\t\tconst geometryInfo = geometryInfoList[ index ];\n\t\t\tif ( geometryInfo.active === false ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// if a geometry contains an index buffer then shift it, as well\n\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\tif ( geometryInfo.indexStart !== nextIndexStart ) {\n\n\t\t\t\t\tconst { indexStart, vertexStart, reservedIndexCount } = geometryInfo;\n\t\t\t\t\tconst index = geometry.index;\n\t\t\t\t\tconst array = index.array;\n\n\t\t\t\t\t// shift the index pointers based on how the vertex data will shift\n\t\t\t\t\t// adjusting the index must happen first so the original vertex start value is available\n\t\t\t\t\tconst elementDelta = nextVertexStart - vertexStart;\n\t\t\t\t\tfor ( let j = indexStart; j < indexStart + reservedIndexCount; j ++ ) {\n\n\t\t\t\t\t\tarray[ j ] = array[ j ] + elementDelta;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tindex.array.copyWithin( nextIndexStart, indexStart, indexStart + reservedIndexCount );\n\t\t\t\t\tindex.addUpdateRange( nextIndexStart, reservedIndexCount );\n\n\t\t\t\t\tgeometryInfo.indexStart = nextIndexStart;\n\n\t\t\t\t}\n\n\t\t\t\tnextIndexStart += geometryInfo.reservedIndexCount;\n\n\t\t\t}\n\n\t\t\t// if a geometry needs to be moved then copy attribute data to overwrite unused space\n\t\t\tif ( geometryInfo.vertexStart !== nextVertexStart ) {\n\n\t\t\t\tconst { vertexStart, reservedVertexCount } = geometryInfo;\n\t\t\t\tconst attributes = geometry.attributes;\n\t\t\t\tfor ( const key in attributes ) {\n\n\t\t\t\t\tconst attribute = attributes[ key ];\n\t\t\t\t\tconst { array, itemSize } = attribute;\n\t\t\t\t\tarray.copyWithin( nextVertexStart * itemSize, vertexStart * itemSize, ( vertexStart + reservedVertexCount ) * itemSize );\n\t\t\t\t\tattribute.addUpdateRange( nextVertexStart * itemSize, reservedVertexCount * itemSize );\n\n\t\t\t\t}\n\n\t\t\t\tgeometryInfo.vertexStart = nextVertexStart;\n\n\t\t\t}\n\n\t\t\tnextVertexStart += geometryInfo.reservedVertexCount;\n\t\t\tgeometryInfo.start = geometry.index ? geometryInfo.indexStart : geometryInfo.vertexStart;\n\n\t\t\t// step the next geometry points to the shifted position\n\t\t\tthis._nextIndexStart = geometry.index ? geometryInfo.indexStart + geometryInfo.reservedIndexCount : 0;\n\t\t\tthis._nextVertexStart = geometryInfo.vertexStart + geometryInfo.reservedVertexCount;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// get bounding box and compute it if it doesn't exist\n\tgetBoundingBoxAt( geometryId, target ) {\n\n\t\tif ( geometryId >= this._geometryCount ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// compute bounding box\n\t\tconst geometry = this.geometry;\n\t\tconst geometryInfo = this._geometryInfo[ geometryId ];\n\t\tif ( geometryInfo.boundingBox === null ) {\n\n\t\t\tconst box = new Box3();\n\t\t\tconst index = geometry.index;\n\t\t\tconst position = geometry.attributes.position;\n\t\t\tfor ( let i = geometryInfo.start, l = geometryInfo.start + geometryInfo.count; i < l; i ++ ) {\n\n\t\t\t\tlet iv = i;\n\t\t\t\tif ( index ) {\n\n\t\t\t\t\tiv = index.getX( iv );\n\n\t\t\t\t}\n\n\t\t\t\tbox.expandByPoint( _vector$5.fromBufferAttribute( position, iv ) );\n\n\t\t\t}\n\n\t\t\tgeometryInfo.boundingBox = box;\n\n\t\t}\n\n\t\ttarget.copy( geometryInfo.boundingBox );\n\t\treturn target;\n\n\t}\n\n\t// get bounding sphere and compute it if it doesn't exist\n\tgetBoundingSphereAt( geometryId, target ) {\n\n\t\tif ( geometryId >= this._geometryCount ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// compute bounding sphere\n\t\tconst geometry = this.geometry;\n\t\tconst geometryInfo = this._geometryInfo[ geometryId ];\n\t\tif ( geometryInfo.boundingSphere === null ) {\n\n\t\t\tconst sphere = new Sphere();\n\t\t\tthis.getBoundingBoxAt( geometryId, _box$1 );\n\t\t\t_box$1.getCenter( sphere.center );\n\n\t\t\tconst index = geometry.index;\n\t\t\tconst position = geometry.attributes.position;\n\n\t\t\tlet maxRadiusSq = 0;\n\t\t\tfor ( let i = geometryInfo.start, l = geometryInfo.start + geometryInfo.count; i < l; i ++ ) {\n\n\t\t\t\tlet iv = i;\n\t\t\t\tif ( index ) {\n\n\t\t\t\t\tiv = index.getX( iv );\n\n\t\t\t\t}\n\n\t\t\t\t_vector$5.fromBufferAttribute( position, iv );\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, sphere.center.distanceToSquared( _vector$5 ) );\n\n\t\t\t}\n\n\t\t\tsphere.radius = Math.sqrt( maxRadiusSq );\n\t\t\tgeometryInfo.boundingSphere = sphere;\n\n\t\t}\n\n\t\ttarget.copy( geometryInfo.boundingSphere );\n\t\treturn target;\n\n\t}\n\n\tsetMatrixAt( instanceId, matrix ) {\n\n\t\tthis.validateInstanceId( instanceId );\n\n\t\tconst matricesTexture = this._matricesTexture;\n\t\tconst matricesArray = this._matricesTexture.image.data;\n\t\tmatrix.toArray( matricesArray, instanceId * 16 );\n\t\tmatricesTexture.needsUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n\tgetMatrixAt( instanceId, matrix ) {\n\n\t\tthis.validateInstanceId( instanceId );\n\t\treturn matrix.fromArray( this._matricesTexture.image.data, instanceId * 16 );\n\n\t}\n\n\tsetColorAt( instanceId, color ) {\n\n\t\tthis.validateInstanceId( instanceId );\n\n\t\tif ( this._colorsTexture === null ) {\n\n\t\t\tthis._initColorsTexture();\n\n\t\t}\n\n\t\tcolor.toArray( this._colorsTexture.image.data, instanceId * 4 );\n\t\tthis._colorsTexture.needsUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n\tgetColorAt( instanceId, color ) {\n\n\t\tthis.validateInstanceId( instanceId );\n\t\treturn color.fromArray( this._colorsTexture.image.data, instanceId * 4 );\n\n\t}\n\n\tsetVisibleAt( instanceId, value ) {\n\n\t\tthis.validateInstanceId( instanceId );\n\n\t\tif ( this._instanceInfo[ instanceId ].visible === value ) {\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tthis._instanceInfo[ instanceId ].visible = value;\n\t\tthis._visibilityChanged = true;\n\n\t\treturn this;\n\n\t}\n\n\tgetVisibleAt( instanceId ) {\n\n\t\tthis.validateInstanceId( instanceId );\n\n\t\treturn this._instanceInfo[ instanceId ].visible;\n\n\t}\n\n\tsetGeometryIdAt( instanceId, geometryId ) {\n\n\t\tthis.validateInstanceId( instanceId );\n\t\tthis.validateGeometryId( geometryId );\n\n\t\tthis._instanceInfo[ instanceId ].geometryIndex = geometryId;\n\n\t\treturn this;\n\n\t}\n\n\tgetGeometryIdAt( instanceId ) {\n\n\t\tthis.validateInstanceId( instanceId );\n\n\t\treturn this._instanceInfo[ instanceId ].geometryIndex;\n\n\t}\n\n\tgetGeometryRangeAt( geometryId, target = {} ) {\n\n\t\tthis.validateGeometryId( geometryId );\n\n\t\tconst geometryInfo = this._geometryInfo[ geometryId ];\n\t\ttarget.vertexStart = geometryInfo.vertexStart;\n\t\ttarget.vertexCount = geometryInfo.vertexCount;\n\t\ttarget.reservedVertexCount = geometryInfo.reservedVertexCount;\n\n\t\ttarget.indexStart = geometryInfo.indexStart;\n\t\ttarget.indexCount = geometryInfo.indexCount;\n\t\ttarget.reservedIndexCount = geometryInfo.reservedIndexCount;\n\n\t\ttarget.start = geometryInfo.start;\n\t\ttarget.count = geometryInfo.count;\n\n\t\treturn target;\n\n\t}\n\n\tsetInstanceCount( maxInstanceCount ) {\n\n\t\t// shrink the available instances as much as possible\n\t\tconst availableInstanceIds = this._availableInstanceIds;\n\t\tconst instanceInfo = this._instanceInfo;\n\t\tavailableInstanceIds.sort( ascIdSort );\n\t\twhile ( availableInstanceIds[ availableInstanceIds.length - 1 ] === instanceInfo.length ) {\n\n\t\t\tinstanceInfo.pop();\n\t\t\tavailableInstanceIds.pop();\n\n\t\t}\n\n\t\t// throw an error if it can't be shrunk to the desired size\n\t\tif ( maxInstanceCount < instanceInfo.length ) {\n\n\t\t\tthrow new Error( `BatchedMesh: Instance ids outside the range ${ maxInstanceCount } are being used. Cannot shrink instance count.` );\n\n\t\t}\n\n\t\t// copy the multi draw counts\n\t\tconst multiDrawCounts = new Int32Array( maxInstanceCount );\n\t\tconst multiDrawStarts = new Int32Array( maxInstanceCount );\n\t\tcopyArrayContents( this._multiDrawCounts, multiDrawCounts );\n\t\tcopyArrayContents( this._multiDrawStarts, multiDrawStarts );\n\n\t\tthis._multiDrawCounts = multiDrawCounts;\n\t\tthis._multiDrawStarts = multiDrawStarts;\n\t\tthis._maxInstanceCount = maxInstanceCount;\n\n\t\t// update texture data for instance sampling\n\t\tconst indirectTexture = this._indirectTexture;\n\t\tconst matricesTexture = this._matricesTexture;\n\t\tconst colorsTexture = this._colorsTexture;\n\n\t\tindirectTexture.dispose();\n\t\tthis._initIndirectTexture();\n\t\tcopyArrayContents( indirectTexture.image.data, this._indirectTexture.image.data );\n\n\t\tmatricesTexture.dispose();\n\t\tthis._initMatricesTexture();\n\t\tcopyArrayContents( matricesTexture.image.data, this._matricesTexture.image.data );\n\n\t\tif ( colorsTexture ) {\n\n\t\t\tcolorsTexture.dispose();\n\t\t\tthis._initColorsTexture();\n\t\t\tcopyArrayContents( colorsTexture.image.data, this._colorsTexture.image.data );\n\n\t\t}\n\n\t}\n\n\tsetGeometrySize( maxVertexCount, maxIndexCount ) {\n\n\t\t// Check if we can shrink to the requested vertex attribute size\n\t\tconst validRanges = [ ...this._geometryInfo ].filter( info => info.active );\n\t\tconst requiredVertexLength = Math.max( ...validRanges.map( range => range.vertexStart + range.reservedVertexCount ) );\n\t\tif ( requiredVertexLength > maxVertexCount ) {\n\n\t\t\tthrow new Error( `BatchedMesh: Geometry vertex values are being used outside the range ${ maxIndexCount }. Cannot shrink further.` );\n\n\t\t}\n\n\t\t// Check if we can shrink to the requested index attribute size\n\t\tif ( this.geometry.index ) {\n\n\t\t\tconst requiredIndexLength = Math.max( ...validRanges.map( range => range.indexStart + range.reservedIndexCount ) );\n\t\t\tif ( requiredIndexLength > maxIndexCount ) {\n\n\t\t\t\tthrow new Error( `BatchedMesh: Geometry index values are being used outside the range ${ maxIndexCount }. Cannot shrink further.` );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\t// dispose of the previous geometry\n\t\tconst oldGeometry = this.geometry;\n\t\toldGeometry.dispose();\n\n\t\t// recreate the geometry needed based on the previous variant\n\t\tthis._maxVertexCount = maxVertexCount;\n\t\tthis._maxIndexCount = maxIndexCount;\n\n\t\tif ( this._geometryInitialized ) {\n\n\t\t\tthis._geometryInitialized = false;\n\t\t\tthis.geometry = new BufferGeometry();\n\t\t\tthis._initializeGeometry( oldGeometry );\n\n\t\t}\n\n\t\t// copy data from the previous geometry\n\t\tconst geometry = this.geometry;\n\t\tif ( oldGeometry.index ) {\n\n\t\t\tcopyArrayContents( oldGeometry.index.array, geometry.index.array );\n\n\t\t}\n\n\t\tfor ( const key in oldGeometry.attributes ) {\n\n\t\t\tcopyArrayContents( oldGeometry.attributes[ key ].array, geometry.attributes[ key ].array );\n\n\t\t}\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst instanceInfo = this._instanceInfo;\n\t\tconst geometryInfoList = this._geometryInfo;\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst batchGeometry = this.geometry;\n\n\t\t// iterate over each geometry\n\t\t_mesh.material = this.material;\n\t\t_mesh.geometry.index = batchGeometry.index;\n\t\t_mesh.geometry.attributes = batchGeometry.attributes;\n\t\tif ( _mesh.geometry.boundingBox === null ) {\n\n\t\t\t_mesh.geometry.boundingBox = new Box3();\n\n\t\t}\n\n\t\tif ( _mesh.geometry.boundingSphere === null ) {\n\n\t\t\t_mesh.geometry.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tfor ( let i = 0, l = instanceInfo.length; i < l; i ++ ) {\n\n\t\t\tif ( ! instanceInfo[ i ].visible || ! instanceInfo[ i ].active ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst geometryId = instanceInfo[ i ].geometryIndex;\n\t\t\tconst geometryInfo = geometryInfoList[ geometryId ];\n\t\t\t_mesh.geometry.setDrawRange( geometryInfo.start, geometryInfo.count );\n\n\t\t\t// get the intersects\n\t\t\tthis.getMatrixAt( i, _mesh.matrixWorld ).premultiply( matrixWorld );\n\t\t\tthis.getBoundingBoxAt( geometryId, _mesh.geometry.boundingBox );\n\t\t\tthis.getBoundingSphereAt( geometryId, _mesh.geometry.boundingSphere );\n\t\t\t_mesh.raycast( raycaster, _batchIntersects );\n\n\t\t\t// add batch id to the intersects\n\t\t\tfor ( let j = 0, l = _batchIntersects.length; j < l; j ++ ) {\n\n\t\t\t\tconst intersect = _batchIntersects[ j ];\n\t\t\t\tintersect.object = this;\n\t\t\t\tintersect.batchId = i;\n\t\t\t\tintersects.push( intersect );\n\n\t\t\t}\n\n\t\t\t_batchIntersects.length = 0;\n\n\t\t}\n\n\t\t_mesh.material = null;\n\t\t_mesh.geometry.index = null;\n\t\t_mesh.geometry.attributes = {};\n\t\t_mesh.geometry.setDrawRange( 0, Infinity );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.geometry = source.geometry.clone();\n\t\tthis.perObjectFrustumCulled = source.perObjectFrustumCulled;\n\t\tthis.sortObjects = source.sortObjects;\n\t\tthis.boundingBox = source.boundingBox !== null ? source.boundingBox.clone() : null;\n\t\tthis.boundingSphere = source.boundingSphere !== null ? source.boundingSphere.clone() : null;\n\n\t\tthis._geometryInfo = source._geometryInfo.map( info => ( {\n\t\t\t...info,\n\n\t\t\tboundingBox: info.boundingBox !== null ? info.boundingBox.clone() : null,\n\t\t\tboundingSphere: info.boundingSphere !== null ? info.boundingSphere.clone() : null,\n\t\t} ) );\n\t\tthis._instanceInfo = source._instanceInfo.map( info => ( { ...info } ) );\n\n\t\tthis._maxInstanceCount = source._maxInstanceCount;\n\t\tthis._maxVertexCount = source._maxVertexCount;\n\t\tthis._maxIndexCount = source._maxIndexCount;\n\n\t\tthis._geometryInitialized = source._geometryInitialized;\n\t\tthis._geometryCount = source._geometryCount;\n\t\tthis._multiDrawCounts = source._multiDrawCounts.slice();\n\t\tthis._multiDrawStarts = source._multiDrawStarts.slice();\n\n\t\tthis._matricesTexture = source._matricesTexture.clone();\n\t\tthis._matricesTexture.image.data = this._matricesTexture.image.data.slice();\n\n\t\tif ( this._colorsTexture !== null ) {\n\n\t\t\tthis._colorsTexture = source._colorsTexture.clone();\n\t\t\tthis._colorsTexture.image.data = this._colorsTexture.image.data.slice();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\t// Assuming the geometry is not shared with other meshes\n\t\tthis.geometry.dispose();\n\n\t\tthis._matricesTexture.dispose();\n\t\tthis._matricesTexture = null;\n\n\t\tthis._indirectTexture.dispose();\n\t\tthis._indirectTexture = null;\n\n\t\tif ( this._colorsTexture !== null ) {\n\n\t\t\tthis._colorsTexture.dispose();\n\t\t\tthis._colorsTexture = null;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tonBeforeRender( renderer, scene, camera, geometry, material/*, _group*/ ) {\n\n\t\t// if visibility has not changed and frustum culling and object sorting is not required\n\t\t// then skip iterating over all items\n\t\tif ( ! this._visibilityChanged && ! this.perObjectFrustumCulled && ! this.sortObjects ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// the indexed version of the multi draw function requires specifying the start\n\t\t// offset in bytes.\n\t\tconst index = geometry.getIndex();\n\t\tconst bytesPerElement = index === null ? 1 : index.array.BYTES_PER_ELEMENT;\n\n\t\tconst instanceInfo = this._instanceInfo;\n\t\tconst multiDrawStarts = this._multiDrawStarts;\n\t\tconst multiDrawCounts = this._multiDrawCounts;\n\t\tconst geometryInfoList = this._geometryInfo;\n\t\tconst perObjectFrustumCulled = this.perObjectFrustumCulled;\n\t\tconst indirectTexture = this._indirectTexture;\n\t\tconst indirectArray = indirectTexture.image.data;\n\n\t\t// prepare the frustum in the local frame\n\t\tif ( perObjectFrustumCulled ) {\n\n\t\t\t_matrix$1\n\t\t\t\t.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse )\n\t\t\t\t.multiply( this.matrixWorld );\n\t\t\t_frustum.setFromProjectionMatrix(\n\t\t\t\t_matrix$1,\n\t\t\t\trenderer.coordinateSystem\n\t\t\t);\n\n\t\t}\n\n\t\tlet multiDrawCount = 0;\n\t\tif ( this.sortObjects ) {\n\n\t\t\t// get the camera position in the local frame\n\t\t\t_matrix$1.copy( this.matrixWorld ).invert();\n\t\t\t_vector$5.setFromMatrixPosition( camera.matrixWorld ).applyMatrix4( _matrix$1 );\n\t\t\t_forward.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld ).transformDirection( _matrix$1 );\n\n\t\t\tfor ( let i = 0, l = instanceInfo.length; i < l; i ++ ) {\n\n\t\t\t\tif ( instanceInfo[ i ].visible && instanceInfo[ i ].active ) {\n\n\t\t\t\t\tconst geometryId = instanceInfo[ i ].geometryIndex;\n\n\t\t\t\t\t// get the bounds in world space\n\t\t\t\t\tthis.getMatrixAt( i, _matrix$1 );\n\t\t\t\t\tthis.getBoundingSphereAt( geometryId, _sphere$2 ).applyMatrix4( _matrix$1 );\n\n\t\t\t\t\t// determine whether the batched geometry is within the frustum\n\t\t\t\t\tlet culled = false;\n\t\t\t\t\tif ( perObjectFrustumCulled ) {\n\n\t\t\t\t\t\tculled = ! _frustum.intersectsSphere( _sphere$2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! culled ) {\n\n\t\t\t\t\t\t// get the distance from camera used for sorting\n\t\t\t\t\t\tconst geometryInfo = geometryInfoList[ geometryId ];\n\t\t\t\t\t\tconst z = _temp.subVectors( _sphere$2.center, _vector$5 ).dot( _forward );\n\t\t\t\t\t\t_renderList.push( geometryInfo.start, geometryInfo.count, z, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Sort the draw ranges and prep for rendering\n\t\t\tconst list = _renderList.list;\n\t\t\tconst customSort = this.customSort;\n\t\t\tif ( customSort === null ) {\n\n\t\t\t\tlist.sort( material.transparent ? sortTransparent : sortOpaque );\n\n\t\t\t} else {\n\n\t\t\t\tcustomSort.call( this, list, camera );\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, l = list.length; i < l; i ++ ) {\n\n\t\t\t\tconst item = list[ i ];\n\t\t\t\tmultiDrawStarts[ multiDrawCount ] = item.start * bytesPerElement;\n\t\t\t\tmultiDrawCounts[ multiDrawCount ] = item.count;\n\t\t\t\tindirectArray[ multiDrawCount ] = item.index;\n\t\t\t\tmultiDrawCount ++;\n\n\t\t\t}\n\n\t\t\t_renderList.reset();\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0, l = instanceInfo.length; i < l; i ++ ) {\n\n\t\t\t\tif ( instanceInfo[ i ].visible && instanceInfo[ i ].active ) {\n\n\t\t\t\t\tconst geometryId = instanceInfo[ i ].geometryIndex;\n\n\t\t\t\t\t// determine whether the batched geometry is within the frustum\n\t\t\t\t\tlet culled = false;\n\t\t\t\t\tif ( perObjectFrustumCulled ) {\n\n\t\t\t\t\t\t// get the bounds in world space\n\t\t\t\t\t\tthis.getMatrixAt( i, _matrix$1 );\n\t\t\t\t\t\tthis.getBoundingSphereAt( geometryId, _sphere$2 ).applyMatrix4( _matrix$1 );\n\t\t\t\t\t\tculled = ! _frustum.intersectsSphere( _sphere$2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! culled ) {\n\n\t\t\t\t\t\tconst geometryInfo = geometryInfoList[ geometryId ];\n\t\t\t\t\t\tmultiDrawStarts[ multiDrawCount ] = geometryInfo.start * bytesPerElement;\n\t\t\t\t\t\tmultiDrawCounts[ multiDrawCount ] = geometryInfo.count;\n\t\t\t\t\t\tindirectArray[ multiDrawCount ] = i;\n\t\t\t\t\t\tmultiDrawCount ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tindirectTexture.needsUpdate = true;\n\t\tthis._multiDrawCount = multiDrawCount;\n\t\tthis._visibilityChanged = false;\n\n\t}\n\n\tonBeforeShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial/* , group */ ) {\n\n\t\tthis.onBeforeRender( renderer, null, shadowCamera, geometry, depthMaterial );\n\n\t}\n\n}\n\nclass LineBasicMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isLineBasicMaterial = true;\n\n\t\tthis.type = 'LineBasicMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.map = null;\n\n\t\tthis.linewidth = 1;\n\t\tthis.linecap = 'round';\n\t\tthis.linejoin = 'round';\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.linewidth = source.linewidth;\n\t\tthis.linecap = source.linecap;\n\t\tthis.linejoin = source.linejoin;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _vStart = /*@__PURE__*/ new Vector3();\nconst _vEnd = /*@__PURE__*/ new Vector3();\n\nconst _inverseMatrix$1 = /*@__PURE__*/ new Matrix4();\nconst _ray$1 = /*@__PURE__*/ new Ray();\nconst _sphere$1 = /*@__PURE__*/ new Sphere();\n\nconst _intersectPointOnRay = /*@__PURE__*/ new Vector3();\nconst _intersectPointOnSegment = /*@__PURE__*/ new Vector3();\n\nclass Line extends Object3D {\n\n\tconstructor( geometry = new BufferGeometry(), material = new LineBasicMaterial() ) {\n\n\t\tsuper();\n\n\t\tthis.isLine = true;\n\n\t\tthis.type = 'Line';\n\n\t\tthis.geometry = geometry;\n\t\tthis.material = material;\n\n\t\tthis.updateMorphTargets();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.material = Array.isArray( source.material ) ? source.material.slice() : source.material;\n\t\tthis.geometry = source.geometry;\n\n\t\treturn this;\n\n\t}\n\n\tcomputeLineDistances() {\n\n\t\tconst geometry = this.geometry;\n\n\t\t// we assume non-indexed geometry\n\n\t\tif ( geometry.index === null ) {\n\n\t\t\tconst positionAttribute = geometry.attributes.position;\n\t\t\tconst lineDistances = [ 0 ];\n\n\t\t\tfor ( let i = 1, l = positionAttribute.count; i < l; i ++ ) {\n\n\t\t\t\t_vStart.fromBufferAttribute( positionAttribute, i - 1 );\n\t\t\t\t_vEnd.fromBufferAttribute( positionAttribute, i );\n\n\t\t\t\tlineDistances[ i ] = lineDistances[ i - 1 ];\n\t\t\t\tlineDistances[ i ] += _vStart.distanceTo( _vEnd );\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst threshold = raycaster.params.Line.threshold;\n\t\tconst drawRange = geometry.drawRange;\n\n\t\t// Checking boundingSphere distance to ray\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere$1.copy( geometry.boundingSphere );\n\t\t_sphere$1.applyMatrix4( matrixWorld );\n\t\t_sphere$1.radius += threshold;\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere$1 ) === false ) return;\n\n\t\t//\n\n\t\t_inverseMatrix$1.copy( matrixWorld ).invert();\n\t\t_ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );\n\n\t\tconst localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\tconst localThresholdSq = localThreshold * localThreshold;\n\n\t\tconst step = this.isLineSegments ? 2 : 1;\n\n\t\tconst index = geometry.index;\n\t\tconst attributes = geometry.attributes;\n\t\tconst positionAttribute = attributes.position;\n\n\t\tif ( index !== null ) {\n\n\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\tconst end = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( let i = start, l = end - 1; i < l; i += step ) {\n\n\t\t\t\tconst a = index.getX( i );\n\t\t\t\tconst b = index.getX( i + 1 );\n\n\t\t\t\tconst intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, a, b );\n\n\t\t\t\tif ( intersect ) {\n\n\t\t\t\t\tintersects.push( intersect );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.isLineLoop ) {\n\n\t\t\t\tconst a = index.getX( end - 1 );\n\t\t\t\tconst b = index.getX( start );\n\n\t\t\t\tconst intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, a, b );\n\n\t\t\t\tif ( intersect ) {\n\n\t\t\t\t\tintersects.push( intersect );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\tconst end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( let i = start, l = end - 1; i < l; i += step ) {\n\n\t\t\t\tconst intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, i, i + 1 );\n\n\t\t\t\tif ( intersect ) {\n\n\t\t\t\t\tintersects.push( intersect );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.isLineLoop ) {\n\n\t\t\t\tconst intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, end - 1, start );\n\n\t\t\t\tif ( intersect ) {\n\n\t\t\t\t\tintersects.push( intersect );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdateMorphTargets() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst morphAttributes = geometry.morphAttributes;\n\t\tconst keys = Object.keys( morphAttributes );\n\n\t\tif ( keys.length > 0 ) {\n\n\t\t\tconst morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\tfor ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\tconst name = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nfunction checkIntersection( object, raycaster, ray, thresholdSq, a, b ) {\n\n\tconst positionAttribute = object.geometry.attributes.position;\n\n\t_vStart.fromBufferAttribute( positionAttribute, a );\n\t_vEnd.fromBufferAttribute( positionAttribute, b );\n\n\tconst distSq = ray.distanceSqToSegment( _vStart, _vEnd, _intersectPointOnRay, _intersectPointOnSegment );\n\n\tif ( distSq > thresholdSq ) return;\n\n\t_intersectPointOnRay.applyMatrix4( object.matrixWorld ); // Move back to world space for distance calculation\n\n\tconst distance = raycaster.ray.origin.distanceTo( _intersectPointOnRay );\n\n\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\treturn {\n\n\t\tdistance: distance,\n\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t// point: raycaster.ray.at( distance ),\n\t\tpoint: _intersectPointOnSegment.clone().applyMatrix4( object.matrixWorld ),\n\t\tindex: a,\n\t\tface: null,\n\t\tfaceIndex: null,\n\t\tbarycoord: null,\n\t\tobject: object\n\n\t};\n\n}\n\nconst _start = /*@__PURE__*/ new Vector3();\nconst _end = /*@__PURE__*/ new Vector3();\n\nclass LineSegments extends Line {\n\n\tconstructor( geometry, material ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isLineSegments = true;\n\n\t\tthis.type = 'LineSegments';\n\n\t}\n\n\tcomputeLineDistances() {\n\n\t\tconst geometry = this.geometry;\n\n\t\t// we assume non-indexed geometry\n\n\t\tif ( geometry.index === null ) {\n\n\t\t\tconst positionAttribute = geometry.attributes.position;\n\t\t\tconst lineDistances = [];\n\n\t\t\tfor ( let i = 0, l = positionAttribute.count; i < l; i += 2 ) {\n\n\t\t\t\t_start.fromBufferAttribute( positionAttribute, i );\n\t\t\t\t_end.fromBufferAttribute( positionAttribute, i + 1 );\n\n\t\t\t\tlineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];\n\t\t\t\tlineDistances[ i + 1 ] = lineDistances[ i ] + _start.distanceTo( _end );\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass LineLoop extends Line {\n\n\tconstructor( geometry, material ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isLineLoop = true;\n\n\t\tthis.type = 'LineLoop';\n\n\t}\n\n}\n\nclass PointsMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isPointsMaterial = true;\n\n\t\tthis.type = 'PointsMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.size = 1;\n\t\tthis.sizeAttenuation = true;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.size = source.size;\n\t\tthis.sizeAttenuation = source.sizeAttenuation;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _inverseMatrix = /*@__PURE__*/ new Matrix4();\nconst _ray = /*@__PURE__*/ new Ray();\nconst _sphere = /*@__PURE__*/ new Sphere();\nconst _position$2 = /*@__PURE__*/ new Vector3();\n\nclass Points extends Object3D {\n\n\tconstructor( geometry = new BufferGeometry(), material = new PointsMaterial() ) {\n\n\t\tsuper();\n\n\t\tthis.isPoints = true;\n\n\t\tthis.type = 'Points';\n\n\t\tthis.geometry = geometry;\n\t\tthis.material = material;\n\n\t\tthis.updateMorphTargets();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.material = Array.isArray( source.material ) ? source.material.slice() : source.material;\n\t\tthis.geometry = source.geometry;\n\n\t\treturn this;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst threshold = raycaster.params.Points.threshold;\n\t\tconst drawRange = geometry.drawRange;\n\n\t\t// Checking boundingSphere distance to ray\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere.copy( geometry.boundingSphere );\n\t\t_sphere.applyMatrix4( matrixWorld );\n\t\t_sphere.radius += threshold;\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;\n\n\t\t//\n\n\t\t_inverseMatrix.copy( matrixWorld ).invert();\n\t\t_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );\n\n\t\tconst localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\tconst localThresholdSq = localThreshold * localThreshold;\n\n\t\tconst index = geometry.index;\n\t\tconst attributes = geometry.attributes;\n\t\tconst positionAttribute = attributes.position;\n\n\t\tif ( index !== null ) {\n\n\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\tconst end = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( let i = start, il = end; i < il; i ++ ) {\n\n\t\t\t\tconst a = index.getX( i );\n\n\t\t\t\t_position$2.fromBufferAttribute( positionAttribute, a );\n\n\t\t\t\ttestPoint( _position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\tconst end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( let i = start, l = end; i < l; i ++ ) {\n\n\t\t\t\t_position$2.fromBufferAttribute( positionAttribute, i );\n\n\t\t\t\ttestPoint( _position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdateMorphTargets() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst morphAttributes = geometry.morphAttributes;\n\t\tconst keys = Object.keys( morphAttributes );\n\n\t\tif ( keys.length > 0 ) {\n\n\t\t\tconst morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\tfor ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\tconst name = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nfunction testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {\n\n\tconst rayPointDistanceSq = _ray.distanceSqToPoint( point );\n\n\tif ( rayPointDistanceSq < localThresholdSq ) {\n\n\t\tconst intersectPoint = new Vector3();\n\n\t\t_ray.closestPointToPoint( point, intersectPoint );\n\t\tintersectPoint.applyMatrix4( matrixWorld );\n\n\t\tconst distance = raycaster.ray.origin.distanceTo( intersectPoint );\n\n\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\t\tintersects.push( {\n\n\t\t\tdistance: distance,\n\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\n\t\t\tpoint: intersectPoint,\n\t\t\tindex: index,\n\t\t\tface: null,\n\t\t\tfaceIndex: null,\n\t\t\tbarycoord: null,\n\t\t\tobject: object\n\n\t\t} );\n\n\t}\n\n}\n\nclass Group extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isGroup = true;\n\n\t\tthis.type = 'Group';\n\n\t}\n\n}\n\nclass VideoTexture extends Texture {\n\n\tconstructor( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\t\tsuper( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.isVideoTexture = true;\n\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : LinearFilter;\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\n\n\t\tthis.generateMipmaps = false;\n\n\t\tconst scope = this;\n\n\t\tfunction updateVideo() {\n\n\t\t\tscope.needsUpdate = true;\n\t\t\tvideo.requestVideoFrameCallback( updateVideo );\n\n\t\t}\n\n\t\tif ( 'requestVideoFrameCallback' in video ) {\n\n\t\t\tvideo.requestVideoFrameCallback( updateVideo );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.image ).copy( this );\n\n\t}\n\n\tupdate() {\n\n\t\tconst video = this.image;\n\t\tconst hasVideoFrameCallback = 'requestVideoFrameCallback' in video;\n\n\t\tif ( hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n}\n\nclass FramebufferTexture extends Texture {\n\n\tconstructor( width, height ) {\n\n\t\tsuper( { width, height } );\n\n\t\tthis.isFramebufferTexture = true;\n\n\t\tthis.magFilter = NearestFilter;\n\t\tthis.minFilter = NearestFilter;\n\n\t\tthis.generateMipmaps = false;\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nclass CompressedTexture extends Texture {\n\n\tconstructor( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, colorSpace ) {\n\n\t\tsuper( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );\n\n\t\tthis.isCompressedTexture = true;\n\n\t\tthis.image = { width: width, height: height };\n\t\tthis.mipmaps = mipmaps;\n\n\t\t// no flipping for cube textures\n\t\t// (also flipping doesn't work for compressed textures )\n\n\t\tthis.flipY = false;\n\n\t\t// can't generate mipmaps for compressed textures\n\t\t// mips must be embedded in DDS files\n\n\t\tthis.generateMipmaps = false;\n\n\t}\n\n}\n\nclass CompressedArrayTexture extends CompressedTexture {\n\n\tconstructor( mipmaps, width, height, depth, format, type ) {\n\n\t\tsuper( mipmaps, width, height, format, type );\n\n\t\tthis.isCompressedArrayTexture = true;\n\t\tthis.image.depth = depth;\n\t\tthis.wrapR = ClampToEdgeWrapping;\n\n\t\tthis.layerUpdates = new Set();\n\n\t}\n\n\taddLayerUpdate( layerIndex ) {\n\n\t\tthis.layerUpdates.add( layerIndex );\n\n\t}\n\n\tclearLayerUpdates() {\n\n\t\tthis.layerUpdates.clear();\n\n\t}\n\n}\n\nclass CompressedCubeTexture extends CompressedTexture {\n\n\tconstructor( images, format, type ) {\n\n\t\tsuper( undefined, images[ 0 ].width, images[ 0 ].height, format, type, CubeReflectionMapping );\n\n\t\tthis.isCompressedCubeTexture = true;\n\t\tthis.isCubeTexture = true;\n\n\t\tthis.image = images;\n\n\t}\n\n}\n\nclass CanvasTexture extends Texture {\n\n\tconstructor( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\t\tsuper( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.isCanvasTexture = true;\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nclass DepthTexture extends Texture {\n\n\tconstructor( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format = DepthFormat ) {\n\n\t\tif ( format !== DepthFormat && format !== DepthStencilFormat ) {\n\n\t\t\tthrow new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );\n\n\t\t}\n\n\t\tif ( type === undefined && format === DepthFormat ) type = UnsignedIntType;\n\t\tif ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;\n\n\t\tsuper( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.isDepthTexture = true;\n\n\t\tthis.image = { width: width, height: height };\n\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\n\t\tthis.flipY = false;\n\t\tthis.generateMipmaps = false;\n\n\t\tthis.compareFunction = null;\n\n\t}\n\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.compareFunction = source.compareFunction;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tif ( this.compareFunction !== null ) data.compareFunction = this.compareFunction;\n\n\t\treturn data;\n\n\t}\n\n}\n\n/**\n * Extensible curve object.\n *\n * Some common of curve methods:\n * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )\n * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )\n * .getPoints(), .getSpacedPoints()\n * .getLength()\n * .updateArcLengths()\n *\n * This following curves inherit from THREE.Curve:\n *\n * -- 2D curves --\n * THREE.ArcCurve\n * THREE.CubicBezierCurve\n * THREE.EllipseCurve\n * THREE.LineCurve\n * THREE.QuadraticBezierCurve\n * THREE.SplineCurve\n *\n * -- 3D curves --\n * THREE.CatmullRomCurve3\n * THREE.CubicBezierCurve3\n * THREE.LineCurve3\n * THREE.QuadraticBezierCurve3\n *\n * A series of curves can be represented as a THREE.CurvePath.\n *\n **/\n\nclass Curve {\n\n\tconstructor() {\n\n\t\tthis.type = 'Curve';\n\n\t\tthis.arcLengthDivisions = 200;\n\n\t}\n\n\t// Virtual base class method to overwrite and implement in subclasses\n\t//\t- t [0 .. 1]\n\n\tgetPoint( /* t, optionalTarget */ ) {\n\n\t\tconsole.warn( 'THREE.Curve: .getPoint() not implemented.' );\n\t\treturn null;\n\n\t}\n\n\t// Get point at relative position in curve according to arc length\n\t// - u [0 .. 1]\n\n\tgetPointAt( u, optionalTarget ) {\n\n\t\tconst t = this.getUtoTmapping( u );\n\t\treturn this.getPoint( t, optionalTarget );\n\n\t}\n\n\t// Get sequence of points using getPoint( t )\n\n\tgetPoints( divisions = 5 ) {\n\n\t\tconst points = [];\n\n\t\tfor ( let d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpoints.push( this.getPoint( d / divisions ) );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\t// Get sequence of points using getPointAt( u )\n\n\tgetSpacedPoints( divisions = 5 ) {\n\n\t\tconst points = [];\n\n\t\tfor ( let d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpoints.push( this.getPointAt( d / divisions ) );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\t// Get total curve arc length\n\n\tgetLength() {\n\n\t\tconst lengths = this.getLengths();\n\t\treturn lengths[ lengths.length - 1 ];\n\n\t}\n\n\t// Get list of cumulative segment lengths\n\n\tgetLengths( divisions = this.arcLengthDivisions ) {\n\n\t\tif ( this.cacheArcLengths &&\n\t\t\t( this.cacheArcLengths.length === divisions + 1 ) &&\n\t\t\t! this.needsUpdate ) {\n\n\t\t\treturn this.cacheArcLengths;\n\n\t\t}\n\n\t\tthis.needsUpdate = false;\n\n\t\tconst cache = [];\n\t\tlet current, last = this.getPoint( 0 );\n\t\tlet sum = 0;\n\n\t\tcache.push( 0 );\n\n\t\tfor ( let p = 1; p <= divisions; p ++ ) {\n\n\t\t\tcurrent = this.getPoint( p / divisions );\n\t\t\tsum += current.distanceTo( last );\n\t\t\tcache.push( sum );\n\t\t\tlast = current;\n\n\t\t}\n\n\t\tthis.cacheArcLengths = cache;\n\n\t\treturn cache; // { sums: cache, sum: sum }; Sum is in the last element.\n\n\t}\n\n\tupdateArcLengths() {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.getLengths();\n\n\t}\n\n\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n\tgetUtoTmapping( u, distance ) {\n\n\t\tconst arcLengths = this.getLengths();\n\n\t\tlet i = 0;\n\t\tconst il = arcLengths.length;\n\n\t\tlet targetArcLength; // The targeted u distance value to get\n\n\t\tif ( distance ) {\n\n\t\t\ttargetArcLength = distance;\n\n\t\t} else {\n\n\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\n\t\t}\n\n\t\t// binary search for the index with largest value smaller than target u distance\n\n\t\tlet low = 0, high = il - 1, comparison;\n\n\t\twhile ( low <= high ) {\n\n\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\n\t\t\tif ( comparison < 0 ) {\n\n\t\t\t\tlow = i + 1;\n\n\t\t\t} else if ( comparison > 0 ) {\n\n\t\t\t\thigh = i - 1;\n\n\t\t\t} else {\n\n\t\t\t\thigh = i;\n\t\t\t\tbreak;\n\n\t\t\t\t// DONE\n\n\t\t\t}\n\n\t\t}\n\n\t\ti = high;\n\n\t\tif ( arcLengths[ i ] === targetArcLength ) {\n\n\t\t\treturn i / ( il - 1 );\n\n\t\t}\n\n\t\t// we could get finer grain at lengths, or use simple interpolation between two points\n\n\t\tconst lengthBefore = arcLengths[ i ];\n\t\tconst lengthAfter = arcLengths[ i + 1 ];\n\n\t\tconst segmentLength = lengthAfter - lengthBefore;\n\n\t\t// determine where we are between the 'before' and 'after' points\n\n\t\tconst segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\n\t\t// add that fractional amount to t\n\n\t\tconst t = ( i + segmentFraction ) / ( il - 1 );\n\n\t\treturn t;\n\n\t}\n\n\t// Returns a unit vector tangent at t\n\t// In case any sub curve does not implement its tangent derivation,\n\t// 2 points a small delta apart will be used to find its gradient\n\t// which seems to give a reasonable approximation\n\n\tgetTangent( t, optionalTarget ) {\n\n\t\tconst delta = 0.0001;\n\t\tlet t1 = t - delta;\n\t\tlet t2 = t + delta;\n\n\t\t// Capping in case of danger\n\n\t\tif ( t1 < 0 ) t1 = 0;\n\t\tif ( t2 > 1 ) t2 = 1;\n\n\t\tconst pt1 = this.getPoint( t1 );\n\t\tconst pt2 = this.getPoint( t2 );\n\n\t\tconst tangent = optionalTarget || ( ( pt1.isVector2 ) ? new Vector2() : new Vector3() );\n\n\t\ttangent.copy( pt2 ).sub( pt1 ).normalize();\n\n\t\treturn tangent;\n\n\t}\n\n\tgetTangentAt( u, optionalTarget ) {\n\n\t\tconst t = this.getUtoTmapping( u );\n\t\treturn this.getTangent( t, optionalTarget );\n\n\t}\n\n\tcomputeFrenetFrames( segments, closed ) {\n\n\t\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\n\t\tconst normal = new Vector3();\n\n\t\tconst tangents = [];\n\t\tconst normals = [];\n\t\tconst binormals = [];\n\n\t\tconst vec = new Vector3();\n\t\tconst mat = new Matrix4();\n\n\t\t// compute the tangent vectors for each segment on the curve\n\n\t\tfor ( let i = 0; i <= segments; i ++ ) {\n\n\t\t\tconst u = i / segments;\n\n\t\t\ttangents[ i ] = this.getTangentAt( u, new Vector3() );\n\n\t\t}\n\n\t\t// select an initial normal vector perpendicular to the first tangent vector,\n\t\t// and in the direction of the minimum tangent xyz component\n\n\t\tnormals[ 0 ] = new Vector3();\n\t\tbinormals[ 0 ] = new Vector3();\n\t\tlet min = Number.MAX_VALUE;\n\t\tconst tx = Math.abs( tangents[ 0 ].x );\n\t\tconst ty = Math.abs( tangents[ 0 ].y );\n\t\tconst tz = Math.abs( tangents[ 0 ].z );\n\n\t\tif ( tx <= min ) {\n\n\t\t\tmin = tx;\n\t\t\tnormal.set( 1, 0, 0 );\n\n\t\t}\n\n\t\tif ( ty <= min ) {\n\n\t\t\tmin = ty;\n\t\t\tnormal.set( 0, 1, 0 );\n\n\t\t}\n\n\t\tif ( tz <= min ) {\n\n\t\t\tnormal.set( 0, 0, 1 );\n\n\t\t}\n\n\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\n\n\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\n\t\t// compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n\t\tfor ( let i = 1; i <= segments; i ++ ) {\n\n\t\t\tnormals[ i ] = normals[ i - 1 ].clone();\n\n\t\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\n\n\t\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\n\t\t\tif ( vec.length() > Number.EPSILON ) {\n\n\t\t\t\tvec.normalize();\n\n\t\t\t\tconst theta = Math.acos( clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\n\t\t\t}\n\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t}\n\n\t\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\t\tif ( closed === true ) {\n\n\t\t\tlet theta = Math.acos( clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\n\t\t\ttheta /= segments;\n\n\t\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\n\n\t\t\t\ttheta = - theta;\n\n\t\t\t}\n\n\t\t\tfor ( let i = 1; i <= segments; i ++ ) {\n\n\t\t\t\t// twist a little...\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\t\t\ttangents: tangents,\n\t\t\tnormals: normals,\n\t\t\tbinormals: binormals\n\t\t};\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.arcLengthDivisions = source.arcLengthDivisions;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'Curve',\n\t\t\t\tgenerator: 'Curve.toJSON'\n\t\t\t}\n\t\t};\n\n\t\tdata.arcLengthDivisions = this.arcLengthDivisions;\n\t\tdata.type = this.type;\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tthis.arcLengthDivisions = json.arcLengthDivisions;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass EllipseCurve extends Curve {\n\n\tconstructor( aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0 ) {\n\n\t\tsuper();\n\n\t\tthis.isEllipseCurve = true;\n\n\t\tthis.type = 'EllipseCurve';\n\n\t\tthis.aX = aX;\n\t\tthis.aY = aY;\n\n\t\tthis.xRadius = xRadius;\n\t\tthis.yRadius = yRadius;\n\n\t\tthis.aStartAngle = aStartAngle;\n\t\tthis.aEndAngle = aEndAngle;\n\n\t\tthis.aClockwise = aClockwise;\n\n\t\tthis.aRotation = aRotation;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst twoPi = Math.PI * 2;\n\t\tlet deltaAngle = this.aEndAngle - this.aStartAngle;\n\t\tconst samePoints = Math.abs( deltaAngle ) < Number.EPSILON;\n\n\t\t// ensures that deltaAngle is 0 .. 2 PI\n\t\twhile ( deltaAngle < 0 ) deltaAngle += twoPi;\n\t\twhile ( deltaAngle > twoPi ) deltaAngle -= twoPi;\n\n\t\tif ( deltaAngle < Number.EPSILON ) {\n\n\t\t\tif ( samePoints ) {\n\n\t\t\t\tdeltaAngle = 0;\n\n\t\t\t} else {\n\n\t\t\t\tdeltaAngle = twoPi;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.aClockwise === true && ! samePoints ) {\n\n\t\t\tif ( deltaAngle === twoPi ) {\n\n\t\t\t\tdeltaAngle = - twoPi;\n\n\t\t\t} else {\n\n\t\t\t\tdeltaAngle = deltaAngle - twoPi;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst angle = this.aStartAngle + t * deltaAngle;\n\t\tlet x = this.aX + this.xRadius * Math.cos( angle );\n\t\tlet y = this.aY + this.yRadius * Math.sin( angle );\n\n\t\tif ( this.aRotation !== 0 ) {\n\n\t\t\tconst cos = Math.cos( this.aRotation );\n\t\t\tconst sin = Math.sin( this.aRotation );\n\n\t\t\tconst tx = x - this.aX;\n\t\t\tconst ty = y - this.aY;\n\n\t\t\t// Rotate the point about the center of the ellipse.\n\t\t\tx = tx * cos - ty * sin + this.aX;\n\t\t\ty = tx * sin + ty * cos + this.aY;\n\n\t\t}\n\n\t\treturn point.set( x, y );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.aX = source.aX;\n\t\tthis.aY = source.aY;\n\n\t\tthis.xRadius = source.xRadius;\n\t\tthis.yRadius = source.yRadius;\n\n\t\tthis.aStartAngle = source.aStartAngle;\n\t\tthis.aEndAngle = source.aEndAngle;\n\n\t\tthis.aClockwise = source.aClockwise;\n\n\t\tthis.aRotation = source.aRotation;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.aX = this.aX;\n\t\tdata.aY = this.aY;\n\n\t\tdata.xRadius = this.xRadius;\n\t\tdata.yRadius = this.yRadius;\n\n\t\tdata.aStartAngle = this.aStartAngle;\n\t\tdata.aEndAngle = this.aEndAngle;\n\n\t\tdata.aClockwise = this.aClockwise;\n\n\t\tdata.aRotation = this.aRotation;\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.aX = json.aX;\n\t\tthis.aY = json.aY;\n\n\t\tthis.xRadius = json.xRadius;\n\t\tthis.yRadius = json.yRadius;\n\n\t\tthis.aStartAngle = json.aStartAngle;\n\t\tthis.aEndAngle = json.aEndAngle;\n\n\t\tthis.aClockwise = json.aClockwise;\n\n\t\tthis.aRotation = json.aRotation;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass ArcCurve extends EllipseCurve {\n\n\tconstructor( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tsuper( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t\tthis.isArcCurve = true;\n\n\t\tthis.type = 'ArcCurve';\n\n\t}\n\n}\n\n/**\n * Centripetal CatmullRom Curve - which is useful for avoiding\n * cusps and self-intersections in non-uniform catmull rom curves.\n * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n *\n * curve.type accepts centripetal(default), chordal and catmullrom\n * curve.tension is used for catmullrom which defaults to 0.5\n */\n\n\n/*\nBased on an optimized c++ solution in\n - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n - http://ideone.com/NoEbVM\n\nThis CubicPoly class could be used for reusing some variables and calculations,\nbut for three.js curve use, it could be possible inlined and flatten into a single function call\nwhich can be placed in CurveUtils.\n*/\n\nfunction CubicPoly() {\n\n\tlet c0 = 0, c1 = 0, c2 = 0, c3 = 0;\n\n\t/*\n\t * Compute coefficients for a cubic polynomial\n\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n\t * such that\n\t *   p(0) = x0, p(1) = x1\n\t *  and\n\t *   p'(0) = t0, p'(1) = t1.\n\t */\n\tfunction init( x0, x1, t0, t1 ) {\n\n\t\tc0 = x0;\n\t\tc1 = t0;\n\t\tc2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\n\t\tc3 = 2 * x0 - 2 * x1 + t0 + t1;\n\n\t}\n\n\treturn {\n\n\t\tinitCatmullRom: function ( x0, x1, x2, x3, tension ) {\n\n\t\t\tinit( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\n\n\t\t},\n\n\t\tinitNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {\n\n\t\t\t// compute tangents when parameterized in [t1,t2]\n\t\t\tlet t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\n\t\t\tlet t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\n\n\t\t\t// rescale tangents for parametrization in [0,1]\n\t\t\tt1 *= dt1;\n\t\t\tt2 *= dt1;\n\n\t\t\tinit( x1, x2, t1, t2 );\n\n\t\t},\n\n\t\tcalc: function ( t ) {\n\n\t\t\tconst t2 = t * t;\n\t\t\tconst t3 = t2 * t;\n\t\t\treturn c0 + c1 * t + c2 * t2 + c3 * t3;\n\n\t\t}\n\n\t};\n\n}\n\n//\n\nconst tmp = /*@__PURE__*/ new Vector3();\nconst px = /*@__PURE__*/ new CubicPoly();\nconst py = /*@__PURE__*/ new CubicPoly();\nconst pz = /*@__PURE__*/ new CubicPoly();\n\nclass CatmullRomCurve3 extends Curve {\n\n\tconstructor( points = [], closed = false, curveType = 'centripetal', tension = 0.5 ) {\n\n\t\tsuper();\n\n\t\tthis.isCatmullRomCurve3 = true;\n\n\t\tthis.type = 'CatmullRomCurve3';\n\n\t\tthis.points = points;\n\t\tthis.closed = closed;\n\t\tthis.curveType = curveType;\n\t\tthis.tension = tension;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst points = this.points;\n\t\tconst l = points.length;\n\n\t\tconst p = ( l - ( this.closed ? 0 : 1 ) ) * t;\n\t\tlet intPoint = Math.floor( p );\n\t\tlet weight = p - intPoint;\n\n\t\tif ( this.closed ) {\n\n\t\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;\n\n\t\t} else if ( weight === 0 && intPoint === l - 1 ) {\n\n\t\t\tintPoint = l - 2;\n\t\t\tweight = 1;\n\n\t\t}\n\n\t\tlet p0, p3; // 4 points (p1 & p2 defined below)\n\n\t\tif ( this.closed || intPoint > 0 ) {\n\n\t\t\tp0 = points[ ( intPoint - 1 ) % l ];\n\n\t\t} else {\n\n\t\t\t// extrapolate first point\n\t\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\n\t\t\tp0 = tmp;\n\n\t\t}\n\n\t\tconst p1 = points[ intPoint % l ];\n\t\tconst p2 = points[ ( intPoint + 1 ) % l ];\n\n\t\tif ( this.closed || intPoint + 2 < l ) {\n\n\t\t\tp3 = points[ ( intPoint + 2 ) % l ];\n\n\t\t} else {\n\n\t\t\t// extrapolate last point\n\t\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\n\t\t\tp3 = tmp;\n\n\t\t}\n\n\t\tif ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {\n\n\t\t\t// init Centripetal / Chordal Catmull-Rom\n\t\t\tconst pow = this.curveType === 'chordal' ? 0.5 : 0.25;\n\t\t\tlet dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\n\t\t\tlet dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\n\t\t\tlet dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\n\n\t\t\t// safety check for repeated points\n\t\t\tif ( dt1 < 1e-4 ) dt1 = 1.0;\n\t\t\tif ( dt0 < 1e-4 ) dt0 = dt1;\n\t\t\tif ( dt2 < 1e-4 ) dt2 = dt1;\n\n\t\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\n\t\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\n\t\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\n\n\t\t} else if ( this.curveType === 'catmullrom' ) {\n\n\t\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );\n\t\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );\n\t\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );\n\n\t\t}\n\n\t\tpoint.set(\n\t\t\tpx.calc( weight ),\n\t\t\tpy.calc( weight ),\n\t\t\tpz.calc( weight )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.points = [];\n\n\t\tfor ( let i = 0, l = source.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = source.points[ i ];\n\n\t\t\tthis.points.push( point.clone() );\n\n\t\t}\n\n\t\tthis.closed = source.closed;\n\t\tthis.curveType = source.curveType;\n\t\tthis.tension = source.tension;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.points = [];\n\n\t\tfor ( let i = 0, l = this.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = this.points[ i ];\n\t\t\tdata.points.push( point.toArray() );\n\n\t\t}\n\n\t\tdata.closed = this.closed;\n\t\tdata.curveType = this.curveType;\n\t\tdata.tension = this.tension;\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.points = [];\n\n\t\tfor ( let i = 0, l = json.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = json.points[ i ];\n\t\t\tthis.points.push( new Vector3().fromArray( point ) );\n\n\t\t}\n\n\t\tthis.closed = json.closed;\n\t\tthis.curveType = json.curveType;\n\t\tthis.tension = json.tension;\n\n\t\treturn this;\n\n\t}\n\n}\n\n/**\n * Bezier Curves formulas obtained from\n * https://en.wikipedia.org/wiki/B%C3%A9zier_curve\n */\n\nfunction CatmullRom( t, p0, p1, p2, p3 ) {\n\n\tconst v0 = ( p2 - p0 ) * 0.5;\n\tconst v1 = ( p3 - p1 ) * 0.5;\n\tconst t2 = t * t;\n\tconst t3 = t * t2;\n\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n}\n\n//\n\nfunction QuadraticBezierP0( t, p ) {\n\n\tconst k = 1 - t;\n\treturn k * k * p;\n\n}\n\nfunction QuadraticBezierP1( t, p ) {\n\n\treturn 2 * ( 1 - t ) * t * p;\n\n}\n\nfunction QuadraticBezierP2( t, p ) {\n\n\treturn t * t * p;\n\n}\n\nfunction QuadraticBezier( t, p0, p1, p2 ) {\n\n\treturn QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +\n\t\tQuadraticBezierP2( t, p2 );\n\n}\n\n//\n\nfunction CubicBezierP0( t, p ) {\n\n\tconst k = 1 - t;\n\treturn k * k * k * p;\n\n}\n\nfunction CubicBezierP1( t, p ) {\n\n\tconst k = 1 - t;\n\treturn 3 * k * k * t * p;\n\n}\n\nfunction CubicBezierP2( t, p ) {\n\n\treturn 3 * ( 1 - t ) * t * t * p;\n\n}\n\nfunction CubicBezierP3( t, p ) {\n\n\treturn t * t * t * p;\n\n}\n\nfunction CubicBezier( t, p0, p1, p2, p3 ) {\n\n\treturn CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +\n\t\tCubicBezierP3( t, p3 );\n\n}\n\nclass CubicBezierCurve extends Curve {\n\n\tconstructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2() ) {\n\n\t\tsuper();\n\n\t\tthis.isCubicBezierCurve = true;\n\n\t\tthis.type = 'CubicBezierCurve';\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\n\n\t\tpoint.set(\n\t\t\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\n\t\t\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\t\tthis.v3.copy( source.v3 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\t\tdata.v3 = this.v3.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\t\tthis.v3.fromArray( json.v3 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass CubicBezierCurve3 extends Curve {\n\n\tconstructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3() ) {\n\n\t\tsuper();\n\n\t\tthis.isCubicBezierCurve3 = true;\n\n\t\tthis.type = 'CubicBezierCurve3';\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\n\n\t\tpoint.set(\n\t\t\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\n\t\t\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y ),\n\t\t\tCubicBezier( t, v0.z, v1.z, v2.z, v3.z )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\t\tthis.v3.copy( source.v3 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\t\tdata.v3 = this.v3.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\t\tthis.v3.fromArray( json.v3 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass LineCurve extends Curve {\n\n\tconstructor( v1 = new Vector2(), v2 = new Vector2() ) {\n\n\t\tsuper();\n\n\t\tthis.isLineCurve = true;\n\n\t\tthis.type = 'LineCurve';\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tif ( t === 1 ) {\n\n\t\t\tpoint.copy( this.v2 );\n\n\t\t} else {\n\n\t\t\tpoint.copy( this.v2 ).sub( this.v1 );\n\t\t\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\t\t}\n\n\t\treturn point;\n\n\t}\n\n\t// Line curve is linear, so we can overwrite default getPointAt\n\tgetPointAt( u, optionalTarget ) {\n\n\t\treturn this.getPoint( u, optionalTarget );\n\n\t}\n\n\tgetTangent( t, optionalTarget = new Vector2() ) {\n\n\t\treturn optionalTarget.subVectors( this.v2, this.v1 ).normalize();\n\n\t}\n\n\tgetTangentAt( u, optionalTarget ) {\n\n\t\treturn this.getTangent( u, optionalTarget );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass LineCurve3 extends Curve {\n\n\tconstructor( v1 = new Vector3(), v2 = new Vector3() ) {\n\n\t\tsuper();\n\n\t\tthis.isLineCurve3 = true;\n\n\t\tthis.type = 'LineCurve3';\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tif ( t === 1 ) {\n\n\t\t\tpoint.copy( this.v2 );\n\n\t\t} else {\n\n\t\t\tpoint.copy( this.v2 ).sub( this.v1 );\n\t\t\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\t\t}\n\n\t\treturn point;\n\n\t}\n\n\t// Line curve is linear, so we can overwrite default getPointAt\n\tgetPointAt( u, optionalTarget ) {\n\n\t\treturn this.getPoint( u, optionalTarget );\n\n\t}\n\n\tgetTangent( t, optionalTarget = new Vector3() ) {\n\n\t\treturn optionalTarget.subVectors( this.v2, this.v1 ).normalize();\n\n\t}\n\n\tgetTangentAt( u, optionalTarget ) {\n\n\t\treturn this.getTangent( u, optionalTarget );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass QuadraticBezierCurve extends Curve {\n\n\tconstructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2() ) {\n\n\t\tsuper();\n\n\t\tthis.isQuadraticBezierCurve = true;\n\n\t\tthis.type = 'QuadraticBezierCurve';\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst v0 = this.v0, v1 = this.v1, v2 = this.v2;\n\n\t\tpoint.set(\n\t\t\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\n\t\t\tQuadraticBezier( t, v0.y, v1.y, v2.y )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass QuadraticBezierCurve3 extends Curve {\n\n\tconstructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3() ) {\n\n\t\tsuper();\n\n\t\tthis.isQuadraticBezierCurve3 = true;\n\n\t\tthis.type = 'QuadraticBezierCurve3';\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst v0 = this.v0, v1 = this.v1, v2 = this.v2;\n\n\t\tpoint.set(\n\t\t\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\n\t\t\tQuadraticBezier( t, v0.y, v1.y, v2.y ),\n\t\t\tQuadraticBezier( t, v0.z, v1.z, v2.z )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass SplineCurve extends Curve {\n\n\tconstructor( points = [] ) {\n\n\t\tsuper();\n\n\t\tthis.isSplineCurve = true;\n\n\t\tthis.type = 'SplineCurve';\n\n\t\tthis.points = points;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst points = this.points;\n\t\tconst p = ( points.length - 1 ) * t;\n\n\t\tconst intPoint = Math.floor( p );\n\t\tconst weight = p - intPoint;\n\n\t\tconst p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\n\t\tconst p1 = points[ intPoint ];\n\t\tconst p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\t\tconst p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\n\t\tpoint.set(\n\t\t\tCatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),\n\t\t\tCatmullRom( weight, p0.y, p1.y, p2.y, p3.y )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.points = [];\n\n\t\tfor ( let i = 0, l = source.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = source.points[ i ];\n\n\t\t\tthis.points.push( point.clone() );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.points = [];\n\n\t\tfor ( let i = 0, l = this.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = this.points[ i ];\n\t\t\tdata.points.push( point.toArray() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.points = [];\n\n\t\tfor ( let i = 0, l = json.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = json.points[ i ];\n\t\t\tthis.points.push( new Vector2().fromArray( point ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nvar Curves = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tArcCurve: ArcCurve,\n\tCatmullRomCurve3: CatmullRomCurve3,\n\tCubicBezierCurve: CubicBezierCurve,\n\tCubicBezierCurve3: CubicBezierCurve3,\n\tEllipseCurve: EllipseCurve,\n\tLineCurve: LineCurve,\n\tLineCurve3: LineCurve3,\n\tQuadraticBezierCurve: QuadraticBezierCurve,\n\tQuadraticBezierCurve3: QuadraticBezierCurve3,\n\tSplineCurve: SplineCurve\n});\n\n/**************************************************************\n *\tCurved Path - a curve path is simply a array of connected\n *  curves, but retains the api of a curve\n **************************************************************/\n\nclass CurvePath extends Curve {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.type = 'CurvePath';\n\n\t\tthis.curves = [];\n\t\tthis.autoClose = false; // Automatically closes the path\n\n\t}\n\n\tadd( curve ) {\n\n\t\tthis.curves.push( curve );\n\n\t}\n\n\tclosePath() {\n\n\t\t// Add a line curve if start and end of lines are not connected\n\t\tconst startPoint = this.curves[ 0 ].getPoint( 0 );\n\t\tconst endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\n\n\t\tif ( ! startPoint.equals( endPoint ) ) {\n\n\t\t\tconst lineType = ( startPoint.isVector2 === true ) ? 'LineCurve' : 'LineCurve3';\n\t\t\tthis.curves.push( new Curves[ lineType ]( endPoint, startPoint ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// To get accurate point with reference to\n\t// entire path distance at time t,\n\t// following has to be done:\n\n\t// 1. Length of each sub path have to be known\n\t// 2. Locate and identify type of curve\n\t// 3. Get t for the curve\n\t// 4. Return curve.getPointAt(t')\n\n\tgetPoint( t, optionalTarget ) {\n\n\t\tconst d = t * this.getLength();\n\t\tconst curveLengths = this.getCurveLengths();\n\t\tlet i = 0;\n\n\t\t// To think about boundaries points.\n\n\t\twhile ( i < curveLengths.length ) {\n\n\t\t\tif ( curveLengths[ i ] >= d ) {\n\n\t\t\t\tconst diff = curveLengths[ i ] - d;\n\t\t\t\tconst curve = this.curves[ i ];\n\n\t\t\t\tconst segmentLength = curve.getLength();\n\t\t\t\tconst u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n\n\t\t\t\treturn curve.getPointAt( u, optionalTarget );\n\n\t\t\t}\n\n\t\t\ti ++;\n\n\t\t}\n\n\t\treturn null;\n\n\t\t// loop where sum != 0, sum > d , sum+1 <d\n\n\t}\n\n\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\n\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\t// getPoint() depends on getLength\n\n\tgetLength() {\n\n\t\tconst lens = this.getCurveLengths();\n\t\treturn lens[ lens.length - 1 ];\n\n\t}\n\n\t// cacheLengths must be recalculated.\n\tupdateArcLengths() {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.cacheLengths = null;\n\t\tthis.getCurveLengths();\n\n\t}\n\n\t// Compute lengths and cache them\n\t// We cannot overwrite getLengths() because UtoT mapping uses it.\n\n\tgetCurveLengths() {\n\n\t\t// We use cache values if curves and cache array are same length\n\n\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\n\n\t\t\treturn this.cacheLengths;\n\n\t\t}\n\n\t\t// Get length of sub-curve\n\t\t// Push sums into cached array\n\n\t\tconst lengths = [];\n\t\tlet sums = 0;\n\n\t\tfor ( let i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\tsums += this.curves[ i ].getLength();\n\t\t\tlengths.push( sums );\n\n\t\t}\n\n\t\tthis.cacheLengths = lengths;\n\n\t\treturn lengths;\n\n\t}\n\n\tgetSpacedPoints( divisions = 40 ) {\n\n\t\tconst points = [];\n\n\t\tfor ( let i = 0; i <= divisions; i ++ ) {\n\n\t\t\tpoints.push( this.getPoint( i / divisions ) );\n\n\t\t}\n\n\t\tif ( this.autoClose ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\tgetPoints( divisions = 12 ) {\n\n\t\tconst points = [];\n\t\tlet last;\n\n\t\tfor ( let i = 0, curves = this.curves; i < curves.length; i ++ ) {\n\n\t\t\tconst curve = curves[ i ];\n\t\t\tconst resolution = curve.isEllipseCurve ? divisions * 2\n\t\t\t\t: ( curve.isLineCurve || curve.isLineCurve3 ) ? 1\n\t\t\t\t\t: curve.isSplineCurve ? divisions * curve.points.length\n\t\t\t\t\t\t: divisions;\n\n\t\t\tconst pts = curve.getPoints( resolution );\n\n\t\t\tfor ( let j = 0; j < pts.length; j ++ ) {\n\n\t\t\t\tconst point = pts[ j ];\n\n\t\t\t\tif ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates\n\n\t\t\t\tpoints.push( point );\n\t\t\t\tlast = point;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.curves = [];\n\n\t\tfor ( let i = 0, l = source.curves.length; i < l; i ++ ) {\n\n\t\t\tconst curve = source.curves[ i ];\n\n\t\t\tthis.curves.push( curve.clone() );\n\n\t\t}\n\n\t\tthis.autoClose = source.autoClose;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.autoClose = this.autoClose;\n\t\tdata.curves = [];\n\n\t\tfor ( let i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\tconst curve = this.curves[ i ];\n\t\t\tdata.curves.push( curve.toJSON() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.autoClose = json.autoClose;\n\t\tthis.curves = [];\n\n\t\tfor ( let i = 0, l = json.curves.length; i < l; i ++ ) {\n\n\t\t\tconst curve = json.curves[ i ];\n\t\t\tthis.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass Path extends CurvePath {\n\n\tconstructor( points ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'Path';\n\n\t\tthis.currentPoint = new Vector2();\n\n\t\tif ( points ) {\n\n\t\t\tthis.setFromPoints( points );\n\n\t\t}\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tthis.moveTo( points[ 0 ].x, points[ 0 ].y );\n\n\t\tfor ( let i = 1, l = points.length; i < l; i ++ ) {\n\n\t\t\tthis.lineTo( points[ i ].x, points[ i ].y );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tmoveTo( x, y ) {\n\n\t\tthis.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?\n\n\t\treturn this;\n\n\t}\n\n\tlineTo( x, y ) {\n\n\t\tconst curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( x, y );\n\n\t\treturn this;\n\n\t}\n\n\tquadraticCurveTo( aCPx, aCPy, aX, aY ) {\n\n\t\tconst curve = new QuadraticBezierCurve(\n\t\t\tthis.currentPoint.clone(),\n\t\t\tnew Vector2( aCPx, aCPy ),\n\t\t\tnew Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\tbezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\tconst curve = new CubicBezierCurve(\n\t\t\tthis.currentPoint.clone(),\n\t\t\tnew Vector2( aCP1x, aCP1y ),\n\t\t\tnew Vector2( aCP2x, aCP2y ),\n\t\t\tnew Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\tsplineThru( pts /*Array of Vector*/ ) {\n\n\t\tconst npts = [ this.currentPoint.clone() ].concat( pts );\n\n\t\tconst curve = new SplineCurve( npts );\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.copy( pts[ pts.length - 1 ] );\n\n\t\treturn this;\n\n\t}\n\n\tarc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tconst x0 = this.currentPoint.x;\n\t\tconst y0 = this.currentPoint.y;\n\n\t\tthis.absarc( aX + x0, aY + y0, aRadius,\n\t\t\taStartAngle, aEndAngle, aClockwise );\n\n\t\treturn this;\n\n\t}\n\n\tabsarc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t\treturn this;\n\n\t}\n\n\tellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tconst x0 = this.currentPoint.x;\n\t\tconst y0 = this.currentPoint.y;\n\n\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t\treturn this;\n\n\t}\n\n\tabsellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tconst curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t\tif ( this.curves.length > 0 ) {\n\n\t\t\t// if a previous curve is present, attempt to join\n\t\t\tconst firstPoint = curve.getPoint( 0 );\n\n\t\t\tif ( ! firstPoint.equals( this.currentPoint ) ) {\n\n\t\t\t\tthis.lineTo( firstPoint.x, firstPoint.y );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.curves.push( curve );\n\n\t\tconst lastPoint = curve.getPoint( 1 );\n\t\tthis.currentPoint.copy( lastPoint );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.currentPoint.copy( source.currentPoint );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.currentPoint = this.currentPoint.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.currentPoint.fromArray( json.currentPoint );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass LatheGeometry extends BufferGeometry {\n\n\tconstructor( points = [ new Vector2( 0, - 0.5 ), new Vector2( 0.5, 0 ), new Vector2( 0, 0.5 ) ], segments = 12, phiStart = 0, phiLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'LatheGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpoints: points,\n\t\t\tsegments: segments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength\n\t\t};\n\n\t\tsegments = Math.floor( segments );\n\n\t\t// clamp phiLength so it's in range of [ 0, 2PI ]\n\n\t\tphiLength = clamp( phiLength, 0, Math.PI * 2 );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst uvs = [];\n\t\tconst initNormals = [];\n\t\tconst normals = [];\n\n\t\t// helper variables\n\n\t\tconst inverseSegments = 1.0 / segments;\n\t\tconst vertex = new Vector3();\n\t\tconst uv = new Vector2();\n\t\tconst normal = new Vector3();\n\t\tconst curNormal = new Vector3();\n\t\tconst prevNormal = new Vector3();\n\t\tlet dx = 0;\n\t\tlet dy = 0;\n\n\t\t// pre-compute normals for initial \"meridian\"\n\n\t\tfor ( let j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\tswitch ( j ) {\n\n\t\t\t\tcase 0:\t\t\t\t// special handling for 1st vertex on path\n\n\t\t\t\t\tdx = points[ j + 1 ].x - points[ j ].x;\n\t\t\t\t\tdy = points[ j + 1 ].y - points[ j ].y;\n\n\t\t\t\t\tnormal.x = dy * 1.0;\n\t\t\t\t\tnormal.y = - dx;\n\t\t\t\t\tnormal.z = dy * 0.0;\n\n\t\t\t\t\tprevNormal.copy( normal );\n\n\t\t\t\t\tnormal.normalize();\n\n\t\t\t\t\tinitNormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ( points.length - 1 ):\t// special handling for last Vertex on path\n\n\t\t\t\t\tinitNormals.push( prevNormal.x, prevNormal.y, prevNormal.z );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\t\t\t// default handling for all vertices in between\n\n\t\t\t\t\tdx = points[ j + 1 ].x - points[ j ].x;\n\t\t\t\t\tdy = points[ j + 1 ].y - points[ j ].y;\n\n\t\t\t\t\tnormal.x = dy * 1.0;\n\t\t\t\t\tnormal.y = - dx;\n\t\t\t\t\tnormal.z = dy * 0.0;\n\n\t\t\t\t\tcurNormal.copy( normal );\n\n\t\t\t\t\tnormal.x += prevNormal.x;\n\t\t\t\t\tnormal.y += prevNormal.y;\n\t\t\t\t\tnormal.z += prevNormal.z;\n\n\t\t\t\t\tnormal.normalize();\n\n\t\t\t\t\tinitNormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t\tprevNormal.copy( curNormal );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate vertices, uvs and normals\n\n\t\tfor ( let i = 0; i <= segments; i ++ ) {\n\n\t\t\tconst phi = phiStart + i * inverseSegments * phiLength;\n\n\t\t\tconst sin = Math.sin( phi );\n\t\t\tconst cos = Math.cos( phi );\n\n\t\t\tfor ( let j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = points[ j ].x * sin;\n\t\t\t\tvertex.y = points[ j ].y;\n\t\t\t\tvertex.z = points[ j ].x * cos;\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuv.x = i / segments;\n\t\t\t\tuv.y = j / ( points.length - 1 );\n\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t// normal\n\n\t\t\t\tconst x = initNormals[ 3 * j + 0 ] * sin;\n\t\t\t\tconst y = initNormals[ 3 * j + 1 ];\n\t\t\t\tconst z = initNormals[ 3 * j + 0 ] * cos;\n\n\t\t\t\tnormals.push( x, y, z );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let i = 0; i < segments; i ++ ) {\n\n\t\t\tfor ( let j = 0; j < ( points.length - 1 ); j ++ ) {\n\n\t\t\t\tconst base = j + i * points.length;\n\n\t\t\t\tconst a = base;\n\t\t\t\tconst b = base + points.length;\n\t\t\t\tconst c = base + points.length + 1;\n\t\t\t\tconst d = base + 1;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( c, d, b );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new LatheGeometry( data.points, data.segments, data.phiStart, data.phiLength );\n\n\t}\n\n}\n\nclass CapsuleGeometry extends LatheGeometry {\n\n\tconstructor( radius = 1, length = 1, capSegments = 4, radialSegments = 8 ) {\n\n\t\tconst path = new Path();\n\t\tpath.absarc( 0, - length / 2, radius, Math.PI * 1.5, 0 );\n\t\tpath.absarc( 0, length / 2, radius, 0, Math.PI * 0.5 );\n\n\t\tsuper( path.getPoints( capSegments ), radialSegments );\n\n\t\tthis.type = 'CapsuleGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tlength: length,\n\t\t\tcapSegments: capSegments,\n\t\t\tradialSegments: radialSegments,\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new CapsuleGeometry( data.radius, data.length, data.capSegments, data.radialSegments );\n\n\t}\n\n}\n\nclass CircleGeometry extends BufferGeometry {\n\n\tconstructor( radius = 1, segments = 32, thetaStart = 0, thetaLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CircleGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tsegments: segments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tsegments = Math.max( 3, segments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tconst vertex = new Vector3();\n\t\tconst uv = new Vector2();\n\n\t\t// center point\n\n\t\tvertices.push( 0, 0, 0 );\n\t\tnormals.push( 0, 0, 1 );\n\t\tuvs.push( 0.5, 0.5 );\n\n\t\tfor ( let s = 0, i = 3; s <= segments; s ++, i += 3 ) {\n\n\t\t\tconst segment = thetaStart + s / segments * thetaLength;\n\n\t\t\t// vertex\n\n\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\tvertex.y = radius * Math.sin( segment );\n\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal\n\n\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t// uvs\n\n\t\t\tuv.x = ( vertices[ i ] / radius + 1 ) / 2;\n\t\t\tuv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;\n\n\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let i = 1; i <= segments; i ++ ) {\n\n\t\t\tindices.push( i, i + 1, 0 );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new CircleGeometry( data.radius, data.segments, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nclass CylinderGeometry extends BufferGeometry {\n\n\tconstructor( radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CylinderGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradiusTop: radiusTop,\n\t\t\tradiusBottom: radiusBottom,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tconst scope = this;\n\n\t\tradialSegments = Math.floor( radialSegments );\n\t\theightSegments = Math.floor( heightSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tlet index = 0;\n\t\tconst indexArray = [];\n\t\tconst halfHeight = height / 2;\n\t\tlet groupStart = 0;\n\n\t\t// generate geometry\n\n\t\tgenerateTorso();\n\n\t\tif ( openEnded === false ) {\n\n\t\t\tif ( radiusTop > 0 ) generateCap( true );\n\t\t\tif ( radiusBottom > 0 ) generateCap( false );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\tfunction generateTorso() {\n\n\t\t\tconst normal = new Vector3();\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tlet groupCount = 0;\n\n\t\t\t// this will be used to calculate the normal\n\t\t\tconst slope = ( radiusBottom - radiusTop ) / height;\n\n\t\t\t// generate vertices, normals and uvs\n\n\t\t\tfor ( let y = 0; y <= heightSegments; y ++ ) {\n\n\t\t\t\tconst indexRow = [];\n\n\t\t\t\tconst v = y / heightSegments;\n\n\t\t\t\t// calculate the radius of the current row\n\n\t\t\t\tconst radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\n\t\t\t\tfor ( let x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\t\tconst u = x / radialSegments;\n\n\t\t\t\t\tconst theta = u * thetaLength + thetaStart;\n\n\t\t\t\t\tconst sinTheta = Math.sin( theta );\n\t\t\t\t\tconst cosTheta = Math.cos( theta );\n\n\t\t\t\t\t// vertex\n\n\t\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\t\tvertex.y = - v * height + halfHeight;\n\t\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t\t// normal\n\n\t\t\t\t\tnormal.set( sinTheta, slope, cosTheta ).normalize();\n\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t\t// uv\n\n\t\t\t\t\tuvs.push( u, 1 - v );\n\n\t\t\t\t\t// save index of vertex in respective row\n\n\t\t\t\t\tindexRow.push( index ++ );\n\n\t\t\t\t}\n\n\t\t\t\t// now save vertices of the row in our index array\n\n\t\t\t\tindexArray.push( indexRow );\n\n\t\t\t}\n\n\t\t\t// generate indices\n\n\t\t\tfor ( let x = 0; x < radialSegments; x ++ ) {\n\n\t\t\t\tfor ( let y = 0; y < heightSegments; y ++ ) {\n\n\t\t\t\t\t// we use the index array to access the correct indices\n\n\t\t\t\t\tconst a = indexArray[ y ][ x ];\n\t\t\t\t\tconst b = indexArray[ y + 1 ][ x ];\n\t\t\t\t\tconst c = indexArray[ y + 1 ][ x + 1 ];\n\t\t\t\t\tconst d = indexArray[ y ][ x + 1 ];\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tif ( radiusTop > 0 || y !== 0 ) {\n\n\t\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\t\tgroupCount += 3;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( radiusBottom > 0 || y !== heightSegments - 1 ) {\n\n\t\t\t\t\t\tindices.push( b, c, d );\n\t\t\t\t\t\tgroupCount += 3;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, 0 );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t}\n\n\t\tfunction generateCap( top ) {\n\n\t\t\t// save the index of the first center vertex\n\t\t\tconst centerIndexStart = index;\n\n\t\t\tconst uv = new Vector2();\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tlet groupCount = 0;\n\n\t\t\tconst radius = ( top === true ) ? radiusTop : radiusBottom;\n\t\t\tconst sign = ( top === true ) ? 1 : - 1;\n\n\t\t\t// first we generate the center vertex data of the cap.\n\t\t\t// because the geometry needs one set of uvs per face,\n\t\t\t// we must generate a center vertex per face/segment\n\n\t\t\tfor ( let x = 1; x <= radialSegments; x ++ ) {\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertices.push( 0, halfHeight * sign, 0 );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormals.push( 0, sign, 0 );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( 0.5, 0.5 );\n\n\t\t\t\t// increase index\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// save the index of the last center vertex\n\t\t\tconst centerIndexEnd = index;\n\n\t\t\t// now we generate the surrounding vertices, normals and uvs\n\n\t\t\tfor ( let x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\tconst u = x / radialSegments;\n\t\t\t\tconst theta = u * thetaLength + thetaStart;\n\n\t\t\t\tconst cosTheta = Math.cos( theta );\n\t\t\t\tconst sinTheta = Math.sin( theta );\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\tvertex.y = halfHeight * sign;\n\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormals.push( 0, sign, 0 );\n\n\t\t\t\t// uv\n\n\t\t\t\tuv.x = ( cosTheta * 0.5 ) + 0.5;\n\t\t\t\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t// increase index\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// generate indices\n\n\t\t\tfor ( let x = 0; x < radialSegments; x ++ ) {\n\n\t\t\t\tconst c = centerIndexStart + x;\n\t\t\t\tconst i = centerIndexEnd + x;\n\n\t\t\t\tif ( top === true ) {\n\n\t\t\t\t\t// face top\n\n\t\t\t\t\tindices.push( i, i + 1, c );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// face bottom\n\n\t\t\t\t\tindices.push( i + 1, i, c );\n\n\t\t\t\t}\n\n\t\t\t\tgroupCount += 3;\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new CylinderGeometry( data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nclass ConeGeometry extends CylinderGeometry {\n\n\tconstructor( radius = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {\n\n\t\tsuper( 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\n\n\t\tthis.type = 'ConeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new ConeGeometry( data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nclass PolyhedronGeometry extends BufferGeometry {\n\n\tconstructor( vertices = [], indices = [], radius = 1, detail = 0 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'PolyhedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tvertices: vertices,\n\t\t\tindices: indices,\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\t// default buffer data\n\n\t\tconst vertexBuffer = [];\n\t\tconst uvBuffer = [];\n\n\t\t// the subdivision creates the vertex buffer data\n\n\t\tsubdivide( detail );\n\n\t\t// all vertices should lie on a conceptual sphere with a given radius\n\n\t\tapplyRadius( radius );\n\n\t\t// finally, create the uv data\n\n\t\tgenerateUVs();\n\n\t\t// build non-indexed geometry\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );\n\n\t\tif ( detail === 0 ) {\n\n\t\t\tthis.computeVertexNormals(); // flat normals\n\n\t\t} else {\n\n\t\t\tthis.normalizeNormals(); // smooth normals\n\n\t\t}\n\n\t\t// helper functions\n\n\t\tfunction subdivide( detail ) {\n\n\t\t\tconst a = new Vector3();\n\t\t\tconst b = new Vector3();\n\t\t\tconst c = new Vector3();\n\n\t\t\t// iterate over all faces and apply a subdivision with the given detail value\n\n\t\t\tfor ( let i = 0; i < indices.length; i += 3 ) {\n\n\t\t\t\t// get the vertices of the face\n\n\t\t\t\tgetVertexByIndex( indices[ i + 0 ], a );\n\t\t\t\tgetVertexByIndex( indices[ i + 1 ], b );\n\t\t\t\tgetVertexByIndex( indices[ i + 2 ], c );\n\n\t\t\t\t// perform subdivision\n\n\t\t\t\tsubdivideFace( a, b, c, detail );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction subdivideFace( a, b, c, detail ) {\n\n\t\t\tconst cols = detail + 1;\n\n\t\t\t// we use this multidimensional array as a data structure for creating the subdivision\n\n\t\t\tconst v = [];\n\n\t\t\t// construct all of the vertices for this subdivision\n\n\t\t\tfor ( let i = 0; i <= cols; i ++ ) {\n\n\t\t\t\tv[ i ] = [];\n\n\t\t\t\tconst aj = a.clone().lerp( c, i / cols );\n\t\t\t\tconst bj = b.clone().lerp( c, i / cols );\n\n\t\t\t\tconst rows = cols - i;\n\n\t\t\t\tfor ( let j = 0; j <= rows; j ++ ) {\n\n\t\t\t\t\tif ( j === 0 && i === cols ) {\n\n\t\t\t\t\t\tv[ i ][ j ] = aj;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv[ i ][ j ] = aj.clone().lerp( bj, j / rows );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// construct all of the faces\n\n\t\t\tfor ( let i = 0; i < cols; i ++ ) {\n\n\t\t\t\tfor ( let j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\n\n\t\t\t\t\tconst k = Math.floor( j / 2 );\n\n\t\t\t\t\tif ( j % 2 === 0 ) {\n\n\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\t\t\t\t\t\tpushVertex( v[ i ][ k ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction applyRadius( radius ) {\n\n\t\t\tconst vertex = new Vector3();\n\n\t\t\t// iterate over the entire buffer and apply the radius to each vertex\n\n\t\t\tfor ( let i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\t\tvertex.normalize().multiplyScalar( radius );\n\n\t\t\t\tvertexBuffer[ i + 0 ] = vertex.x;\n\t\t\t\tvertexBuffer[ i + 1 ] = vertex.y;\n\t\t\t\tvertexBuffer[ i + 2 ] = vertex.z;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateUVs() {\n\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tfor ( let i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\t\tconst u = azimuth( vertex ) / 2 / Math.PI + 0.5;\n\t\t\t\tconst v = inclination( vertex ) / Math.PI + 0.5;\n\t\t\t\tuvBuffer.push( u, 1 - v );\n\n\t\t\t}\n\n\t\t\tcorrectUVs();\n\n\t\t\tcorrectSeam();\n\n\t\t}\n\n\t\tfunction correctSeam() {\n\n\t\t\t// handle case when face straddles the seam, see #3269\n\n\t\t\tfor ( let i = 0; i < uvBuffer.length; i += 6 ) {\n\n\t\t\t\t// uv data of a single face\n\n\t\t\t\tconst x0 = uvBuffer[ i + 0 ];\n\t\t\t\tconst x1 = uvBuffer[ i + 2 ];\n\t\t\t\tconst x2 = uvBuffer[ i + 4 ];\n\n\t\t\t\tconst max = Math.max( x0, x1, x2 );\n\t\t\t\tconst min = Math.min( x0, x1, x2 );\n\n\t\t\t\t// 0.9 is somewhat arbitrary\n\n\t\t\t\tif ( max > 0.9 && min < 0.1 ) {\n\n\t\t\t\t\tif ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;\n\t\t\t\t\tif ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;\n\t\t\t\t\tif ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction pushVertex( vertex ) {\n\n\t\t\tvertexBuffer.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t\tfunction getVertexByIndex( index, vertex ) {\n\n\t\t\tconst stride = index * 3;\n\n\t\t\tvertex.x = vertices[ stride + 0 ];\n\t\t\tvertex.y = vertices[ stride + 1 ];\n\t\t\tvertex.z = vertices[ stride + 2 ];\n\n\t\t}\n\n\t\tfunction correctUVs() {\n\n\t\t\tconst a = new Vector3();\n\t\t\tconst b = new Vector3();\n\t\t\tconst c = new Vector3();\n\n\t\t\tconst centroid = new Vector3();\n\n\t\t\tconst uvA = new Vector2();\n\t\t\tconst uvB = new Vector2();\n\t\t\tconst uvC = new Vector2();\n\n\t\t\tfor ( let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {\n\n\t\t\t\ta.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );\n\t\t\t\tb.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );\n\t\t\t\tc.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );\n\n\t\t\t\tuvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );\n\t\t\t\tuvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );\n\t\t\t\tuvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );\n\n\t\t\t\tcentroid.copy( a ).add( b ).add( c ).divideScalar( 3 );\n\n\t\t\t\tconst azi = azimuth( centroid );\n\n\t\t\t\tcorrectUV( uvA, j + 0, a, azi );\n\t\t\t\tcorrectUV( uvB, j + 2, b, azi );\n\t\t\t\tcorrectUV( uvC, j + 4, c, azi );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction correctUV( uv, stride, vector, azimuth ) {\n\n\t\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {\n\n\t\t\t\tuvBuffer[ stride ] = uv.x - 1;\n\n\t\t\t}\n\n\t\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {\n\n\t\t\t\tuvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Angle around the Y axis, counter-clockwise when looking from above.\n\n\t\tfunction azimuth( vector ) {\n\n\t\t\treturn Math.atan2( vector.z, - vector.x );\n\n\t\t}\n\n\n\t\t// Angle above the XZ plane.\n\n\t\tfunction inclination( vector ) {\n\n\t\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new PolyhedronGeometry( data.vertices, data.indices, data.radius, data.details );\n\n\t}\n\n}\n\nclass DodecahedronGeometry extends PolyhedronGeometry {\n\n\tconstructor( radius = 1, detail = 0 ) {\n\n\t\tconst t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\t\tconst r = 1 / t;\n\n\t\tconst vertices = [\n\n\t\t\t// (±1, ±1, ±1)\n\t\t\t- 1, - 1, - 1,\t- 1, - 1, 1,\n\t\t\t- 1, 1, - 1, - 1, 1, 1,\n\t\t\t1, - 1, - 1, 1, - 1, 1,\n\t\t\t1, 1, - 1, 1, 1, 1,\n\n\t\t\t// (0, ±1/φ, ±φ)\n\t\t\t0, - r, - t, 0, - r, t,\n\t\t\t0, r, - t, 0, r, t,\n\n\t\t\t// (±1/φ, ±φ, 0)\n\t\t\t- r, - t, 0, - r, t, 0,\n\t\t\tr, - t, 0, r, t, 0,\n\n\t\t\t// (±φ, 0, ±1/φ)\n\t\t\t- t, 0, - r, t, 0, - r,\n\t\t\t- t, 0, r, t, 0, r\n\t\t];\n\n\t\tconst indices = [\n\t\t\t3, 11, 7, \t3, 7, 15, \t3, 15, 13,\n\t\t\t7, 19, 17, \t7, 17, 6, \t7, 6, 15,\n\t\t\t17, 4, 8, \t17, 8, 10, \t17, 10, 6,\n\t\t\t8, 0, 16, \t8, 16, 2, \t8, 2, 10,\n\t\t\t0, 12, 1, \t0, 1, 18, \t0, 18, 16,\n\t\t\t6, 10, 2, \t6, 2, 13, \t6, 13, 15,\n\t\t\t2, 16, 18, \t2, 18, 3, \t2, 3, 13,\n\t\t\t18, 1, 9, \t18, 9, 11, \t18, 11, 3,\n\t\t\t4, 14, 12, \t4, 12, 0, \t4, 0, 8,\n\t\t\t11, 9, 5, \t11, 5, 19, \t11, 19, 7,\n\t\t\t19, 5, 14, \t19, 14, 4, \t19, 4, 17,\n\t\t\t1, 12, 14, \t1, 14, 5, \t1, 5, 9\n\t\t];\n\n\t\tsuper( vertices, indices, radius, detail );\n\n\t\tthis.type = 'DodecahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new DodecahedronGeometry( data.radius, data.detail );\n\n\t}\n\n}\n\nconst _v0 = /*@__PURE__*/ new Vector3();\nconst _v1$1 = /*@__PURE__*/ new Vector3();\nconst _normal = /*@__PURE__*/ new Vector3();\nconst _triangle = /*@__PURE__*/ new Triangle();\n\nclass EdgesGeometry extends BufferGeometry {\n\n\tconstructor( geometry = null, thresholdAngle = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'EdgesGeometry';\n\n\t\tthis.parameters = {\n\t\t\tgeometry: geometry,\n\t\t\tthresholdAngle: thresholdAngle\n\t\t};\n\n\t\tif ( geometry !== null ) {\n\n\t\t\tconst precisionPoints = 4;\n\t\t\tconst precision = Math.pow( 10, precisionPoints );\n\t\t\tconst thresholdDot = Math.cos( DEG2RAD * thresholdAngle );\n\n\t\t\tconst indexAttr = geometry.getIndex();\n\t\t\tconst positionAttr = geometry.getAttribute( 'position' );\n\t\t\tconst indexCount = indexAttr ? indexAttr.count : positionAttr.count;\n\n\t\t\tconst indexArr = [ 0, 0, 0 ];\n\t\t\tconst vertKeys = [ 'a', 'b', 'c' ];\n\t\t\tconst hashes = new Array( 3 );\n\n\t\t\tconst edgeData = {};\n\t\t\tconst vertices = [];\n\t\t\tfor ( let i = 0; i < indexCount; i += 3 ) {\n\n\t\t\t\tif ( indexAttr ) {\n\n\t\t\t\t\tindexArr[ 0 ] = indexAttr.getX( i );\n\t\t\t\t\tindexArr[ 1 ] = indexAttr.getX( i + 1 );\n\t\t\t\t\tindexArr[ 2 ] = indexAttr.getX( i + 2 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindexArr[ 0 ] = i;\n\t\t\t\t\tindexArr[ 1 ] = i + 1;\n\t\t\t\t\tindexArr[ 2 ] = i + 2;\n\n\t\t\t\t}\n\n\t\t\t\tconst { a, b, c } = _triangle;\n\t\t\t\ta.fromBufferAttribute( positionAttr, indexArr[ 0 ] );\n\t\t\t\tb.fromBufferAttribute( positionAttr, indexArr[ 1 ] );\n\t\t\t\tc.fromBufferAttribute( positionAttr, indexArr[ 2 ] );\n\t\t\t\t_triangle.getNormal( _normal );\n\n\t\t\t\t// create hashes for the edge from the vertices\n\t\t\t\thashes[ 0 ] = `${ Math.round( a.x * precision ) },${ Math.round( a.y * precision ) },${ Math.round( a.z * precision ) }`;\n\t\t\t\thashes[ 1 ] = `${ Math.round( b.x * precision ) },${ Math.round( b.y * precision ) },${ Math.round( b.z * precision ) }`;\n\t\t\t\thashes[ 2 ] = `${ Math.round( c.x * precision ) },${ Math.round( c.y * precision ) },${ Math.round( c.z * precision ) }`;\n\n\t\t\t\t// skip degenerate triangles\n\t\t\t\tif ( hashes[ 0 ] === hashes[ 1 ] || hashes[ 1 ] === hashes[ 2 ] || hashes[ 2 ] === hashes[ 0 ] ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// iterate over every edge\n\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t// get the first and next vertex making up the edge\n\t\t\t\t\tconst jNext = ( j + 1 ) % 3;\n\t\t\t\t\tconst vecHash0 = hashes[ j ];\n\t\t\t\t\tconst vecHash1 = hashes[ jNext ];\n\t\t\t\t\tconst v0 = _triangle[ vertKeys[ j ] ];\n\t\t\t\t\tconst v1 = _triangle[ vertKeys[ jNext ] ];\n\n\t\t\t\t\tconst hash = `${ vecHash0 }_${ vecHash1 }`;\n\t\t\t\t\tconst reverseHash = `${ vecHash1 }_${ vecHash0 }`;\n\n\t\t\t\t\tif ( reverseHash in edgeData && edgeData[ reverseHash ] ) {\n\n\t\t\t\t\t\t// if we found a sibling edge add it into the vertex array if\n\t\t\t\t\t\t// it meets the angle threshold and delete the edge from the map.\n\t\t\t\t\t\tif ( _normal.dot( edgeData[ reverseHash ].normal ) <= thresholdDot ) {\n\n\t\t\t\t\t\t\tvertices.push( v0.x, v0.y, v0.z );\n\t\t\t\t\t\t\tvertices.push( v1.x, v1.y, v1.z );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tedgeData[ reverseHash ] = null;\n\n\t\t\t\t\t} else if ( ! ( hash in edgeData ) ) {\n\n\t\t\t\t\t\t// if we've already got an edge here then skip adding a new one\n\t\t\t\t\t\tedgeData[ hash ] = {\n\n\t\t\t\t\t\t\tindex0: indexArr[ j ],\n\t\t\t\t\t\t\tindex1: indexArr[ jNext ],\n\t\t\t\t\t\t\tnormal: _normal.clone(),\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// iterate over all remaining, unmatched edges and add them to the vertex array\n\t\t\tfor ( const key in edgeData ) {\n\n\t\t\t\tif ( edgeData[ key ] ) {\n\n\t\t\t\t\tconst { index0, index1 } = edgeData[ key ];\n\t\t\t\t\t_v0.fromBufferAttribute( positionAttr, index0 );\n\t\t\t\t\t_v1$1.fromBufferAttribute( positionAttr, index1 );\n\n\t\t\t\t\tvertices.push( _v0.x, _v0.y, _v0.z );\n\t\t\t\t\tvertices.push( _v1$1.x, _v1$1.y, _v1$1.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass Shape extends Path {\n\n\tconstructor( points ) {\n\n\t\tsuper( points );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.type = 'Shape';\n\n\t\tthis.holes = [];\n\n\t}\n\n\tgetPointsHoles( divisions ) {\n\n\t\tconst holesPts = [];\n\n\t\tfor ( let i = 0, l = this.holes.length; i < l; i ++ ) {\n\n\t\t\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\n\n\t\t}\n\n\t\treturn holesPts;\n\n\t}\n\n\t// get points of shape and holes (keypoints based on segments parameter)\n\n\textractPoints( divisions ) {\n\n\t\treturn {\n\n\t\t\tshape: this.getPoints( divisions ),\n\t\t\tholes: this.getPointsHoles( divisions )\n\n\t\t};\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.holes = [];\n\n\t\tfor ( let i = 0, l = source.holes.length; i < l; i ++ ) {\n\n\t\t\tconst hole = source.holes[ i ];\n\n\t\t\tthis.holes.push( hole.clone() );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.holes = [];\n\n\t\tfor ( let i = 0, l = this.holes.length; i < l; i ++ ) {\n\n\t\t\tconst hole = this.holes[ i ];\n\t\t\tdata.holes.push( hole.toJSON() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.uuid = json.uuid;\n\t\tthis.holes = [];\n\n\t\tfor ( let i = 0, l = json.holes.length; i < l; i ++ ) {\n\n\t\t\tconst hole = json.holes[ i ];\n\t\t\tthis.holes.push( new Path().fromJSON( hole ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\n/**\n * Port from https://github.com/mapbox/earcut (v2.2.4)\n */\n\nconst Earcut = {\n\n\ttriangulate: function ( data, holeIndices, dim = 2 ) {\n\n\t\tconst hasHoles = holeIndices && holeIndices.length;\n\t\tconst outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length;\n\t\tlet outerNode = linkedList( data, 0, outerLen, dim, true );\n\t\tconst triangles = [];\n\n\t\tif ( ! outerNode || outerNode.next === outerNode.prev ) return triangles;\n\n\t\tlet minX, minY, maxX, maxY, x, y, invSize;\n\n\t\tif ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );\n\n\t\t// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n\t\tif ( data.length > 80 * dim ) {\n\n\t\t\tminX = maxX = data[ 0 ];\n\t\t\tminY = maxY = data[ 1 ];\n\n\t\t\tfor ( let i = dim; i < outerLen; i += dim ) {\n\n\t\t\t\tx = data[ i ];\n\t\t\t\ty = data[ i + 1 ];\n\t\t\t\tif ( x < minX ) minX = x;\n\t\t\t\tif ( y < minY ) minY = y;\n\t\t\t\tif ( x > maxX ) maxX = x;\n\t\t\t\tif ( y > maxY ) maxY = y;\n\n\t\t\t}\n\n\t\t\t// minX, minY and invSize are later used to transform coords into integers for z-order calculation\n\t\t\tinvSize = Math.max( maxX - minX, maxY - minY );\n\t\t\tinvSize = invSize !== 0 ? 32767 / invSize : 0;\n\n\t\t}\n\n\t\tearcutLinked( outerNode, triangles, dim, minX, minY, invSize, 0 );\n\n\t\treturn triangles;\n\n\t}\n\n};\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList( data, start, end, dim, clockwise ) {\n\n\tlet i, last;\n\n\tif ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {\n\n\t\tfor ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\n\n\t} else {\n\n\t\tfor ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\n\n\t}\n\n\tif ( last && equals( last, last.next ) ) {\n\n\t\tremoveNode( last );\n\t\tlast = last.next;\n\n\t}\n\n\treturn last;\n\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints( start, end ) {\n\n\tif ( ! start ) return start;\n\tif ( ! end ) end = start;\n\n\tlet p = start,\n\t\tagain;\n\tdo {\n\n\t\tagain = false;\n\n\t\tif ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {\n\n\t\t\tremoveNode( p );\n\t\t\tp = end = p.prev;\n\t\t\tif ( p === p.next ) break;\n\t\t\tagain = true;\n\n\t\t} else {\n\n\t\t\tp = p.next;\n\n\t\t}\n\n\t} while ( again || p !== end );\n\n\treturn end;\n\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {\n\n\tif ( ! ear ) return;\n\n\t// interlink polygon nodes in z-order\n\tif ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );\n\n\tlet stop = ear,\n\t\tprev, next;\n\n\t// iterate through ears, slicing them one by one\n\twhile ( ear.prev !== ear.next ) {\n\n\t\tprev = ear.prev;\n\t\tnext = ear.next;\n\n\t\tif ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {\n\n\t\t\t// cut off the triangle\n\t\t\ttriangles.push( prev.i / dim | 0 );\n\t\t\ttriangles.push( ear.i / dim | 0 );\n\t\t\ttriangles.push( next.i / dim | 0 );\n\n\t\t\tremoveNode( ear );\n\n\t\t\t// skipping the next vertex leads to less sliver triangles\n\t\t\tear = next.next;\n\t\t\tstop = next.next;\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tear = next;\n\n\t\t// if we looped through the whole remaining polygon and can't find any more ears\n\t\tif ( ear === stop ) {\n\n\t\t\t// try filtering points and slicing again\n\t\t\tif ( ! pass ) {\n\n\t\t\t\tearcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );\n\n\t\t\t\t// if this didn't work, try curing all small self-intersections locally\n\n\t\t\t} else if ( pass === 1 ) {\n\n\t\t\t\tear = cureLocalIntersections( filterPoints( ear ), triangles, dim );\n\t\t\t\tearcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );\n\n\t\t\t\t// as a last resort, try splitting the remaining polygon into two\n\n\t\t\t} else if ( pass === 2 ) {\n\n\t\t\t\tsplitEarcut( ear, triangles, dim, minX, minY, invSize );\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar( ear ) {\n\n\tconst a = ear.prev,\n\t\tb = ear,\n\t\tc = ear.next;\n\n\tif ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\n\n\t// now make sure we don't have other points inside the potential ear\n\tconst ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n\t// triangle bbox; min & max are calculated like this for speed\n\tconst x0 = ax < bx ? ( ax < cx ? ax : cx ) : ( bx < cx ? bx : cx ),\n\t\ty0 = ay < by ? ( ay < cy ? ay : cy ) : ( by < cy ? by : cy ),\n\t\tx1 = ax > bx ? ( ax > cx ? ax : cx ) : ( bx > cx ? bx : cx ),\n\t\ty1 = ay > by ? ( ay > cy ? ay : cy ) : ( by > cy ? by : cy );\n\n\tlet p = c.next;\n\twhile ( p !== a ) {\n\n\t\tif ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&\n\t\t\tpointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) &&\n\t\t\tarea( p.prev, p, p.next ) >= 0 ) return false;\n\t\tp = p.next;\n\n\t}\n\n\treturn true;\n\n}\n\nfunction isEarHashed( ear, minX, minY, invSize ) {\n\n\tconst a = ear.prev,\n\t\tb = ear,\n\t\tc = ear.next;\n\n\tif ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\n\n\tconst ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n\t// triangle bbox; min & max are calculated like this for speed\n\tconst x0 = ax < bx ? ( ax < cx ? ax : cx ) : ( bx < cx ? bx : cx ),\n\t\ty0 = ay < by ? ( ay < cy ? ay : cy ) : ( by < cy ? by : cy ),\n\t\tx1 = ax > bx ? ( ax > cx ? ax : cx ) : ( bx > cx ? bx : cx ),\n\t\ty1 = ay > by ? ( ay > cy ? ay : cy ) : ( by > cy ? by : cy );\n\n\t// z-order range for the current triangle bbox;\n\tconst minZ = zOrder( x0, y0, minX, minY, invSize ),\n\t\tmaxZ = zOrder( x1, y1, minX, minY, invSize );\n\n\tlet p = ear.prevZ,\n\t\tn = ear.nextZ;\n\n\t// look for points inside the triangle in both directions\n\twhile ( p && p.z >= minZ && n && n.z <= maxZ ) {\n\n\t\tif ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n\t\t\tpointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) return false;\n\t\tp = p.prevZ;\n\n\t\tif ( n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n\t\t\tpointInTriangle( ax, ay, bx, by, cx, cy, n.x, n.y ) && area( n.prev, n, n.next ) >= 0 ) return false;\n\t\tn = n.nextZ;\n\n\t}\n\n\t// look for remaining points in decreasing z-order\n\twhile ( p && p.z >= minZ ) {\n\n\t\tif ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n\t\t\tpointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) return false;\n\t\tp = p.prevZ;\n\n\t}\n\n\t// look for remaining points in increasing z-order\n\twhile ( n && n.z <= maxZ ) {\n\n\t\tif ( n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n\t\t\tpointInTriangle( ax, ay, bx, by, cx, cy, n.x, n.y ) && area( n.prev, n, n.next ) >= 0 ) return false;\n\t\tn = n.nextZ;\n\n\t}\n\n\treturn true;\n\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections( start, triangles, dim ) {\n\n\tlet p = start;\n\tdo {\n\n\t\tconst a = p.prev,\n\t\t\tb = p.next.next;\n\n\t\tif ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {\n\n\t\t\ttriangles.push( a.i / dim | 0 );\n\t\t\ttriangles.push( p.i / dim | 0 );\n\t\t\ttriangles.push( b.i / dim | 0 );\n\n\t\t\t// remove two nodes involved\n\t\t\tremoveNode( p );\n\t\t\tremoveNode( p.next );\n\n\t\t\tp = start = b;\n\n\t\t}\n\n\t\tp = p.next;\n\n\t} while ( p !== start );\n\n\treturn filterPoints( p );\n\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut( start, triangles, dim, minX, minY, invSize ) {\n\n\t// look for a valid diagonal that divides the polygon into two\n\tlet a = start;\n\tdo {\n\n\t\tlet b = a.next.next;\n\t\twhile ( b !== a.prev ) {\n\n\t\t\tif ( a.i !== b.i && isValidDiagonal( a, b ) ) {\n\n\t\t\t\t// split the polygon in two by the diagonal\n\t\t\t\tlet c = splitPolygon( a, b );\n\n\t\t\t\t// filter colinear points around the cuts\n\t\t\t\ta = filterPoints( a, a.next );\n\t\t\t\tc = filterPoints( c, c.next );\n\n\t\t\t\t// run earcut on each half\n\t\t\t\tearcutLinked( a, triangles, dim, minX, minY, invSize, 0 );\n\t\t\t\tearcutLinked( c, triangles, dim, minX, minY, invSize, 0 );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tb = b.next;\n\n\t\t}\n\n\t\ta = a.next;\n\n\t} while ( a !== start );\n\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles( data, holeIndices, outerNode, dim ) {\n\n\tconst queue = [];\n\tlet i, len, start, end, list;\n\n\tfor ( i = 0, len = holeIndices.length; i < len; i ++ ) {\n\n\t\tstart = holeIndices[ i ] * dim;\n\t\tend = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;\n\t\tlist = linkedList( data, start, end, dim, false );\n\t\tif ( list === list.next ) list.steiner = true;\n\t\tqueue.push( getLeftmost( list ) );\n\n\t}\n\n\tqueue.sort( compareX );\n\n\t// process holes from left to right\n\tfor ( i = 0; i < queue.length; i ++ ) {\n\n\t\touterNode = eliminateHole( queue[ i ], outerNode );\n\n\t}\n\n\treturn outerNode;\n\n}\n\nfunction compareX( a, b ) {\n\n\treturn a.x - b.x;\n\n}\n\n// find a bridge between vertices that connects hole with an outer ring and link it\nfunction eliminateHole( hole, outerNode ) {\n\n\tconst bridge = findHoleBridge( hole, outerNode );\n\tif ( ! bridge ) {\n\n\t\treturn outerNode;\n\n\t}\n\n\tconst bridgeReverse = splitPolygon( bridge, hole );\n\n\t// filter collinear points around the cuts\n\tfilterPoints( bridgeReverse, bridgeReverse.next );\n\treturn filterPoints( bridge, bridge.next );\n\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge( hole, outerNode ) {\n\n\tlet p = outerNode,\n\t\tqx = - Infinity,\n\t\tm;\n\n\tconst hx = hole.x, hy = hole.y;\n\n\t// find a segment intersected by a ray from the hole's leftmost point to the left;\n\t// segment's endpoint with lesser x will be potential connection point\n\tdo {\n\n\t\tif ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {\n\n\t\t\tconst x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );\n\t\t\tif ( x <= hx && x > qx ) {\n\n\t\t\t\tqx = x;\n\t\t\t\tm = p.x < p.next.x ? p : p.next;\n\t\t\t\tif ( x === hx ) return m; // hole touches outer segment; pick leftmost endpoint\n\n\t\t\t}\n\n\t\t}\n\n\t\tp = p.next;\n\n\t} while ( p !== outerNode );\n\n\tif ( ! m ) return null;\n\n\t// look for points inside the triangle of hole point, segment intersection and endpoint;\n\t// if there are no points found, we have a valid connection;\n\t// otherwise choose the point of the minimum angle with the ray as connection point\n\n\tconst stop = m,\n\t\tmx = m.x,\n\t\tmy = m.y;\n\tlet tanMin = Infinity, tan;\n\n\tp = m;\n\n\tdo {\n\n\t\tif ( hx >= p.x && p.x >= mx && hx !== p.x &&\n\t\t\t\tpointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {\n\n\t\t\ttan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential\n\n\t\t\tif ( locallyInside( p, hole ) && ( tan < tanMin || ( tan === tanMin && ( p.x > m.x || ( p.x === m.x && sectorContainsSector( m, p ) ) ) ) ) ) {\n\n\t\t\t\tm = p;\n\t\t\t\ttanMin = tan;\n\n\t\t\t}\n\n\t\t}\n\n\t\tp = p.next;\n\n\t} while ( p !== stop );\n\n\treturn m;\n\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector( m, p ) {\n\n\treturn area( m.prev, m, p.prev ) < 0 && area( p.next, m, m.next ) < 0;\n\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve( start, minX, minY, invSize ) {\n\n\tlet p = start;\n\tdo {\n\n\t\tif ( p.z === 0 ) p.z = zOrder( p.x, p.y, minX, minY, invSize );\n\t\tp.prevZ = p.prev;\n\t\tp.nextZ = p.next;\n\t\tp = p.next;\n\n\t} while ( p !== start );\n\n\tp.prevZ.nextZ = null;\n\tp.prevZ = null;\n\n\tsortLinked( p );\n\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked( list ) {\n\n\tlet i, p, q, e, tail, numMerges, pSize, qSize,\n\t\tinSize = 1;\n\n\tdo {\n\n\t\tp = list;\n\t\tlist = null;\n\t\ttail = null;\n\t\tnumMerges = 0;\n\n\t\twhile ( p ) {\n\n\t\t\tnumMerges ++;\n\t\t\tq = p;\n\t\t\tpSize = 0;\n\t\t\tfor ( i = 0; i < inSize; i ++ ) {\n\n\t\t\t\tpSize ++;\n\t\t\t\tq = q.nextZ;\n\t\t\t\tif ( ! q ) break;\n\n\t\t\t}\n\n\t\t\tqSize = inSize;\n\n\t\t\twhile ( pSize > 0 || ( qSize > 0 && q ) ) {\n\n\t\t\t\tif ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {\n\n\t\t\t\t\te = p;\n\t\t\t\t\tp = p.nextZ;\n\t\t\t\t\tpSize --;\n\n\t\t\t\t} else {\n\n\t\t\t\t\te = q;\n\t\t\t\t\tq = q.nextZ;\n\t\t\t\t\tqSize --;\n\n\t\t\t\t}\n\n\t\t\t\tif ( tail ) tail.nextZ = e;\n\t\t\t\telse list = e;\n\n\t\t\t\te.prevZ = tail;\n\t\t\t\ttail = e;\n\n\t\t\t}\n\n\t\t\tp = q;\n\n\t\t}\n\n\t\ttail.nextZ = null;\n\t\tinSize *= 2;\n\n\t} while ( numMerges > 1 );\n\n\treturn list;\n\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder( x, y, minX, minY, invSize ) {\n\n\t// coords are transformed into non-negative 15-bit integer range\n\tx = ( x - minX ) * invSize | 0;\n\ty = ( y - minY ) * invSize | 0;\n\n\tx = ( x | ( x << 8 ) ) & 0x00FF00FF;\n\tx = ( x | ( x << 4 ) ) & 0x0F0F0F0F;\n\tx = ( x | ( x << 2 ) ) & 0x33333333;\n\tx = ( x | ( x << 1 ) ) & 0x55555555;\n\n\ty = ( y | ( y << 8 ) ) & 0x00FF00FF;\n\ty = ( y | ( y << 4 ) ) & 0x0F0F0F0F;\n\ty = ( y | ( y << 2 ) ) & 0x33333333;\n\ty = ( y | ( y << 1 ) ) & 0x55555555;\n\n\treturn x | ( y << 1 );\n\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost( start ) {\n\n\tlet p = start,\n\t\tleftmost = start;\n\tdo {\n\n\t\tif ( p.x < leftmost.x || ( p.x === leftmost.x && p.y < leftmost.y ) ) leftmost = p;\n\t\tp = p.next;\n\n\t} while ( p !== start );\n\n\treturn leftmost;\n\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {\n\n\treturn ( cx - px ) * ( ay - py ) >= ( ax - px ) * ( cy - py ) &&\n           ( ax - px ) * ( by - py ) >= ( bx - px ) * ( ay - py ) &&\n           ( bx - px ) * ( cy - py ) >= ( cx - px ) * ( by - py );\n\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal( a, b ) {\n\n\treturn a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) && // dones't intersect other edges\n           ( locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b ) && // locally visible\n            ( area( a.prev, a, b.prev ) || area( a, b.prev, b ) ) || // does not create opposite-facing sectors\n            equals( a, b ) && area( a.prev, a, a.next ) > 0 && area( b.prev, b, b.next ) > 0 ); // special zero-length case\n\n}\n\n// signed area of a triangle\nfunction area( p, q, r ) {\n\n\treturn ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );\n\n}\n\n// check if two points are equal\nfunction equals( p1, p2 ) {\n\n\treturn p1.x === p2.x && p1.y === p2.y;\n\n}\n\n// check if two segments intersect\nfunction intersects( p1, q1, p2, q2 ) {\n\n\tconst o1 = sign( area( p1, q1, p2 ) );\n\tconst o2 = sign( area( p1, q1, q2 ) );\n\tconst o3 = sign( area( p2, q2, p1 ) );\n\tconst o4 = sign( area( p2, q2, q1 ) );\n\n\tif ( o1 !== o2 && o3 !== o4 ) return true; // general case\n\n\tif ( o1 === 0 && onSegment( p1, p2, q1 ) ) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n\tif ( o2 === 0 && onSegment( p1, q2, q1 ) ) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n\tif ( o3 === 0 && onSegment( p2, p1, q2 ) ) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n\tif ( o4 === 0 && onSegment( p2, q1, q2 ) ) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n\treturn false;\n\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment( p, q, r ) {\n\n\treturn q.x <= Math.max( p.x, r.x ) && q.x >= Math.min( p.x, r.x ) && q.y <= Math.max( p.y, r.y ) && q.y >= Math.min( p.y, r.y );\n\n}\n\nfunction sign( num ) {\n\n\treturn num > 0 ? 1 : num < 0 ? - 1 : 0;\n\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon( a, b ) {\n\n\tlet p = a;\n\tdo {\n\n\t\tif ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n\t\t\tintersects( p, p.next, a, b ) ) return true;\n\t\tp = p.next;\n\n\t} while ( p !== a );\n\n\treturn false;\n\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside( a, b ) {\n\n\treturn area( a.prev, a, a.next ) < 0 ?\n\t\tarea( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :\n\t\tarea( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;\n\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside( a, b ) {\n\n\tlet p = a,\n\t\tinside = false;\n\tconst px = ( a.x + b.x ) / 2,\n\t\tpy = ( a.y + b.y ) / 2;\n\tdo {\n\n\t\tif ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&\n\t\t\t( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) )\n\t\t\tinside = ! inside;\n\t\tp = p.next;\n\n\t} while ( p !== a );\n\n\treturn inside;\n\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon( a, b ) {\n\n\tconst a2 = new Node( a.i, a.x, a.y ),\n\t\tb2 = new Node( b.i, b.x, b.y ),\n\t\tan = a.next,\n\t\tbp = b.prev;\n\n\ta.next = b;\n\tb.prev = a;\n\n\ta2.next = an;\n\tan.prev = a2;\n\n\tb2.next = a2;\n\ta2.prev = b2;\n\n\tbp.next = b2;\n\tb2.prev = bp;\n\n\treturn b2;\n\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode( i, x, y, last ) {\n\n\tconst p = new Node( i, x, y );\n\n\tif ( ! last ) {\n\n\t\tp.prev = p;\n\t\tp.next = p;\n\n\t} else {\n\n\t\tp.next = last.next;\n\t\tp.prev = last;\n\t\tlast.next.prev = p;\n\t\tlast.next = p;\n\n\t}\n\n\treturn p;\n\n}\n\nfunction removeNode( p ) {\n\n\tp.next.prev = p.prev;\n\tp.prev.next = p.next;\n\n\tif ( p.prevZ ) p.prevZ.nextZ = p.nextZ;\n\tif ( p.nextZ ) p.nextZ.prevZ = p.prevZ;\n\n}\n\nfunction Node( i, x, y ) {\n\n\t// vertex index in coordinates array\n\tthis.i = i;\n\n\t// vertex coordinates\n\tthis.x = x;\n\tthis.y = y;\n\n\t// previous and next vertex nodes in a polygon ring\n\tthis.prev = null;\n\tthis.next = null;\n\n\t// z-order curve value\n\tthis.z = 0;\n\n\t// previous and next nodes in z-order\n\tthis.prevZ = null;\n\tthis.nextZ = null;\n\n\t// indicates whether this is a steiner point\n\tthis.steiner = false;\n\n}\n\nfunction signedArea( data, start, end, dim ) {\n\n\tlet sum = 0;\n\tfor ( let i = start, j = end - dim; i < end; i += dim ) {\n\n\t\tsum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );\n\t\tj = i;\n\n\t}\n\n\treturn sum;\n\n}\n\nclass ShapeUtils {\n\n\t// calculate area of the contour polygon\n\n\tstatic area( contour ) {\n\n\t\tconst n = contour.length;\n\t\tlet a = 0.0;\n\n\t\tfor ( let p = n - 1, q = 0; q < n; p = q ++ ) {\n\n\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\n\n\t\t}\n\n\t\treturn a * 0.5;\n\n\t}\n\n\tstatic isClockWise( pts ) {\n\n\t\treturn ShapeUtils.area( pts ) < 0;\n\n\t}\n\n\tstatic triangulateShape( contour, holes ) {\n\n\t\tconst vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]\n\t\tconst holeIndices = []; // array of hole indices\n\t\tconst faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]\n\n\t\tremoveDupEndPts( contour );\n\t\taddContour( vertices, contour );\n\n\t\t//\n\n\t\tlet holeIndex = contour.length;\n\n\t\tholes.forEach( removeDupEndPts );\n\n\t\tfor ( let i = 0; i < holes.length; i ++ ) {\n\n\t\t\tholeIndices.push( holeIndex );\n\t\t\tholeIndex += holes[ i ].length;\n\t\t\taddContour( vertices, holes[ i ] );\n\n\t\t}\n\n\t\t//\n\n\t\tconst triangles = Earcut.triangulate( vertices, holeIndices );\n\n\t\t//\n\n\t\tfor ( let i = 0; i < triangles.length; i += 3 ) {\n\n\t\t\tfaces.push( triangles.slice( i, i + 3 ) );\n\n\t\t}\n\n\t\treturn faces;\n\n\t}\n\n}\n\nfunction removeDupEndPts( points ) {\n\n\tconst l = points.length;\n\n\tif ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {\n\n\t\tpoints.pop();\n\n\t}\n\n}\n\nfunction addContour( vertices, contour ) {\n\n\tfor ( let i = 0; i < contour.length; i ++ ) {\n\n\t\tvertices.push( contour[ i ].x );\n\t\tvertices.push( contour[ i ].y );\n\n\t}\n\n}\n\n/**\n * Creates extruded geometry from a path shape.\n *\n * parameters = {\n *\n *  curveSegments: <int>, // number of points on the curves\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n *  depth: <float>, // Depth to extrude the shape\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\n *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel\n *  bevelOffset: <float>, // how far from shape outline does bevel start\n *  bevelSegments: <int>, // number of bevel layers\n *\n *  extrudePath: <THREE.Curve> // curve to extrude shape along\n *\n *  UVGenerator: <Object> // object that provides UV generator functions\n *\n * }\n */\n\n\nclass ExtrudeGeometry extends BufferGeometry {\n\n\tconstructor( shapes = new Shape( [ new Vector2( 0.5, 0.5 ), new Vector2( - 0.5, 0.5 ), new Vector2( - 0.5, - 0.5 ), new Vector2( 0.5, - 0.5 ) ] ), options = {} ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'ExtrudeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tshapes: shapes,\n\t\t\toptions: options\n\t\t};\n\n\t\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\n\n\t\tconst scope = this;\n\n\t\tconst verticesArray = [];\n\t\tconst uvArray = [];\n\n\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tconst shape = shapes[ i ];\n\t\t\taddShape( shape );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );\n\n\t\tthis.computeVertexNormals();\n\n\t\t// functions\n\n\t\tfunction addShape( shape ) {\n\n\t\t\tconst placeholder = [];\n\n\t\t\t// options\n\n\t\t\tconst curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\t\t\tconst steps = options.steps !== undefined ? options.steps : 1;\n\t\t\tconst depth = options.depth !== undefined ? options.depth : 1;\n\n\t\t\tlet bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;\n\t\t\tlet bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 0.2;\n\t\t\tlet bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 0.1;\n\t\t\tlet bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;\n\t\t\tlet bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\n\t\t\tconst extrudePath = options.extrudePath;\n\n\t\t\tconst uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;\n\n\t\t\t//\n\n\t\t\tlet extrudePts, extrudeByPath = false;\n\t\t\tlet splineTube, binormal, normal, position2;\n\n\t\t\tif ( extrudePath ) {\n\n\t\t\t\textrudePts = extrudePath.getSpacedPoints( steps );\n\n\t\t\t\textrudeByPath = true;\n\t\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\n\t\t\t\t// SETUP TNB variables\n\n\t\t\t\t// TODO1 - have a .isClosed in spline?\n\n\t\t\t\tsplineTube = extrudePath.computeFrenetFrames( steps, false );\n\n\t\t\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n\t\t\t\tbinormal = new Vector3();\n\t\t\t\tnormal = new Vector3();\n\t\t\t\tposition2 = new Vector3();\n\n\t\t\t}\n\n\t\t\t// Safeguards if bevels are not enabled\n\n\t\t\tif ( ! bevelEnabled ) {\n\n\t\t\t\tbevelSegments = 0;\n\t\t\t\tbevelThickness = 0;\n\t\t\t\tbevelSize = 0;\n\t\t\t\tbevelOffset = 0;\n\n\t\t\t}\n\n\t\t\t// Variables initialization\n\n\t\t\tconst shapePoints = shape.extractPoints( curveSegments );\n\n\t\t\tlet vertices = shapePoints.shape;\n\t\t\tconst holes = shapePoints.holes;\n\n\t\t\tconst reverse = ! ShapeUtils.isClockWise( vertices );\n\n\t\t\tif ( reverse ) {\n\n\t\t\t\tvertices = vertices.reverse();\n\n\t\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\n\t\t\t\t\tif ( ShapeUtils.isClockWise( ahole ) ) {\n\n\t\t\t\t\t\tholes[ h ] = ahole.reverse();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tconst faces = ShapeUtils.triangulateShape( vertices, holes );\n\n\t\t\t/* Vertices */\n\n\t\t\tconst contour = vertices; // vertices has all points but contour has only points of circumference\n\n\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tconst ahole = holes[ h ];\n\n\t\t\t\tvertices = vertices.concat( ahole );\n\n\t\t\t}\n\n\n\t\t\tfunction scalePt2( pt, vec, size ) {\n\n\t\t\t\tif ( ! vec ) console.error( 'THREE.ExtrudeGeometry: vec does not exist' );\n\n\t\t\t\treturn pt.clone().addScaledVector( vec, size );\n\n\t\t\t}\n\n\t\t\tconst vlen = vertices.length, flen = faces.length;\n\n\n\t\t\t// Find directions for point movement\n\n\n\t\t\tfunction getBevelVec( inPt, inPrev, inNext ) {\n\n\t\t\t\t// computes for inPt the corresponding point inPt' on a new contour\n\t\t\t\t//   shifted by 1 unit (length of normalized vector) to the left\n\t\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\n\t\t\t\t//\n\t\t\t\t// inPt' is the intersection of the two lines parallel to the two\n\t\t\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\n\n\t\t\t\tlet v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\n\n\t\t\t\t// good reading for geometry algorithms (here: line-line intersection)\n\t\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\n\n\t\t\t\tconst v_prev_x = inPt.x - inPrev.x,\n\t\t\t\t\tv_prev_y = inPt.y - inPrev.y;\n\t\t\t\tconst v_next_x = inNext.x - inPt.x,\n\t\t\t\t\tv_next_y = inNext.y - inPt.y;\n\n\t\t\t\tconst v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\n\n\t\t\t\t// check for collinear edges\n\t\t\t\tconst collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\n\n\t\t\t\t\t// not collinear\n\n\t\t\t\t\t// length of vectors for normalizing\n\n\t\t\t\t\tconst v_prev_len = Math.sqrt( v_prev_lensq );\n\t\t\t\t\tconst v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\n\n\t\t\t\t\t// shift adjacent points by unit vectors to the left\n\n\t\t\t\t\tconst ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\n\t\t\t\t\tconst ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\n\n\t\t\t\t\tconst ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\n\t\t\t\t\tconst ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\n\n\t\t\t\t\t// scaling factor for v_prev to intersection point\n\n\t\t\t\t\tconst sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\n\t\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /\n\t\t\t\t\t\t( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\t\t\t// vector from inPt to intersection point\n\n\t\t\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\n\t\t\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\n\n\t\t\t\t\t// Don't normalize!, otherwise sharp corners become ugly\n\t\t\t\t\t//  but prevent crazy spikes\n\t\t\t\t\tconst v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\n\t\t\t\t\tif ( v_trans_lensq <= 2 ) {\n\n\t\t\t\t\t\treturn new Vector2( v_trans_x, v_trans_y );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// handle special case of collinear edges\n\n\t\t\t\t\tlet direction_eq = false; // assumes: opposite\n\n\t\t\t\t\tif ( v_prev_x > Number.EPSILON ) {\n\n\t\t\t\t\t\tif ( v_next_x > Number.EPSILON ) {\n\n\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\n\n\t\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( direction_eq ) {\n\n\t\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\n\t\t\t\t\t\tv_trans_x = - v_prev_y;\n\t\t\t\t\t\tv_trans_y = v_prev_x;\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\n\t\t\t\t\t\tv_trans_x = v_prev_x;\n\t\t\t\t\t\tv_trans_y = v_prev_y;\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\n\n\t\t\t}\n\n\n\t\t\tconst contourMovements = [];\n\n\t\t\tfor ( let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\tif ( k === il ) k = 0;\n\n\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\t// console.log('i,j,k', i, j , k)\n\n\t\t\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\n\t\t\t}\n\n\t\t\tconst holesMovements = [];\n\t\t\tlet oneHoleMovements, verticesMovements = contourMovements.concat();\n\n\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tconst ahole = holes[ h ];\n\n\t\t\t\toneHoleMovements = [];\n\n\t\t\t\tfor ( let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\t\tif ( k === il ) k = 0;\n\n\t\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\n\t\t\t\t}\n\n\t\t\t\tholesMovements.push( oneHoleMovements );\n\t\t\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\n\n\t\t\t}\n\n\n\t\t\t// Loop bevelSegments, 1 for the front, 1 for the back\n\n\t\t\tfor ( let b = 0; b < bevelSegments; b ++ ) {\n\n\t\t\t\t//for ( b = bevelSegments; b > 0; b -- ) {\n\n\t\t\t\tconst t = b / bevelSegments;\n\t\t\t\tconst z = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\t\tconst bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;\n\n\t\t\t\t// contract shape\n\n\t\t\t\tfor ( let i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst vert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\n\t\t\t\t\tv( vert.x, vert.y, - z );\n\n\t\t\t\t}\n\n\t\t\t\t// expand holes\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\t\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\t\tfor ( let i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\t\tv( vert.x, vert.y, - z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst bs = bevelSize + bevelOffset;\n\n\t\t\t// Back facing vertices\n\n\t\t\tfor ( let i = 0; i < vlen; i ++ ) {\n\n\t\t\t\tconst vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\tv( vert.x, vert.y, 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\n\t\t\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\n\t\t\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\n\n\t\t\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\n\n\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Add stepped vertices...\n\t\t\t// Including front facing vertices\n\n\t\t\tfor ( let s = 1; s <= steps; s ++ ) {\n\n\t\t\t\tfor ( let i = 0; i < vlen; i ++ ) {\n\n\t\t\t\t\tconst vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\t\tv( vert.x, vert.y, depth / steps * s );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\n\t\t\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\n\t\t\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\n\n\t\t\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\n\n\t\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// Add bevel segments planes\n\n\t\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\t\t\tfor ( let b = bevelSegments - 1; b >= 0; b -- ) {\n\n\t\t\t\tconst t = b / bevelSegments;\n\t\t\t\tconst z = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\t\tconst bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;\n\n\t\t\t\t// contract shape\n\n\t\t\t\tfor ( let i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst vert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\t\t\tv( vert.x, vert.y, depth + z );\n\n\t\t\t\t}\n\n\t\t\t\t// expand holes\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\t\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\t\tfor ( let i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\t\t\tv( vert.x, vert.y, depth + z );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/* Faces */\n\n\t\t\t// Top and bottom faces\n\n\t\t\tbuildLidFaces();\n\n\t\t\t// Sides faces\n\n\t\t\tbuildSideFaces();\n\n\n\t\t\t/////  Internal functions\n\n\t\t\tfunction buildLidFaces() {\n\n\t\t\t\tconst start = verticesArray.length / 3;\n\n\t\t\t\tif ( bevelEnabled ) {\n\n\t\t\t\t\tlet layer = 0; // steps + 1\n\t\t\t\t\tlet offset = vlen * layer;\n\n\t\t\t\t\t// Bottom faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\t\t\toffset = vlen * layer;\n\n\t\t\t\t\t// Top faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Bottom faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Top faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, 0 );\n\n\t\t\t}\n\n\t\t\t// Create faces for the z-sides of the shape\n\n\t\t\tfunction buildSideFaces() {\n\n\t\t\t\tconst start = verticesArray.length / 3;\n\t\t\t\tlet layeroffset = 0;\n\t\t\t\tsidewalls( contour, layeroffset );\n\t\t\t\tlayeroffset += contour.length;\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\t\t\t\t\tsidewalls( ahole, layeroffset );\n\n\t\t\t\t\t//, true\n\t\t\t\t\tlayeroffset += ahole.length;\n\n\t\t\t\t}\n\n\n\t\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, 1 );\n\n\n\t\t\t}\n\n\t\t\tfunction sidewalls( contour, layeroffset ) {\n\n\t\t\t\tlet i = contour.length;\n\n\t\t\t\twhile ( -- i >= 0 ) {\n\n\t\t\t\t\tconst j = i;\n\t\t\t\t\tlet k = i - 1;\n\t\t\t\t\tif ( k < 0 ) k = contour.length - 1;\n\n\t\t\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\n\t\t\t\t\tfor ( let s = 0, sl = ( steps + bevelSegments * 2 ); s < sl; s ++ ) {\n\n\t\t\t\t\t\tconst slen1 = vlen * s;\n\t\t\t\t\t\tconst slen2 = vlen * ( s + 1 );\n\n\t\t\t\t\t\tconst a = layeroffset + j + slen1,\n\t\t\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\t\t\td = layeroffset + j + slen2;\n\n\t\t\t\t\t\tf4( a, b, c, d );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction v( x, y, z ) {\n\n\t\t\t\tplaceholder.push( x );\n\t\t\t\tplaceholder.push( y );\n\t\t\t\tplaceholder.push( z );\n\n\t\t\t}\n\n\n\t\t\tfunction f3( a, b, c ) {\n\n\t\t\t\taddVertex( a );\n\t\t\t\taddVertex( b );\n\t\t\t\taddVertex( c );\n\n\t\t\t\tconst nextIndex = verticesArray.length / 3;\n\t\t\t\tconst uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\n\n\t\t\t\taddUV( uvs[ 0 ] );\n\t\t\t\taddUV( uvs[ 1 ] );\n\t\t\t\taddUV( uvs[ 2 ] );\n\n\t\t\t}\n\n\t\t\tfunction f4( a, b, c, d ) {\n\n\t\t\t\taddVertex( a );\n\t\t\t\taddVertex( b );\n\t\t\t\taddVertex( d );\n\n\t\t\t\taddVertex( b );\n\t\t\t\taddVertex( c );\n\t\t\t\taddVertex( d );\n\n\n\t\t\t\tconst nextIndex = verticesArray.length / 3;\n\t\t\t\tconst uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\n\n\t\t\t\taddUV( uvs[ 0 ] );\n\t\t\t\taddUV( uvs[ 1 ] );\n\t\t\t\taddUV( uvs[ 3 ] );\n\n\t\t\t\taddUV( uvs[ 1 ] );\n\t\t\t\taddUV( uvs[ 2 ] );\n\t\t\t\taddUV( uvs[ 3 ] );\n\n\t\t\t}\n\n\t\t\tfunction addVertex( index ) {\n\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 0 ] );\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 1 ] );\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 2 ] );\n\n\t\t\t}\n\n\n\t\t\tfunction addUV( vector2 ) {\n\n\t\t\t\tuvArray.push( vector2.x );\n\t\t\t\tuvArray.push( vector2.y );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tconst shapes = this.parameters.shapes;\n\t\tconst options = this.parameters.options;\n\n\t\treturn toJSON$1( shapes, options, data );\n\n\t}\n\n\tstatic fromJSON( data, shapes ) {\n\n\t\tconst geometryShapes = [];\n\n\t\tfor ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {\n\n\t\t\tconst shape = shapes[ data.shapes[ j ] ];\n\n\t\t\tgeometryShapes.push( shape );\n\n\t\t}\n\n\t\tconst extrudePath = data.options.extrudePath;\n\n\t\tif ( extrudePath !== undefined ) {\n\n\t\t\tdata.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );\n\n\t\t}\n\n\t\treturn new ExtrudeGeometry( geometryShapes, data.options );\n\n\t}\n\n}\n\nconst WorldUVGenerator = {\n\n\tgenerateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {\n\n\t\tconst a_x = vertices[ indexA * 3 ];\n\t\tconst a_y = vertices[ indexA * 3 + 1 ];\n\t\tconst b_x = vertices[ indexB * 3 ];\n\t\tconst b_y = vertices[ indexB * 3 + 1 ];\n\t\tconst c_x = vertices[ indexC * 3 ];\n\t\tconst c_y = vertices[ indexC * 3 + 1 ];\n\n\t\treturn [\n\t\t\tnew Vector2( a_x, a_y ),\n\t\t\tnew Vector2( b_x, b_y ),\n\t\t\tnew Vector2( c_x, c_y )\n\t\t];\n\n\t},\n\n\tgenerateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {\n\n\t\tconst a_x = vertices[ indexA * 3 ];\n\t\tconst a_y = vertices[ indexA * 3 + 1 ];\n\t\tconst a_z = vertices[ indexA * 3 + 2 ];\n\t\tconst b_x = vertices[ indexB * 3 ];\n\t\tconst b_y = vertices[ indexB * 3 + 1 ];\n\t\tconst b_z = vertices[ indexB * 3 + 2 ];\n\t\tconst c_x = vertices[ indexC * 3 ];\n\t\tconst c_y = vertices[ indexC * 3 + 1 ];\n\t\tconst c_z = vertices[ indexC * 3 + 2 ];\n\t\tconst d_x = vertices[ indexD * 3 ];\n\t\tconst d_y = vertices[ indexD * 3 + 1 ];\n\t\tconst d_z = vertices[ indexD * 3 + 2 ];\n\n\t\tif ( Math.abs( a_y - b_y ) < Math.abs( a_x - b_x ) ) {\n\n\t\t\treturn [\n\t\t\t\tnew Vector2( a_x, 1 - a_z ),\n\t\t\t\tnew Vector2( b_x, 1 - b_z ),\n\t\t\t\tnew Vector2( c_x, 1 - c_z ),\n\t\t\t\tnew Vector2( d_x, 1 - d_z )\n\t\t\t];\n\n\t\t} else {\n\n\t\t\treturn [\n\t\t\t\tnew Vector2( a_y, 1 - a_z ),\n\t\t\t\tnew Vector2( b_y, 1 - b_z ),\n\t\t\t\tnew Vector2( c_y, 1 - c_z ),\n\t\t\t\tnew Vector2( d_y, 1 - d_z )\n\t\t\t];\n\n\t\t}\n\n\t}\n\n};\n\nfunction toJSON$1( shapes, options, data ) {\n\n\tdata.shapes = [];\n\n\tif ( Array.isArray( shapes ) ) {\n\n\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tconst shape = shapes[ i ];\n\n\t\t\tdata.shapes.push( shape.uuid );\n\n\t\t}\n\n\t} else {\n\n\t\tdata.shapes.push( shapes.uuid );\n\n\t}\n\n\tdata.options = Object.assign( {}, options );\n\n\tif ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();\n\n\treturn data;\n\n}\n\nclass IcosahedronGeometry extends PolyhedronGeometry {\n\n\tconstructor( radius = 1, detail = 0 ) {\n\n\t\tconst t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\n\t\tconst vertices = [\n\t\t\t- 1, t, 0, \t1, t, 0, \t- 1, - t, 0, \t1, - t, 0,\n\t\t\t0, - 1, t, \t0, 1, t,\t0, - 1, - t, \t0, 1, - t,\n\t\t\tt, 0, - 1, \tt, 0, 1, \t- t, 0, - 1, \t- t, 0, 1\n\t\t];\n\n\t\tconst indices = [\n\t\t\t0, 11, 5, \t0, 5, 1, \t0, 1, 7, \t0, 7, 10, \t0, 10, 11,\n\t\t\t1, 5, 9, \t5, 11, 4,\t11, 10, 2,\t10, 7, 6,\t7, 1, 8,\n\t\t\t3, 9, 4, \t3, 4, 2,\t3, 2, 6,\t3, 6, 8,\t3, 8, 9,\n\t\t\t4, 9, 5, \t2, 4, 11,\t6, 2, 10,\t8, 6, 7,\t9, 8, 1\n\t\t];\n\n\t\tsuper( vertices, indices, radius, detail );\n\n\t\tthis.type = 'IcosahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new IcosahedronGeometry( data.radius, data.detail );\n\n\t}\n\n}\n\nclass OctahedronGeometry extends PolyhedronGeometry {\n\n\tconstructor( radius = 1, detail = 0 ) {\n\n\t\tconst vertices = [\n\t\t\t1, 0, 0, \t- 1, 0, 0,\t0, 1, 0,\n\t\t\t0, - 1, 0, \t0, 0, 1,\t0, 0, - 1\n\t\t];\n\n\t\tconst indices = [\n\t\t\t0, 2, 4,\t0, 4, 3,\t0, 3, 5,\n\t\t\t0, 5, 2,\t1, 2, 5,\t1, 5, 3,\n\t\t\t1, 3, 4,\t1, 4, 2\n\t\t];\n\n\t\tsuper( vertices, indices, radius, detail );\n\n\t\tthis.type = 'OctahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new OctahedronGeometry( data.radius, data.detail );\n\n\t}\n\n}\n\nclass PlaneGeometry extends BufferGeometry {\n\n\tconstructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'PlaneGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments\n\t\t};\n\n\t\tconst width_half = width / 2;\n\t\tconst height_half = height / 2;\n\n\t\tconst gridX = Math.floor( widthSegments );\n\t\tconst gridY = Math.floor( heightSegments );\n\n\t\tconst gridX1 = gridX + 1;\n\t\tconst gridY1 = gridY + 1;\n\n\t\tconst segment_width = width / gridX;\n\t\tconst segment_height = height / gridY;\n\n\t\t//\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\tfor ( let iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\tconst y = iy * segment_height - height_half;\n\n\t\t\tfor ( let ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\tconst x = ix * segment_width - width_half;\n\n\t\t\t\tvertices.push( x, - y, 0 );\n\n\t\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t\tuvs.push( ix / gridX );\n\t\t\t\tuvs.push( 1 - ( iy / gridY ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\tfor ( let ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\tconst a = ix + gridX1 * iy;\n\t\t\t\tconst b = ix + gridX1 * ( iy + 1 );\n\t\t\t\tconst c = ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\tconst d = ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new PlaneGeometry( data.width, data.height, data.widthSegments, data.heightSegments );\n\n\t}\n\n}\n\nclass RingGeometry extends BufferGeometry {\n\n\tconstructor( innerRadius = 0.5, outerRadius = 1, thetaSegments = 32, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'RingGeometry';\n\n\t\tthis.parameters = {\n\t\t\tinnerRadius: innerRadius,\n\t\t\touterRadius: outerRadius,\n\t\t\tthetaSegments: thetaSegments,\n\t\t\tphiSegments: phiSegments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tthetaSegments = Math.max( 3, thetaSegments );\n\t\tphiSegments = Math.max( 1, phiSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// some helper variables\n\n\t\tlet radius = innerRadius;\n\t\tconst radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\n\t\tconst vertex = new Vector3();\n\t\tconst uv = new Vector2();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let j = 0; j <= phiSegments; j ++ ) {\n\n\t\t\tfor ( let i = 0; i <= thetaSegments; i ++ ) {\n\n\t\t\t\t// values are generate from the inside of the ring to the outside\n\n\t\t\t\tconst segment = thetaStart + i / thetaSegments * thetaLength;\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\t\tvertex.y = radius * Math.sin( segment );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t\t// uv\n\n\t\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\n\t\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\n\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t}\n\n\t\t\t// increase the radius for next row of vertices\n\n\t\t\tradius += radiusStep;\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let j = 0; j < phiSegments; j ++ ) {\n\n\t\t\tconst thetaSegmentLevel = j * ( thetaSegments + 1 );\n\n\t\t\tfor ( let i = 0; i < thetaSegments; i ++ ) {\n\n\t\t\t\tconst segment = i + thetaSegmentLevel;\n\n\t\t\t\tconst a = segment;\n\t\t\t\tconst b = segment + thetaSegments + 1;\n\t\t\t\tconst c = segment + thetaSegments + 2;\n\t\t\t\tconst d = segment + 1;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new RingGeometry( data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nclass ShapeGeometry extends BufferGeometry {\n\n\tconstructor( shapes = new Shape( [ new Vector2( 0, 0.5 ), new Vector2( - 0.5, - 0.5 ), new Vector2( 0.5, - 0.5 ) ] ), curveSegments = 12 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'ShapeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tshapes: shapes,\n\t\t\tcurveSegments: curveSegments\n\t\t};\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tlet groupStart = 0;\n\t\tlet groupCount = 0;\n\n\t\t// allow single and array values for \"shapes\" parameter\n\n\t\tif ( Array.isArray( shapes ) === false ) {\n\n\t\t\taddShape( shapes );\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0; i < shapes.length; i ++ ) {\n\n\t\t\t\taddShape( shapes[ i ] );\n\n\t\t\t\tthis.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support\n\n\t\t\t\tgroupStart += groupCount;\n\t\t\t\tgroupCount = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\n\t\t// helper functions\n\n\t\tfunction addShape( shape ) {\n\n\t\t\tconst indexOffset = vertices.length / 3;\n\t\t\tconst points = shape.extractPoints( curveSegments );\n\n\t\t\tlet shapeVertices = points.shape;\n\t\t\tconst shapeHoles = points.holes;\n\n\t\t\t// check direction of vertices\n\n\t\t\tif ( ShapeUtils.isClockWise( shapeVertices ) === false ) {\n\n\t\t\t\tshapeVertices = shapeVertices.reverse();\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {\n\n\t\t\t\tconst shapeHole = shapeHoles[ i ];\n\n\t\t\t\tif ( ShapeUtils.isClockWise( shapeHole ) === true ) {\n\n\t\t\t\t\tshapeHoles[ i ] = shapeHole.reverse();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );\n\n\t\t\t// join vertices of inner and outer paths to a single array\n\n\t\t\tfor ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {\n\n\t\t\t\tconst shapeHole = shapeHoles[ i ];\n\t\t\t\tshapeVertices = shapeVertices.concat( shapeHole );\n\n\t\t\t}\n\n\t\t\t// vertices, normals, uvs\n\n\t\t\tfor ( let i = 0, l = shapeVertices.length; i < l; i ++ ) {\n\n\t\t\t\tconst vertex = shapeVertices[ i ];\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, 0 );\n\t\t\t\tnormals.push( 0, 0, 1 );\n\t\t\t\tuvs.push( vertex.x, vertex.y ); // world uvs\n\n\t\t\t}\n\n\t\t\t// indices\n\n\t\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tconst face = faces[ i ];\n\n\t\t\t\tconst a = face[ 0 ] + indexOffset;\n\t\t\t\tconst b = face[ 1 ] + indexOffset;\n\t\t\t\tconst c = face[ 2 ] + indexOffset;\n\n\t\t\t\tindices.push( a, b, c );\n\t\t\t\tgroupCount += 3;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tconst shapes = this.parameters.shapes;\n\n\t\treturn toJSON( shapes, data );\n\n\t}\n\n\tstatic fromJSON( data, shapes ) {\n\n\t\tconst geometryShapes = [];\n\n\t\tfor ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {\n\n\t\t\tconst shape = shapes[ data.shapes[ j ] ];\n\n\t\t\tgeometryShapes.push( shape );\n\n\t\t}\n\n\t\treturn new ShapeGeometry( geometryShapes, data.curveSegments );\n\n\t}\n\n}\n\nfunction toJSON( shapes, data ) {\n\n\tdata.shapes = [];\n\n\tif ( Array.isArray( shapes ) ) {\n\n\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tconst shape = shapes[ i ];\n\n\t\t\tdata.shapes.push( shape.uuid );\n\n\t\t}\n\n\t} else {\n\n\t\tdata.shapes.push( shapes.uuid );\n\n\t}\n\n\treturn data;\n\n}\n\nclass SphereGeometry extends BufferGeometry {\n\n\tconstructor( radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'SphereGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\twidthSegments = Math.max( 3, Math.floor( widthSegments ) );\n\t\theightSegments = Math.max( 2, Math.floor( heightSegments ) );\n\n\t\tconst thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );\n\n\t\tlet index = 0;\n\t\tconst grid = [];\n\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let iy = 0; iy <= heightSegments; iy ++ ) {\n\n\t\t\tconst verticesRow = [];\n\n\t\t\tconst v = iy / heightSegments;\n\n\t\t\t// special case for the poles\n\n\t\t\tlet uOffset = 0;\n\n\t\t\tif ( iy === 0 && thetaStart === 0 ) {\n\n\t\t\t\tuOffset = 0.5 / widthSegments;\n\n\t\t\t} else if ( iy === heightSegments && thetaEnd === Math.PI ) {\n\n\t\t\t\tuOffset = - 0.5 / widthSegments;\n\n\t\t\t}\n\n\t\t\tfor ( let ix = 0; ix <= widthSegments; ix ++ ) {\n\n\t\t\t\tconst u = ix / widthSegments;\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\t\t\tvertex.y = radius * Math.cos( thetaStart + v * thetaLength );\n\t\t\t\tvertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormal.copy( vertex ).normalize();\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( u + uOffset, 1 - v );\n\n\t\t\t\tverticesRow.push( index ++ );\n\n\t\t\t}\n\n\t\t\tgrid.push( verticesRow );\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let iy = 0; iy < heightSegments; iy ++ ) {\n\n\t\t\tfor ( let ix = 0; ix < widthSegments; ix ++ ) {\n\n\t\t\t\tconst a = grid[ iy ][ ix + 1 ];\n\t\t\t\tconst b = grid[ iy ][ ix ];\n\t\t\t\tconst c = grid[ iy + 1 ][ ix ];\n\t\t\t\tconst d = grid[ iy + 1 ][ ix + 1 ];\n\n\t\t\t\tif ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );\n\t\t\t\tif ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new SphereGeometry( data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nclass TetrahedronGeometry extends PolyhedronGeometry {\n\n\tconstructor( radius = 1, detail = 0 ) {\n\n\t\tconst vertices = [\n\t\t\t1, 1, 1, \t- 1, - 1, 1, \t- 1, 1, - 1, \t1, - 1, - 1\n\t\t];\n\n\t\tconst indices = [\n\t\t\t2, 1, 0, \t0, 3, 2,\t1, 3, 0,\t2, 3, 1\n\t\t];\n\n\t\tsuper( vertices, indices, radius, detail );\n\n\t\tthis.type = 'TetrahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new TetrahedronGeometry( data.radius, data.detail );\n\n\t}\n\n}\n\nclass TorusGeometry extends BufferGeometry {\n\n\tconstructor( radius = 1, tube = 0.4, radialSegments = 12, tubularSegments = 48, arc = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'TorusGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\tradialSegments: radialSegments,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tarc: arc\n\t\t};\n\n\t\tradialSegments = Math.floor( radialSegments );\n\t\ttubularSegments = Math.floor( tubularSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tconst center = new Vector3();\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\tfor ( let i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\t\tconst u = i / tubularSegments * arc;\n\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\n\t\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\n\t\t\t\tvertex.z = tube * Math.sin( v );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tcenter.x = radius * Math.cos( u );\n\t\t\t\tcenter.y = radius * Math.sin( u );\n\t\t\t\tnormal.subVectors( vertex, center ).normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( i / tubularSegments );\n\t\t\t\tuvs.push( j / radialSegments );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( let j = 1; j <= radialSegments; j ++ ) {\n\n\t\t\tfor ( let i = 1; i <= tubularSegments; i ++ ) {\n\n\t\t\t\t// indices\n\n\t\t\t\tconst a = ( tubularSegments + 1 ) * j + i - 1;\n\t\t\t\tconst b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\n\t\t\t\tconst c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\n\t\t\t\tconst d = ( tubularSegments + 1 ) * j + i;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new TorusGeometry( data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc );\n\n\t}\n\n}\n\nclass TorusKnotGeometry extends BufferGeometry {\n\n\tconstructor( radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'TorusKnotGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradialSegments: radialSegments,\n\t\t\tp: p,\n\t\t\tq: q\n\t\t};\n\n\t\ttubularSegments = Math.floor( tubularSegments );\n\t\tradialSegments = Math.floor( radialSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\tconst P1 = new Vector3();\n\t\tconst P2 = new Vector3();\n\n\t\tconst B = new Vector3();\n\t\tconst T = new Vector3();\n\t\tconst N = new Vector3();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let i = 0; i <= tubularSegments; ++ i ) {\n\n\t\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segment\n\n\t\t\tconst u = i / tubularSegments * p * Math.PI * 2;\n\n\t\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n\t\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\n\t\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\n\t\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\n\n\t\t\t// calculate orthonormal basis\n\n\t\t\tT.subVectors( P2, P1 );\n\t\t\tN.addVectors( P2, P1 );\n\t\t\tB.crossVectors( T, N );\n\t\t\tN.crossVectors( B, T );\n\n\t\t\t// normalize B, N. T can be ignored, we don't use it\n\n\t\t\tB.normalize();\n\t\t\tN.normalize();\n\n\t\t\tfor ( let j = 0; j <= radialSegments; ++ j ) {\n\n\t\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n\t\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\n\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\n\t\t\t\tconst cx = - tube * Math.cos( v );\n\t\t\t\tconst cy = tube * Math.sin( v );\n\n\t\t\t\t// now calculate the final vertex position.\n\t\t\t\t// first we orient the extrusion with our basis vectors, then we add it to the current position on the curve\n\n\t\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\n\t\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\n\t\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\n\t\t\t\tnormal.subVectors( vertex, P1 ).normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( i / tubularSegments );\n\t\t\t\tuvs.push( j / radialSegments );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( let j = 1; j <= tubularSegments; j ++ ) {\n\n\t\t\tfor ( let i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t\t// indices\n\n\t\t\t\tconst a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\tconst b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\tconst c = ( radialSegments + 1 ) * j + i;\n\t\t\t\tconst d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\t// this function calculates the current position on the torus curve\n\n\t\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\n\n\t\t\tconst cu = Math.cos( u );\n\t\t\tconst su = Math.sin( u );\n\t\t\tconst quOverP = q / p * u;\n\t\t\tconst cs = Math.cos( quOverP );\n\n\t\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\n\t\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\n\t\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new TorusKnotGeometry( data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q );\n\n\t}\n\n}\n\nclass TubeGeometry extends BufferGeometry {\n\n\tconstructor( path = new QuadraticBezierCurve3( new Vector3( - 1, - 1, 0 ), new Vector3( - 1, 1, 0 ), new Vector3( 1, 1, 0 ) ), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'TubeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpath: path,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradius: radius,\n\t\t\tradialSegments: radialSegments,\n\t\t\tclosed: closed\n\t\t};\n\n\t\tconst frames = path.computeFrenetFrames( tubularSegments, closed );\n\n\t\t// expose internals\n\n\t\tthis.tangents = frames.tangents;\n\t\tthis.normals = frames.normals;\n\t\tthis.binormals = frames.binormals;\n\n\t\t// helper variables\n\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\t\tconst uv = new Vector2();\n\t\tlet P = new Vector3();\n\n\t\t// buffer\n\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\t\tconst indices = [];\n\n\t\t// create buffer data\n\n\t\tgenerateBufferData();\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\t// functions\n\n\t\tfunction generateBufferData() {\n\n\t\t\tfor ( let i = 0; i < tubularSegments; i ++ ) {\n\n\t\t\t\tgenerateSegment( i );\n\n\t\t\t}\n\n\t\t\t// if the geometry is not closed, generate the last row of vertices and normals\n\t\t\t// at the regular position on the given path\n\t\t\t//\n\t\t\t// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n\n\t\t\tgenerateSegment( ( closed === false ) ? tubularSegments : 0 );\n\n\t\t\t// uvs are generated in a separate function.\n\t\t\t// this makes it easy compute correct values for closed geometries\n\n\t\t\tgenerateUVs();\n\n\t\t\t// finally create faces\n\n\t\t\tgenerateIndices();\n\n\t\t}\n\n\t\tfunction generateSegment( i ) {\n\n\t\t\t// we use getPointAt to sample evenly distributed points from the given path\n\n\t\t\tP = path.getPointAt( i / tubularSegments, P );\n\n\t\t\t// retrieve corresponding normal and binormal\n\n\t\t\tconst N = frames.normals[ i ];\n\t\t\tconst B = frames.binormals[ i ];\n\n\t\t\t// generate normals and vertices for the current segment\n\n\t\t\tfor ( let j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\n\n\t\t\t\tconst sin = Math.sin( v );\n\t\t\t\tconst cos = - Math.cos( v );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormal.x = ( cos * N.x + sin * B.x );\n\t\t\t\tnormal.y = ( cos * N.y + sin * B.y );\n\t\t\t\tnormal.z = ( cos * N.z + sin * B.z );\n\t\t\t\tnormal.normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = P.x + radius * normal.x;\n\t\t\t\tvertex.y = P.y + radius * normal.y;\n\t\t\t\tvertex.z = P.z + radius * normal.z;\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateIndices() {\n\n\t\t\tfor ( let j = 1; j <= tubularSegments; j ++ ) {\n\n\t\t\t\tfor ( let i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t\t\tconst a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\t\tconst b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\t\tconst c = ( radialSegments + 1 ) * j + i;\n\t\t\t\t\tconst d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateUVs() {\n\n\t\t\tfor ( let i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\t\tfor ( let j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\t\t\tuv.x = i / tubularSegments;\n\t\t\t\t\tuv.y = j / radialSegments;\n\n\t\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.path = this.parameters.path.toJSON();\n\n\t\treturn data;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\t// This only works for built-in curves (e.g. CatmullRomCurve3).\n\t\t// User defined curves or instances of CurvePath will not be deserialized.\n\t\treturn new TubeGeometry(\n\t\t\tnew Curves[ data.path.type ]().fromJSON( data.path ),\n\t\t\tdata.tubularSegments,\n\t\t\tdata.radius,\n\t\t\tdata.radialSegments,\n\t\t\tdata.closed\n\t\t);\n\n\t}\n\n}\n\nclass WireframeGeometry extends BufferGeometry {\n\n\tconstructor( geometry = null ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'WireframeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tgeometry: geometry\n\t\t};\n\n\t\tif ( geometry !== null ) {\n\n\t\t\t// buffer\n\n\t\t\tconst vertices = [];\n\t\t\tconst edges = new Set();\n\n\t\t\t// helper variables\n\n\t\t\tconst start = new Vector3();\n\t\t\tconst end = new Vector3();\n\n\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\t// indexed BufferGeometry\n\n\t\t\t\tconst position = geometry.attributes.position;\n\t\t\t\tconst indices = geometry.index;\n\t\t\t\tlet groups = geometry.groups;\n\n\t\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\t\tgroups = [ { start: 0, count: indices.count, materialIndex: 0 } ];\n\n\t\t\t\t}\n\n\t\t\t\t// create a data structure that contains all edges without duplicates\n\n\t\t\t\tfor ( let o = 0, ol = groups.length; o < ol; ++ o ) {\n\n\t\t\t\t\tconst group = groups[ o ];\n\n\t\t\t\t\tconst groupStart = group.start;\n\t\t\t\t\tconst groupCount = group.count;\n\n\t\t\t\t\tfor ( let i = groupStart, l = ( groupStart + groupCount ); i < l; i += 3 ) {\n\n\t\t\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t\tconst index1 = indices.getX( i + j );\n\t\t\t\t\t\t\tconst index2 = indices.getX( i + ( j + 1 ) % 3 );\n\n\t\t\t\t\t\t\tstart.fromBufferAttribute( position, index1 );\n\t\t\t\t\t\t\tend.fromBufferAttribute( position, index2 );\n\n\t\t\t\t\t\t\tif ( isUniqueEdge( start, end, edges ) === true ) {\n\n\t\t\t\t\t\t\t\tvertices.push( start.x, start.y, start.z );\n\t\t\t\t\t\t\t\tvertices.push( end.x, end.y, end.z );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed BufferGeometry\n\n\t\t\t\tconst position = geometry.attributes.position;\n\n\t\t\t\tfor ( let i = 0, l = ( position.count / 3 ); i < l; i ++ ) {\n\n\t\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t// three edges per triangle, an edge is represented as (index1, index2)\n\t\t\t\t\t\t// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)\n\n\t\t\t\t\t\tconst index1 = 3 * i + j;\n\t\t\t\t\t\tconst index2 = 3 * i + ( ( j + 1 ) % 3 );\n\n\t\t\t\t\t\tstart.fromBufferAttribute( position, index1 );\n\t\t\t\t\t\tend.fromBufferAttribute( position, index2 );\n\n\t\t\t\t\t\tif ( isUniqueEdge( start, end, edges ) === true ) {\n\n\t\t\t\t\t\t\tvertices.push( start.x, start.y, start.z );\n\t\t\t\t\t\t\tvertices.push( end.x, end.y, end.z );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// build geometry\n\n\t\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n}\n\nfunction isUniqueEdge( start, end, edges ) {\n\n\tconst hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;\n\tconst hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`; // coincident edge\n\n\tif ( edges.has( hash1 ) === true || edges.has( hash2 ) === true ) {\n\n\t\treturn false;\n\n\t} else {\n\n\t\tedges.add( hash1 );\n\t\tedges.add( hash2 );\n\t\treturn true;\n\n\t}\n\n}\n\nvar Geometries = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tBoxGeometry: BoxGeometry,\n\tCapsuleGeometry: CapsuleGeometry,\n\tCircleGeometry: CircleGeometry,\n\tConeGeometry: ConeGeometry,\n\tCylinderGeometry: CylinderGeometry,\n\tDodecahedronGeometry: DodecahedronGeometry,\n\tEdgesGeometry: EdgesGeometry,\n\tExtrudeGeometry: ExtrudeGeometry,\n\tIcosahedronGeometry: IcosahedronGeometry,\n\tLatheGeometry: LatheGeometry,\n\tOctahedronGeometry: OctahedronGeometry,\n\tPlaneGeometry: PlaneGeometry,\n\tPolyhedronGeometry: PolyhedronGeometry,\n\tRingGeometry: RingGeometry,\n\tShapeGeometry: ShapeGeometry,\n\tSphereGeometry: SphereGeometry,\n\tTetrahedronGeometry: TetrahedronGeometry,\n\tTorusGeometry: TorusGeometry,\n\tTorusKnotGeometry: TorusKnotGeometry,\n\tTubeGeometry: TubeGeometry,\n\tWireframeGeometry: WireframeGeometry\n});\n\nclass ShadowMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isShadowMaterial = true;\n\n\t\tthis.type = 'ShadowMaterial';\n\n\t\tthis.color = new Color( 0x000000 );\n\t\tthis.transparent = true;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass RawShaderMaterial extends ShaderMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper( parameters );\n\n\t\tthis.isRawShaderMaterial = true;\n\n\t\tthis.type = 'RawShaderMaterial';\n\n\t}\n\n}\n\nclass MeshStandardMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshStandardMaterial = true;\n\n\t\tthis.type = 'MeshStandardMaterial';\n\n\t\tthis.defines = { 'STANDARD': '' };\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\tthis.roughness = 1.0;\n\t\tthis.metalness = 0.0;\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.roughnessMap = null;\n\n\t\tthis.metalnessMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.envMapRotation = new Euler();\n\t\tthis.envMapIntensity = 1.0;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.flatShading = false;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.defines = { 'STANDARD': '' };\n\n\t\tthis.color.copy( source.color );\n\t\tthis.roughness = source.roughness;\n\t\tthis.metalness = source.metalness;\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.roughnessMap = source.roughnessMap;\n\n\t\tthis.metalnessMap = source.metalnessMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.envMapRotation.copy( source.envMapRotation );\n\t\tthis.envMapIntensity = source.envMapIntensity;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshPhysicalMaterial extends MeshStandardMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshPhysicalMaterial = true;\n\n\t\tthis.defines = {\n\n\t\t\t'STANDARD': '',\n\t\t\t'PHYSICAL': ''\n\n\t\t};\n\n\t\tthis.type = 'MeshPhysicalMaterial';\n\n\t\tthis.anisotropyRotation = 0;\n\t\tthis.anisotropyMap = null;\n\n\t\tthis.clearcoatMap = null;\n\t\tthis.clearcoatRoughness = 0.0;\n\t\tthis.clearcoatRoughnessMap = null;\n\t\tthis.clearcoatNormalScale = new Vector2( 1, 1 );\n\t\tthis.clearcoatNormalMap = null;\n\n\t\tthis.ior = 1.5;\n\n\t\tObject.defineProperty( this, 'reflectivity', {\n\t\t\tget: function () {\n\n\t\t\t\treturn ( clamp( 2.5 * ( this.ior - 1 ) / ( this.ior + 1 ), 0, 1 ) );\n\n\t\t\t},\n\t\t\tset: function ( reflectivity ) {\n\n\t\t\t\tthis.ior = ( 1 + 0.4 * reflectivity ) / ( 1 - 0.4 * reflectivity );\n\n\t\t\t}\n\t\t} );\n\n\t\tthis.iridescenceMap = null;\n\t\tthis.iridescenceIOR = 1.3;\n\t\tthis.iridescenceThicknessRange = [ 100, 400 ];\n\t\tthis.iridescenceThicknessMap = null;\n\n\t\tthis.sheenColor = new Color( 0x000000 );\n\t\tthis.sheenColorMap = null;\n\t\tthis.sheenRoughness = 1.0;\n\t\tthis.sheenRoughnessMap = null;\n\n\t\tthis.transmissionMap = null;\n\n\t\tthis.thickness = 0;\n\t\tthis.thicknessMap = null;\n\t\tthis.attenuationDistance = Infinity;\n\t\tthis.attenuationColor = new Color( 1, 1, 1 );\n\n\t\tthis.specularIntensity = 1.0;\n\t\tthis.specularIntensityMap = null;\n\t\tthis.specularColor = new Color( 1, 1, 1 );\n\t\tthis.specularColorMap = null;\n\n\t\tthis._anisotropy = 0;\n\t\tthis._clearcoat = 0;\n\t\tthis._dispersion = 0;\n\t\tthis._iridescence = 0;\n\t\tthis._sheen = 0.0;\n\t\tthis._transmission = 0;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tget anisotropy() {\n\n\t\treturn this._anisotropy;\n\n\t}\n\n\tset anisotropy( value ) {\n\n\t\tif ( this._anisotropy > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._anisotropy = value;\n\n\t}\n\n\tget clearcoat() {\n\n\t\treturn this._clearcoat;\n\n\t}\n\n\tset clearcoat( value ) {\n\n\t\tif ( this._clearcoat > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._clearcoat = value;\n\n\t}\n\n\tget iridescence() {\n\n\t\treturn this._iridescence;\n\n\t}\n\n\tset iridescence( value ) {\n\n\t\tif ( this._iridescence > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._iridescence = value;\n\n\t}\n\n\tget dispersion() {\n\n\t\treturn this._dispersion;\n\n\t}\n\n\tset dispersion( value ) {\n\n\t\tif ( this._dispersion > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._dispersion = value;\n\n\t}\n\n\tget sheen() {\n\n\t\treturn this._sheen;\n\n\t}\n\n\tset sheen( value ) {\n\n\t\tif ( this._sheen > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._sheen = value;\n\n\t}\n\n\tget transmission() {\n\n\t\treturn this._transmission;\n\n\t}\n\n\tset transmission( value ) {\n\n\t\tif ( this._transmission > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._transmission = value;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.defines = {\n\n\t\t\t'STANDARD': '',\n\t\t\t'PHYSICAL': ''\n\n\t\t};\n\n\t\tthis.anisotropy = source.anisotropy;\n\t\tthis.anisotropyRotation = source.anisotropyRotation;\n\t\tthis.anisotropyMap = source.anisotropyMap;\n\n\t\tthis.clearcoat = source.clearcoat;\n\t\tthis.clearcoatMap = source.clearcoatMap;\n\t\tthis.clearcoatRoughness = source.clearcoatRoughness;\n\t\tthis.clearcoatRoughnessMap = source.clearcoatRoughnessMap;\n\t\tthis.clearcoatNormalMap = source.clearcoatNormalMap;\n\t\tthis.clearcoatNormalScale.copy( source.clearcoatNormalScale );\n\n\t\tthis.dispersion = source.dispersion;\n\t\tthis.ior = source.ior;\n\n\t\tthis.iridescence = source.iridescence;\n\t\tthis.iridescenceMap = source.iridescenceMap;\n\t\tthis.iridescenceIOR = source.iridescenceIOR;\n\t\tthis.iridescenceThicknessRange = [ ...source.iridescenceThicknessRange ];\n\t\tthis.iridescenceThicknessMap = source.iridescenceThicknessMap;\n\n\t\tthis.sheen = source.sheen;\n\t\tthis.sheenColor.copy( source.sheenColor );\n\t\tthis.sheenColorMap = source.sheenColorMap;\n\t\tthis.sheenRoughness = source.sheenRoughness;\n\t\tthis.sheenRoughnessMap = source.sheenRoughnessMap;\n\n\t\tthis.transmission = source.transmission;\n\t\tthis.transmissionMap = source.transmissionMap;\n\n\t\tthis.thickness = source.thickness;\n\t\tthis.thicknessMap = source.thicknessMap;\n\t\tthis.attenuationDistance = source.attenuationDistance;\n\t\tthis.attenuationColor.copy( source.attenuationColor );\n\n\t\tthis.specularIntensity = source.specularIntensity;\n\t\tthis.specularIntensityMap = source.specularIntensityMap;\n\t\tthis.specularColor.copy( source.specularColor );\n\t\tthis.specularColorMap = source.specularColorMap;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshPhongMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshPhongMaterial = true;\n\n\t\tthis.type = 'MeshPhongMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\tthis.specular = new Color( 0x111111 );\n\t\tthis.shininess = 30;\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.envMapRotation = new Euler();\n\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.flatShading = false;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\t\tthis.specular.copy( source.specular );\n\t\tthis.shininess = source.shininess;\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.envMapRotation.copy( source.envMapRotation );\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshToonMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshToonMaterial = true;\n\n\t\tthis.defines = { 'TOON': '' };\n\n\t\tthis.type = 'MeshToonMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.map = null;\n\t\tthis.gradientMap = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\t\tthis.gradientMap = source.gradientMap;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshNormalMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshNormalMaterial = true;\n\n\t\tthis.type = 'MeshNormalMaterial';\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.flatShading = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshLambertMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshLambertMaterial = true;\n\n\t\tthis.type = 'MeshLambertMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.envMapRotation = new Euler();\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.flatShading = false;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.envMapRotation.copy( source.envMapRotation );\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshDepthMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshDepthMaterial = true;\n\n\t\tthis.type = 'MeshDepthMaterial';\n\n\t\tthis.depthPacking = BasicDepthPacking;\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.depthPacking = source.depthPacking;\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshDistanceMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshDistanceMaterial = true;\n\n\t\tthis.type = 'MeshDistanceMaterial';\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshMatcapMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshMatcapMaterial = true;\n\n\t\tthis.defines = { 'MATCAP': '' };\n\n\t\tthis.type = 'MeshMatcapMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\n\t\tthis.matcap = null;\n\n\t\tthis.map = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.flatShading = false;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.defines = { 'MATCAP': '' };\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.matcap = source.matcap;\n\n\t\tthis.map = source.map;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass LineDashedMaterial extends LineBasicMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isLineDashedMaterial = true;\n\t\tthis.type = 'LineDashedMaterial';\n\n\t\tthis.scale = 1;\n\t\tthis.dashSize = 3;\n\t\tthis.gapSize = 1;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.scale = source.scale;\n\t\tthis.dashSize = source.dashSize;\n\t\tthis.gapSize = source.gapSize;\n\n\t\treturn this;\n\n\t}\n\n}\n\n// converts an array to a specific type\nfunction convertArray( array, type, forceClone ) {\n\n\tif ( ! array || // let 'undefined' and 'null' pass\n\t\t! forceClone && array.constructor === type ) return array;\n\n\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\n\n\t\treturn new type( array ); // create typed array\n\n\t}\n\n\treturn Array.prototype.slice.call( array ); // create Array\n\n}\n\nfunction isTypedArray( object ) {\n\n\treturn ArrayBuffer.isView( object ) &&\n\t\t! ( object instanceof DataView );\n\n}\n\n// returns an array by which times and values can be sorted\nfunction getKeyframeOrder( times ) {\n\n\tfunction compareTime( i, j ) {\n\n\t\treturn times[ i ] - times[ j ];\n\n\t}\n\n\tconst n = times.length;\n\tconst result = new Array( n );\n\tfor ( let i = 0; i !== n; ++ i ) result[ i ] = i;\n\n\tresult.sort( compareTime );\n\n\treturn result;\n\n}\n\n// uses the array previously returned by 'getKeyframeOrder' to sort data\nfunction sortedArray( values, stride, order ) {\n\n\tconst nValues = values.length;\n\tconst result = new values.constructor( nValues );\n\n\tfor ( let i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\n\n\t\tconst srcOffset = order[ i ] * stride;\n\n\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\n\n\t\t}\n\n\t}\n\n\treturn result;\n\n}\n\n// function for parsing AOS keyframe formats\nfunction flattenJSON( jsonKeys, times, values, valuePropertyName ) {\n\n\tlet i = 1, key = jsonKeys[ 0 ];\n\n\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\n\n\t\tkey = jsonKeys[ i ++ ];\n\n\t}\n\n\tif ( key === undefined ) return; // no data\n\n\tlet value = key[ valuePropertyName ];\n\tif ( value === undefined ) return; // no data\n\n\tif ( Array.isArray( value ) ) {\n\n\t\tdo {\n\n\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\ttimes.push( key.time );\n\t\t\t\tvalues.push.apply( values, value ); // push all elements\n\n\t\t\t}\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t} while ( key !== undefined );\n\n\t} else if ( value.toArray !== undefined ) {\n\n\t\t// ...assume THREE.Math-ish\n\n\t\tdo {\n\n\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\ttimes.push( key.time );\n\t\t\t\tvalue.toArray( values, values.length );\n\n\t\t\t}\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t} while ( key !== undefined );\n\n\t} else {\n\n\t\t// otherwise push as-is\n\n\t\tdo {\n\n\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\ttimes.push( key.time );\n\t\t\t\tvalues.push( value );\n\n\t\t\t}\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t} while ( key !== undefined );\n\n\t}\n\n}\n\nfunction subclip( sourceClip, name, startFrame, endFrame, fps = 30 ) {\n\n\tconst clip = sourceClip.clone();\n\n\tclip.name = name;\n\n\tconst tracks = [];\n\n\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\tconst track = clip.tracks[ i ];\n\t\tconst valueSize = track.getValueSize();\n\n\t\tconst times = [];\n\t\tconst values = [];\n\n\t\tfor ( let j = 0; j < track.times.length; ++ j ) {\n\n\t\t\tconst frame = track.times[ j ] * fps;\n\n\t\t\tif ( frame < startFrame || frame >= endFrame ) continue;\n\n\t\t\ttimes.push( track.times[ j ] );\n\n\t\t\tfor ( let k = 0; k < valueSize; ++ k ) {\n\n\t\t\t\tvalues.push( track.values[ j * valueSize + k ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( times.length === 0 ) continue;\n\n\t\ttrack.times = convertArray( times, track.times.constructor );\n\t\ttrack.values = convertArray( values, track.values.constructor );\n\n\t\ttracks.push( track );\n\n\t}\n\n\tclip.tracks = tracks;\n\n\t// find minimum .times value across all tracks in the trimmed clip\n\n\tlet minStartTime = Infinity;\n\n\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\tif ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {\n\n\t\t\tminStartTime = clip.tracks[ i ].times[ 0 ];\n\n\t\t}\n\n\t}\n\n\t// shift all tracks such that clip begins at t=0\n\n\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\tclip.tracks[ i ].shift( - 1 * minStartTime );\n\n\t}\n\n\tclip.resetDuration();\n\n\treturn clip;\n\n}\n\nfunction makeClipAdditive( targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30 ) {\n\n\tif ( fps <= 0 ) fps = 30;\n\n\tconst numTracks = referenceClip.tracks.length;\n\tconst referenceTime = referenceFrame / fps;\n\n\t// Make each track's values relative to the values at the reference frame\n\tfor ( let i = 0; i < numTracks; ++ i ) {\n\n\t\tconst referenceTrack = referenceClip.tracks[ i ];\n\t\tconst referenceTrackType = referenceTrack.ValueTypeName;\n\n\t\t// Skip this track if it's non-numeric\n\t\tif ( referenceTrackType === 'bool' || referenceTrackType === 'string' ) continue;\n\n\t\t// Find the track in the target clip whose name and type matches the reference track\n\t\tconst targetTrack = targetClip.tracks.find( function ( track ) {\n\n\t\t\treturn track.name === referenceTrack.name\n\t\t\t\t&& track.ValueTypeName === referenceTrackType;\n\n\t\t} );\n\n\t\tif ( targetTrack === undefined ) continue;\n\n\t\tlet referenceOffset = 0;\n\t\tconst referenceValueSize = referenceTrack.getValueSize();\n\n\t\tif ( referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\treferenceOffset = referenceValueSize / 3;\n\n\t\t}\n\n\t\tlet targetOffset = 0;\n\t\tconst targetValueSize = targetTrack.getValueSize();\n\n\t\tif ( targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\ttargetOffset = targetValueSize / 3;\n\n\t\t}\n\n\t\tconst lastIndex = referenceTrack.times.length - 1;\n\t\tlet referenceValue;\n\n\t\t// Find the value to subtract out of the track\n\t\tif ( referenceTime <= referenceTrack.times[ 0 ] ) {\n\n\t\t\t// Reference frame is earlier than the first keyframe, so just use the first keyframe\n\t\t\tconst startIndex = referenceOffset;\n\t\t\tconst endIndex = referenceValueSize - referenceOffset;\n\t\t\treferenceValue = referenceTrack.values.slice( startIndex, endIndex );\n\n\t\t} else if ( referenceTime >= referenceTrack.times[ lastIndex ] ) {\n\n\t\t\t// Reference frame is after the last keyframe, so just use the last keyframe\n\t\t\tconst startIndex = lastIndex * referenceValueSize + referenceOffset;\n\t\t\tconst endIndex = startIndex + referenceValueSize - referenceOffset;\n\t\t\treferenceValue = referenceTrack.values.slice( startIndex, endIndex );\n\n\t\t} else {\n\n\t\t\t// Interpolate to the reference value\n\t\t\tconst interpolant = referenceTrack.createInterpolant();\n\t\t\tconst startIndex = referenceOffset;\n\t\t\tconst endIndex = referenceValueSize - referenceOffset;\n\t\t\tinterpolant.evaluate( referenceTime );\n\t\t\treferenceValue = interpolant.resultBuffer.slice( startIndex, endIndex );\n\n\t\t}\n\n\t\t// Conjugate the quaternion\n\t\tif ( referenceTrackType === 'quaternion' ) {\n\n\t\t\tconst referenceQuat = new Quaternion().fromArray( referenceValue ).normalize().conjugate();\n\t\t\treferenceQuat.toArray( referenceValue );\n\n\t\t}\n\n\t\t// Subtract the reference value from all of the track values\n\n\t\tconst numTimes = targetTrack.times.length;\n\t\tfor ( let j = 0; j < numTimes; ++ j ) {\n\n\t\t\tconst valueStart = j * targetValueSize + targetOffset;\n\n\t\t\tif ( referenceTrackType === 'quaternion' ) {\n\n\t\t\t\t// Multiply the conjugate for quaternion track types\n\t\t\t\tQuaternion.multiplyQuaternionsFlat(\n\t\t\t\t\ttargetTrack.values,\n\t\t\t\t\tvalueStart,\n\t\t\t\t\treferenceValue,\n\t\t\t\t\t0,\n\t\t\t\t\ttargetTrack.values,\n\t\t\t\t\tvalueStart\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\tconst valueEnd = targetValueSize - targetOffset * 2;\n\n\t\t\t\t// Subtract each value for all other numeric track types\n\t\t\t\tfor ( let k = 0; k < valueEnd; ++ k ) {\n\n\t\t\t\t\ttargetTrack.values[ valueStart + k ] -= referenceValue[ k ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttargetClip.blendMode = AdditiveAnimationBlendMode;\n\n\treturn targetClip;\n\n}\n\nconst AnimationUtils = {\n\tconvertArray: convertArray,\n\tisTypedArray: isTypedArray,\n\tgetKeyframeOrder: getKeyframeOrder,\n\tsortedArray: sortedArray,\n\tflattenJSON: flattenJSON,\n\tsubclip: subclip,\n\tmakeClipAdditive: makeClipAdditive\n};\n\n/**\n * Abstract base class of interpolants over parametric samples.\n *\n * The parameter domain is one dimensional, typically the time or a path\n * along a curve defined by the data.\n *\n * The sample values can have any dimensionality and derived classes may\n * apply special interpretations to the data.\n *\n * This class provides the interval seek in a Template Method, deferring\n * the actual interpolation to derived classes.\n *\n * Time complexity is O(1) for linear access crossing at most two points\n * and O(log N) for random access, where N is the number of positions.\n *\n * References:\n *\n * \t\thttp://www.oodesign.com/template-method-pattern.html\n *\n */\n\nclass Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tthis.parameterPositions = parameterPositions;\n\t\tthis._cachedIndex = 0;\n\n\t\tthis.resultBuffer = resultBuffer !== undefined ?\n\t\t\tresultBuffer : new sampleValues.constructor( sampleSize );\n\t\tthis.sampleValues = sampleValues;\n\t\tthis.valueSize = sampleSize;\n\n\t\tthis.settings = null;\n\t\tthis.DefaultSettings_ = {};\n\n\t}\n\n\tevaluate( t ) {\n\n\t\tconst pp = this.parameterPositions;\n\t\tlet i1 = this._cachedIndex,\n\t\t\tt1 = pp[ i1 ],\n\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\tvalidate_interval: {\n\n\t\t\tseek: {\n\n\t\t\t\tlet right;\n\n\t\t\t\tlinear_scan: {\n\n\t\t\t\t\t//- See http://jsperf.com/comparison-to-undefined/3\n\t\t\t\t\t//- slower code:\n\t\t\t\t\t//-\n\t\t\t\t\t//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\n\n\t\t\t\t\t\tfor ( let giveUpAt = i1 + 2; ; ) {\n\n\t\t\t\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\n\n\t\t\t\t\t\t\t\t// after end\n\n\t\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\n\n\t\t\t\t\t\t\tif ( t < t1 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the right side of the index\n\t\t\t\t\t\tright = pp.length;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//- slower code:\n\t\t\t\t\t//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\t\t\t\t\tif ( ! ( t >= t0 ) ) {\n\n\t\t\t\t\t\t// looping?\n\n\t\t\t\t\t\tconst t1global = pp[ 1 ];\n\n\t\t\t\t\t\tif ( t < t1global ) {\n\n\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\n\t\t\t\t\t\t\tt0 = t1global;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// linear reverse scan\n\n\t\t\t\t\t\tfor ( let giveUpAt = i1 - 2; ; ) {\n\n\t\t\t\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\t\t\t\t// before start\n\n\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\t\treturn this.copySampleValue_( 0 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt1 = t0;\n\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\n\n\t\t\t\t\t\t\tif ( t >= t0 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the left side of the index\n\t\t\t\t\t\tright = i1;\n\t\t\t\t\t\ti1 = 0;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// the interval is valid\n\n\t\t\t\t\tbreak validate_interval;\n\n\t\t\t\t} // linear scan\n\n\t\t\t\t// binary search\n\n\t\t\t\twhile ( i1 < right ) {\n\n\t\t\t\t\tconst mid = ( i1 + right ) >>> 1;\n\n\t\t\t\t\tif ( t < pp[ mid ] ) {\n\n\t\t\t\t\t\tright = mid;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ti1 = mid + 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tt1 = pp[ i1 ];\n\t\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\t\t\t// check boundary cases, again\n\n\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\treturn this.copySampleValue_( 0 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t\t\t\t}\n\n\t\t\t} // seek\n\n\t\t\tthis._cachedIndex = i1;\n\n\t\t\tthis.intervalChanged_( i1, t0, t1 );\n\n\t\t} // validate_interval\n\n\t\treturn this.interpolate_( i1, t0, t, t1 );\n\n\t}\n\n\tgetSettings_() {\n\n\t\treturn this.settings || this.DefaultSettings_;\n\n\t}\n\n\tcopySampleValue_( index ) {\n\n\t\t// copies a sample value to the result buffer\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = index * stride;\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\t// Template methods for derived classes:\n\n\tinterpolate_( /* i1, t0, t, t1 */ ) {\n\n\t\tthrow new Error( 'call to abstract method' );\n\t\t// implementations shall return this.resultBuffer\n\n\t}\n\n\tintervalChanged_( /* i1, t0, t1 */ ) {\n\n\t\t// empty\n\n\t}\n\n}\n\n/**\n * Fast and simple cubic spline interpolant.\n *\n * It was derived from a Hermitian construction setting the first derivative\n * at each sample position to the linear slope between neighboring positions\n * over their parameter interval.\n */\n\nclass CubicInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t\tthis._weightPrev = - 0;\n\t\tthis._offsetPrev = - 0;\n\t\tthis._weightNext = - 0;\n\t\tthis._offsetNext = - 0;\n\n\t\tthis.DefaultSettings_ = {\n\n\t\t\tendingStart: ZeroCurvatureEnding,\n\t\t\tendingEnd: ZeroCurvatureEnding\n\n\t\t};\n\n\t}\n\n\tintervalChanged_( i1, t0, t1 ) {\n\n\t\tconst pp = this.parameterPositions;\n\t\tlet iPrev = i1 - 2,\n\t\t\tiNext = i1 + 1,\n\n\t\t\ttPrev = pp[ iPrev ],\n\t\t\ttNext = pp[ iNext ];\n\n\t\tif ( tPrev === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingStart ) {\n\n\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(t0) = 0\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = 2 * t0 - t1;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiPrev = pp.length - 2;\n\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = t1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tNext === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingEnd ) {\n\n\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(tN) = 0\n\t\t\t\t\tiNext = i1;\n\t\t\t\t\ttNext = 2 * t1 - t0;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiNext = 1;\n\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\n\t\t\t\t\tiNext = i1 - 1;\n\t\t\t\t\ttNext = t0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst halfDt = ( t1 - t0 ) * 0.5,\n\t\t\tstride = this.valueSize;\n\n\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\n\t\tthis._weightNext = halfDt / ( tNext - t1 );\n\t\tthis._offsetPrev = iPrev * stride;\n\t\tthis._offsetNext = iNext * stride;\n\n\t}\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\n\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\n\t\t\twP = this._weightPrev,\twN = this._weightNext,\n\n\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\n\t\t\tpp = p * p,\n\t\t\tppp = pp * p;\n\n\t\t// evaluate polynomials\n\n\t\tconst sP = - wP * ppp + 2 * wP * pp - wP * p;\n\t\tconst s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;\n\t\tconst s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;\n\t\tconst sN = wN * ppp - wN * pp;\n\n\t\t// combine data linearly\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] =\n\t\t\t\t\tsP * values[ oP + i ] +\n\t\t\t\t\ts0 * values[ o0 + i ] +\n\t\t\t\t\ts1 * values[ o1 + i ] +\n\t\t\t\t\tsN * values[ oN + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\nclass LinearInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\toffset1 = i1 * stride,\n\t\t\toffset0 = offset1 - stride,\n\n\t\t\tweight1 = ( t - t0 ) / ( t1 - t0 ),\n\t\t\tweight0 = 1 - weight1;\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] =\n\t\t\t\t\tvalues[ offset0 + i ] * weight0 +\n\t\t\t\t\tvalues[ offset1 + i ] * weight1;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\n/**\n *\n * Interpolant that evaluates to the sample value at the position preceding\n * the parameter.\n */\n\nclass DiscreteInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tinterpolate_( i1 /*, t0, t, t1 */ ) {\n\n\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t}\n\n}\n\nclass KeyframeTrack {\n\n\tconstructor( name, times, values, interpolation ) {\n\n\t\tif ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );\n\t\tif ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );\n\n\t\tthis.name = name;\n\n\t\tthis.times = convertArray( times, this.TimeBufferType );\n\t\tthis.values = convertArray( values, this.ValueBufferType );\n\n\t\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\n\n\t}\n\n\t// Serialization (in static context, because of constructor invocation\n\t// and automatic invocation of .toJSON):\n\n\tstatic toJSON( track ) {\n\n\t\tconst trackType = track.constructor;\n\n\t\tlet json;\n\n\t\t// derived classes can define a static toJSON method\n\t\tif ( trackType.toJSON !== this.toJSON ) {\n\n\t\t\tjson = trackType.toJSON( track );\n\n\t\t} else {\n\n\t\t\t// by default, we assume the data can be serialized as-is\n\t\t\tjson = {\n\n\t\t\t\t'name': track.name,\n\t\t\t\t'times': convertArray( track.times, Array ),\n\t\t\t\t'values': convertArray( track.values, Array )\n\n\t\t\t};\n\n\t\t\tconst interpolation = track.getInterpolation();\n\n\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\n\n\t\t\t\tjson.interpolation = interpolation;\n\n\t\t\t}\n\n\t\t}\n\n\t\tjson.type = track.ValueTypeName; // mandatory\n\n\t\treturn json;\n\n\t}\n\n\tInterpolantFactoryMethodDiscrete( result ) {\n\n\t\treturn new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n\tInterpolantFactoryMethodLinear( result ) {\n\n\t\treturn new LinearInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n\tInterpolantFactoryMethodSmooth( result ) {\n\n\t\treturn new CubicInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n\tsetInterpolation( interpolation ) {\n\n\t\tlet factoryMethod;\n\n\t\tswitch ( interpolation ) {\n\n\t\t\tcase InterpolateDiscrete:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\n\n\t\t\t\tbreak;\n\n\t\t\tcase InterpolateLinear:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\n\n\t\t\t\tbreak;\n\n\t\t\tcase InterpolateSmooth:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tif ( factoryMethod === undefined ) {\n\n\t\t\tconst message = 'unsupported interpolation for ' +\n\t\t\t\tthis.ValueTypeName + ' keyframe track named ' + this.name;\n\n\t\t\tif ( this.createInterpolant === undefined ) {\n\n\t\t\t\t// fall back to default, unless the default itself is messed up\n\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\n\n\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( message ); // fatal, in this case\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.KeyframeTrack:', message );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tthis.createInterpolant = factoryMethod;\n\n\t\treturn this;\n\n\t}\n\n\tgetInterpolation() {\n\n\t\tswitch ( this.createInterpolant ) {\n\n\t\t\tcase this.InterpolantFactoryMethodDiscrete:\n\n\t\t\t\treturn InterpolateDiscrete;\n\n\t\t\tcase this.InterpolantFactoryMethodLinear:\n\n\t\t\t\treturn InterpolateLinear;\n\n\t\t\tcase this.InterpolantFactoryMethodSmooth:\n\n\t\t\t\treturn InterpolateSmooth;\n\n\t\t}\n\n\t}\n\n\tgetValueSize() {\n\n\t\treturn this.values.length / this.times.length;\n\n\t}\n\n\t// move all keyframes either forwards or backwards in time\n\tshift( timeOffset ) {\n\n\t\tif ( timeOffset !== 0.0 ) {\n\n\t\t\tconst times = this.times;\n\n\t\t\tfor ( let i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] += timeOffset;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\tscale( timeScale ) {\n\n\t\tif ( timeScale !== 1.0 ) {\n\n\t\t\tconst times = this.times;\n\n\t\t\tfor ( let i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] *= timeScale;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\ttrim( startTime, endTime ) {\n\n\t\tconst times = this.times,\n\t\t\tnKeys = times.length;\n\n\t\tlet from = 0,\n\t\t\tto = nKeys - 1;\n\n\t\twhile ( from !== nKeys && times[ from ] < startTime ) {\n\n\t\t\t++ from;\n\n\t\t}\n\n\t\twhile ( to !== - 1 && times[ to ] > endTime ) {\n\n\t\t\t-- to;\n\n\t\t}\n\n\t\t++ to; // inclusive -> exclusive bound\n\n\t\tif ( from !== 0 || to !== nKeys ) {\n\n\t\t\t// empty tracks are forbidden, so keep at least one keyframe\n\t\t\tif ( from >= to ) {\n\n\t\t\t\tto = Math.max( to, 1 );\n\t\t\t\tfrom = to - 1;\n\n\t\t\t}\n\n\t\t\tconst stride = this.getValueSize();\n\t\t\tthis.times = times.slice( from, to );\n\t\t\tthis.values = this.values.slice( from * stride, to * stride );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\tvalidate() {\n\n\t\tlet valid = true;\n\n\t\tconst valueSize = this.getValueSize();\n\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\n\n\t\t\tconsole.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tconst times = this.times,\n\t\t\tvalues = this.values,\n\n\t\t\tnKeys = times.length;\n\n\t\tif ( nKeys === 0 ) {\n\n\t\t\tconsole.error( 'THREE.KeyframeTrack: Track is empty.', this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tlet prevTime = null;\n\n\t\tfor ( let i = 0; i !== nKeys; i ++ ) {\n\n\t\t\tconst currTime = times[ i ];\n\n\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\n\n\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( prevTime !== null && prevTime > currTime ) {\n\n\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tprevTime = currTime;\n\n\t\t}\n\n\t\tif ( values !== undefined ) {\n\n\t\t\tif ( isTypedArray( values ) ) {\n\n\t\t\t\tfor ( let i = 0, n = values.length; i !== n; ++ i ) {\n\n\t\t\t\t\tconst value = values[ i ];\n\n\t\t\t\t\tif ( isNaN( value ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn valid;\n\n\t}\n\n\t// removes equivalent sequential keys as common in morph target sequences\n\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n\toptimize() {\n\n\t\t// times or values may be shared with other tracks, so overwriting is unsafe\n\t\tconst times = this.times.slice(),\n\t\t\tvalues = this.values.slice(),\n\t\t\tstride = this.getValueSize(),\n\n\t\t\tsmoothInterpolation = this.getInterpolation() === InterpolateSmooth,\n\n\t\t\tlastIndex = times.length - 1;\n\n\t\tlet writeIndex = 1;\n\n\t\tfor ( let i = 1; i < lastIndex; ++ i ) {\n\n\t\t\tlet keep = false;\n\n\t\t\tconst time = times[ i ];\n\t\t\tconst timeNext = times[ i + 1 ];\n\n\t\t\t// remove adjacent keyframes scheduled at the same time\n\n\t\t\tif ( time !== timeNext && ( i !== 1 || time !== times[ 0 ] ) ) {\n\n\t\t\t\tif ( ! smoothInterpolation ) {\n\n\t\t\t\t\t// remove unnecessary keyframes same as their neighbors\n\n\t\t\t\t\tconst offset = i * stride,\n\t\t\t\t\t\toffsetP = offset - stride,\n\t\t\t\t\t\toffsetN = offset + stride;\n\n\t\t\t\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\tconst value = values[ offset + j ];\n\n\t\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\n\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\n\n\t\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tkeep = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// in-place compaction\n\n\t\t\tif ( keep ) {\n\n\t\t\t\tif ( i !== writeIndex ) {\n\n\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\n\n\t\t\t\t\tconst readOffset = i * stride,\n\t\t\t\t\t\twriteOffset = writeIndex * stride;\n\n\t\t\t\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t++ writeIndex;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// flush last keyframe (compaction looks ahead)\n\n\t\tif ( lastIndex > 0 ) {\n\n\t\t\ttimes[ writeIndex ] = times[ lastIndex ];\n\n\t\t\tfor ( let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {\n\n\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t}\n\n\t\t\t++ writeIndex;\n\n\t\t}\n\n\t\tif ( writeIndex !== times.length ) {\n\n\t\t\tthis.times = times.slice( 0, writeIndex );\n\t\t\tthis.values = values.slice( 0, writeIndex * stride );\n\n\t\t} else {\n\n\t\t\tthis.times = times;\n\t\t\tthis.values = values;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\tconst times = this.times.slice();\n\t\tconst values = this.values.slice();\n\n\t\tconst TypedKeyframeTrack = this.constructor;\n\t\tconst track = new TypedKeyframeTrack( this.name, times, values );\n\n\t\t// Interpolant argument to constructor is not saved, so copy the factory method directly.\n\t\ttrack.createInterpolant = this.createInterpolant;\n\n\t\treturn track;\n\n\t}\n\n}\n\nKeyframeTrack.prototype.TimeBufferType = Float32Array;\nKeyframeTrack.prototype.ValueBufferType = Float32Array;\nKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;\n\n/**\n * A Track of Boolean keyframe values.\n */\nclass BooleanKeyframeTrack extends KeyframeTrack {\n\n\t// No interpolation parameter because only InterpolateDiscrete is valid.\n\tconstructor( name, times, values ) {\n\n\t\tsuper( name, times, values );\n\n\t}\n\n}\n\nBooleanKeyframeTrack.prototype.ValueTypeName = 'bool';\nBooleanKeyframeTrack.prototype.ValueBufferType = Array;\nBooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;\nBooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;\nBooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\n/**\n * A Track of keyframe values that represent color.\n */\nclass ColorKeyframeTrack extends KeyframeTrack {}\n\nColorKeyframeTrack.prototype.ValueTypeName = 'color';\n\n/**\n * A Track of numeric keyframe values.\n */\nclass NumberKeyframeTrack extends KeyframeTrack {}\n\nNumberKeyframeTrack.prototype.ValueTypeName = 'number';\n\n/**\n * Spherical linear unit quaternion interpolant.\n */\n\nclass QuaternionLinearInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\talpha = ( t - t0 ) / ( t1 - t0 );\n\n\t\tlet offset = i1 * stride;\n\n\t\tfor ( let end = offset + stride; offset !== end; offset += 4 ) {\n\n\t\t\tQuaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\n/**\n * A Track of quaternion keyframe values.\n */\nclass QuaternionKeyframeTrack extends KeyframeTrack {\n\n\tInterpolantFactoryMethodLinear( result ) {\n\n\t\treturn new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n}\n\nQuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';\n// ValueBufferType is inherited\n// DefaultInterpolation is inherited;\nQuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\n/**\n * A Track that interpolates Strings\n */\nclass StringKeyframeTrack extends KeyframeTrack {\n\n\t// No interpolation parameter because only InterpolateDiscrete is valid.\n\tconstructor( name, times, values ) {\n\n\t\tsuper( name, times, values );\n\n\t}\n\n}\n\nStringKeyframeTrack.prototype.ValueTypeName = 'string';\nStringKeyframeTrack.prototype.ValueBufferType = Array;\nStringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;\nStringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;\nStringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\n/**\n * A Track of vectored keyframe values.\n */\nclass VectorKeyframeTrack extends KeyframeTrack {}\n\nVectorKeyframeTrack.prototype.ValueTypeName = 'vector';\n\nclass AnimationClip {\n\n\tconstructor( name = '', duration = - 1, tracks = [], blendMode = NormalAnimationBlendMode ) {\n\n\t\tthis.name = name;\n\t\tthis.tracks = tracks;\n\t\tthis.duration = duration;\n\t\tthis.blendMode = blendMode;\n\n\t\tthis.uuid = generateUUID();\n\n\t\t// this means it should figure out its duration by scanning the tracks\n\t\tif ( this.duration < 0 ) {\n\n\t\t\tthis.resetDuration();\n\n\t\t}\n\n\t}\n\n\n\tstatic parse( json ) {\n\n\t\tconst tracks = [],\n\t\t\tjsonTracks = json.tracks,\n\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\n\n\t\tfor ( let i = 0, n = jsonTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );\n\n\t\t}\n\n\t\tconst clip = new this( json.name, json.duration, tracks, json.blendMode );\n\t\tclip.uuid = json.uuid;\n\n\t\treturn clip;\n\n\t}\n\n\tstatic toJSON( clip ) {\n\n\t\tconst tracks = [],\n\t\t\tclipTracks = clip.tracks;\n\n\t\tconst json = {\n\n\t\t\t'name': clip.name,\n\t\t\t'duration': clip.duration,\n\t\t\t'tracks': tracks,\n\t\t\t'uuid': clip.uuid,\n\t\t\t'blendMode': clip.blendMode\n\n\t\t};\n\n\t\tfor ( let i = 0, n = clipTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );\n\n\t\t}\n\n\t\treturn json;\n\n\t}\n\n\tstatic CreateFromMorphTargetSequence( name, morphTargetSequence, fps, noLoop ) {\n\n\t\tconst numMorphTargets = morphTargetSequence.length;\n\t\tconst tracks = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; i ++ ) {\n\n\t\t\tlet times = [];\n\t\t\tlet values = [];\n\n\t\t\ttimes.push(\n\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\n\t\t\t\ti,\n\t\t\t\t( i + 1 ) % numMorphTargets );\n\n\t\t\tvalues.push( 0, 1, 0 );\n\n\t\t\tconst order = getKeyframeOrder( times );\n\t\t\ttimes = sortedArray( times, 1, order );\n\t\t\tvalues = sortedArray( values, 1, order );\n\n\t\t\t// if there is a key at the first frame, duplicate it as the\n\t\t\t// last frame as well for perfect loop.\n\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\n\n\t\t\t\ttimes.push( numMorphTargets );\n\t\t\t\tvalues.push( values[ 0 ] );\n\n\t\t\t}\n\n\t\t\ttracks.push(\n\t\t\t\tnew NumberKeyframeTrack(\n\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\n\t\t\t\t\ttimes, values\n\t\t\t\t).scale( 1.0 / fps ) );\n\n\t\t}\n\n\t\treturn new this( name, - 1, tracks );\n\n\t}\n\n\tstatic findByName( objectOrClipArray, name ) {\n\n\t\tlet clipArray = objectOrClipArray;\n\n\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\n\n\t\t\tconst o = objectOrClipArray;\n\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < clipArray.length; i ++ ) {\n\n\t\t\tif ( clipArray[ i ].name === name ) {\n\n\t\t\t\treturn clipArray[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tstatic CreateClipsFromMorphTargetSequences( morphTargets, fps, noLoop ) {\n\n\t\tconst animationToMorphTargets = {};\n\n\t\t// tested with https://regex101.com/ on trick sequences\n\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\t\tconst pattern = /^([\\w-]*?)([\\d]+)$/;\n\n\t\t// sort morph target names into animation groups based\n\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\n\t\tfor ( let i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n\t\t\tconst morphTarget = morphTargets[ i ];\n\t\t\tconst parts = morphTarget.name.match( pattern );\n\n\t\t\tif ( parts && parts.length > 1 ) {\n\n\t\t\t\tconst name = parts[ 1 ];\n\n\t\t\t\tlet animationMorphTargets = animationToMorphTargets[ name ];\n\n\t\t\t\tif ( ! animationMorphTargets ) {\n\n\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\n\n\t\t\t\t}\n\n\t\t\t\tanimationMorphTargets.push( morphTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst clips = [];\n\n\t\tfor ( const name in animationToMorphTargets ) {\n\n\t\t\tclips.push( this.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\n\n\t\t}\n\n\t\treturn clips;\n\n\t}\n\n\t// parse the animation.hierarchy format\n\tstatic parseAnimation( animation, bones ) {\n\n\t\tif ( ! animation ) {\n\n\t\t\tconsole.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {\n\n\t\t\t// only return track if there are actually keys.\n\t\t\tif ( animationKeys.length !== 0 ) {\n\n\t\t\t\tconst times = [];\n\t\t\t\tconst values = [];\n\n\t\t\t\tflattenJSON( animationKeys, times, values, propertyName );\n\n\t\t\t\t// empty keys are filtered out, so check again\n\t\t\t\tif ( times.length !== 0 ) {\n\n\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tconst tracks = [];\n\n\t\tconst clipName = animation.name || 'default';\n\t\tconst fps = animation.fps || 30;\n\t\tconst blendMode = animation.blendMode;\n\n\t\t// automatic length determination in AnimationClip.\n\t\tlet duration = animation.length || - 1;\n\n\t\tconst hierarchyTracks = animation.hierarchy || [];\n\n\t\tfor ( let h = 0; h < hierarchyTracks.length; h ++ ) {\n\n\t\t\tconst animationKeys = hierarchyTracks[ h ].keys;\n\n\t\t\t// skip empty tracks\n\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\n\n\t\t\t// process morph targets\n\t\t\tif ( animationKeys[ 0 ].morphTargets ) {\n\n\t\t\t\t// figure out all morph targets used in this track\n\t\t\t\tconst morphTargetNames = {};\n\n\t\t\t\tlet k;\n\n\t\t\t\tfor ( k = 0; k < animationKeys.length; k ++ ) {\n\n\t\t\t\t\tif ( animationKeys[ k ].morphTargets ) {\n\n\t\t\t\t\t\tfor ( let m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// create a track for each morph target with all zero\n\t\t\t\t// morphTargetInfluences except for the keys in which\n\t\t\t\t// the morphTarget is named.\n\t\t\t\tfor ( const morphTargetName in morphTargetNames ) {\n\n\t\t\t\t\tconst times = [];\n\t\t\t\t\tconst values = [];\n\n\t\t\t\t\tfor ( let m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {\n\n\t\t\t\t\t\tconst animationKey = animationKeys[ k ];\n\n\t\t\t\t\t\ttimes.push( animationKey.time );\n\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\n\n\t\t\t\t}\n\n\t\t\t\tduration = morphTargetNames.length * fps;\n\n\t\t\t} else {\n\n\t\t\t\t// ...assume skeletal animation\n\n\t\t\t\tconst boneName = '.bones[' + bones[ h ].name + ']';\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tVectorKeyframeTrack, boneName + '.position',\n\t\t\t\t\tanimationKeys, 'pos', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tQuaternionKeyframeTrack, boneName + '.quaternion',\n\t\t\t\t\tanimationKeys, 'rot', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tVectorKeyframeTrack, boneName + '.scale',\n\t\t\t\t\tanimationKeys, 'scl', tracks );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tracks.length === 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst clip = new this( clipName, duration, tracks, blendMode );\n\n\t\treturn clip;\n\n\t}\n\n\tresetDuration() {\n\n\t\tconst tracks = this.tracks;\n\t\tlet duration = 0;\n\n\t\tfor ( let i = 0, n = tracks.length; i !== n; ++ i ) {\n\n\t\t\tconst track = this.tracks[ i ];\n\n\t\t\tduration = Math.max( duration, track.times[ track.times.length - 1 ] );\n\n\t\t}\n\n\t\tthis.duration = duration;\n\n\t\treturn this;\n\n\t}\n\n\ttrim() {\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].trim( 0, this.duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tvalidate() {\n\n\t\tlet valid = true;\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tvalid = valid && this.tracks[ i ].validate();\n\n\t\t}\n\n\t\treturn valid;\n\n\t}\n\n\toptimize() {\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].optimize();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\tconst tracks = [];\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\ttracks.push( this.tracks[ i ].clone() );\n\n\t\t}\n\n\t\treturn new this.constructor( this.name, this.duration, tracks, this.blendMode );\n\n\t}\n\n\ttoJSON() {\n\n\t\treturn this.constructor.toJSON( this );\n\n\t}\n\n}\n\nfunction getTrackTypeForValueTypeName( typeName ) {\n\n\tswitch ( typeName.toLowerCase() ) {\n\n\t\tcase 'scalar':\n\t\tcase 'double':\n\t\tcase 'float':\n\t\tcase 'number':\n\t\tcase 'integer':\n\n\t\t\treturn NumberKeyframeTrack;\n\n\t\tcase 'vector':\n\t\tcase 'vector2':\n\t\tcase 'vector3':\n\t\tcase 'vector4':\n\n\t\t\treturn VectorKeyframeTrack;\n\n\t\tcase 'color':\n\n\t\t\treturn ColorKeyframeTrack;\n\n\t\tcase 'quaternion':\n\n\t\t\treturn QuaternionKeyframeTrack;\n\n\t\tcase 'bool':\n\t\tcase 'boolean':\n\n\t\t\treturn BooleanKeyframeTrack;\n\n\t\tcase 'string':\n\n\t\t\treturn StringKeyframeTrack;\n\n\t}\n\n\tthrow new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );\n\n}\n\nfunction parseKeyframeTrack( json ) {\n\n\tif ( json.type === undefined ) {\n\n\t\tthrow new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );\n\n\t}\n\n\tconst trackType = getTrackTypeForValueTypeName( json.type );\n\n\tif ( json.times === undefined ) {\n\n\t\tconst times = [], values = [];\n\n\t\tflattenJSON( json.keys, times, values, 'value' );\n\n\t\tjson.times = times;\n\t\tjson.values = values;\n\n\t}\n\n\t// derived classes can define a static parse method\n\tif ( trackType.parse !== undefined ) {\n\n\t\treturn trackType.parse( json );\n\n\t} else {\n\n\t\t// by default, we assume a constructor compatible with the base\n\t\treturn new trackType( json.name, json.times, json.values, json.interpolation );\n\n\t}\n\n}\n\nconst Cache = {\n\n\tenabled: false,\n\n\tfiles: {},\n\n\tadd: function ( key, file ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\n\n\t\tthis.files[ key ] = file;\n\n\t},\n\n\tget: function ( key ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\n\n\t\treturn this.files[ key ];\n\n\t},\n\n\tremove: function ( key ) {\n\n\t\tdelete this.files[ key ];\n\n\t},\n\n\tclear: function () {\n\n\t\tthis.files = {};\n\n\t}\n\n};\n\nclass LoadingManager {\n\n\tconstructor( onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tlet isLoading = false;\n\t\tlet itemsLoaded = 0;\n\t\tlet itemsTotal = 0;\n\t\tlet urlModifier = undefined;\n\t\tconst handlers = [];\n\n\t\t// Refer to #5689 for the reason why we don't set .onStart\n\t\t// in the constructor\n\n\t\tthis.onStart = undefined;\n\t\tthis.onLoad = onLoad;\n\t\tthis.onProgress = onProgress;\n\t\tthis.onError = onError;\n\n\t\tthis.itemStart = function ( url ) {\n\n\t\t\titemsTotal ++;\n\n\t\t\tif ( isLoading === false ) {\n\n\t\t\t\tif ( scope.onStart !== undefined ) {\n\n\t\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tisLoading = true;\n\n\t\t};\n\n\t\tthis.itemEnd = function ( url ) {\n\n\t\t\titemsLoaded ++;\n\n\t\t\tif ( scope.onProgress !== undefined ) {\n\n\t\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\n\n\t\t\t}\n\n\t\t\tif ( itemsLoaded === itemsTotal ) {\n\n\t\t\t\tisLoading = false;\n\n\t\t\t\tif ( scope.onLoad !== undefined ) {\n\n\t\t\t\t\tscope.onLoad();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.itemError = function ( url ) {\n\n\t\t\tif ( scope.onError !== undefined ) {\n\n\t\t\t\tscope.onError( url );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.resolveURL = function ( url ) {\n\n\t\t\tif ( urlModifier ) {\n\n\t\t\t\treturn urlModifier( url );\n\n\t\t\t}\n\n\t\t\treturn url;\n\n\t\t};\n\n\t\tthis.setURLModifier = function ( transform ) {\n\n\t\t\turlModifier = transform;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t\tthis.addHandler = function ( regex, loader ) {\n\n\t\t\thandlers.push( regex, loader );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t\tthis.removeHandler = function ( regex ) {\n\n\t\t\tconst index = handlers.indexOf( regex );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\thandlers.splice( index, 2 );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t};\n\n\t\tthis.getHandler = function ( file ) {\n\n\t\t\tfor ( let i = 0, l = handlers.length; i < l; i += 2 ) {\n\n\t\t\t\tconst regex = handlers[ i ];\n\t\t\t\tconst loader = handlers[ i + 1 ];\n\n\t\t\t\tif ( regex.global ) regex.lastIndex = 0; // see #17920\n\n\t\t\t\tif ( regex.test( file ) ) {\n\n\t\t\t\t\treturn loader;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t};\n\n\t}\n\n}\n\nconst DefaultLoadingManager = /*@__PURE__*/ new LoadingManager();\n\nclass Loader {\n\n\tconstructor( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t\tthis.crossOrigin = 'anonymous';\n\t\tthis.withCredentials = false;\n\t\tthis.path = '';\n\t\tthis.resourcePath = '';\n\t\tthis.requestHeader = {};\n\n\t}\n\n\tload( /* url, onLoad, onProgress, onError */ ) {}\n\n\tloadAsync( url, onProgress ) {\n\n\t\tconst scope = this;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tscope.load( url, resolve, onProgress, reject );\n\n\t\t} );\n\n\t}\n\n\tparse( /* data */ ) {}\n\n\tsetCrossOrigin( crossOrigin ) {\n\n\t\tthis.crossOrigin = crossOrigin;\n\t\treturn this;\n\n\t}\n\n\tsetWithCredentials( value ) {\n\n\t\tthis.withCredentials = value;\n\t\treturn this;\n\n\t}\n\n\tsetPath( path ) {\n\n\t\tthis.path = path;\n\t\treturn this;\n\n\t}\n\n\tsetResourcePath( resourcePath ) {\n\n\t\tthis.resourcePath = resourcePath;\n\t\treturn this;\n\n\t}\n\n\tsetRequestHeader( requestHeader ) {\n\n\t\tthis.requestHeader = requestHeader;\n\t\treturn this;\n\n\t}\n\n}\n\nLoader.DEFAULT_MATERIAL_NAME = '__DEFAULT';\n\nconst loading = {};\n\nclass HttpError extends Error {\n\n\tconstructor( message, response ) {\n\n\t\tsuper( message );\n\t\tthis.response = response;\n\n\t}\n\n}\n\nclass FileLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tif ( url === undefined ) url = '';\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\turl = this.manager.resolveURL( url );\n\n\t\tconst cached = Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tthis.manager.itemStart( url );\n\n\t\t\tsetTimeout( () => {\n\n\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\tthis.manager.itemEnd( url );\n\n\t\t\t}, 0 );\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\t// Check if request is duplicate\n\n\t\tif ( loading[ url ] !== undefined ) {\n\n\t\t\tloading[ url ].push( {\n\n\t\t\t\tonLoad: onLoad,\n\t\t\t\tonProgress: onProgress,\n\t\t\t\tonError: onError\n\n\t\t\t} );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// Initialise array for duplicate requests\n\t\tloading[ url ] = [];\n\n\t\tloading[ url ].push( {\n\t\t\tonLoad: onLoad,\n\t\t\tonProgress: onProgress,\n\t\t\tonError: onError,\n\t\t} );\n\n\t\t// create request\n\t\tconst req = new Request( url, {\n\t\t\theaders: new Headers( this.requestHeader ),\n\t\t\tcredentials: this.withCredentials ? 'include' : 'same-origin',\n\t\t\t// An abort controller could be added within a future PR\n\t\t} );\n\n\t\t// record states ( avoid data race )\n\t\tconst mimeType = this.mimeType;\n\t\tconst responseType = this.responseType;\n\n\t\t// start the fetch\n\t\tfetch( req )\n\t\t\t.then( response => {\n\n\t\t\t\tif ( response.status === 200 || response.status === 0 ) {\n\n\t\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\n\t\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\n\n\t\t\t\t\tif ( response.status === 0 ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.FileLoader: HTTP Status 0 received.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Workaround: Checking if response.body === undefined for Alipay browser #23548\n\n\t\t\t\t\tif ( typeof ReadableStream === 'undefined' || response.body === undefined || response.body.getReader === undefined ) {\n\n\t\t\t\t\t\treturn response;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst callbacks = loading[ url ];\n\t\t\t\t\tconst reader = response.body.getReader();\n\n\t\t\t\t\t// Nginx needs X-File-Size check\n\t\t\t\t\t// https://serverfault.com/questions/482875/why-does-nginx-remove-content-length-header-for-chunked-content\n\t\t\t\t\tconst contentLength = response.headers.get( 'X-File-Size' ) || response.headers.get( 'Content-Length' );\n\t\t\t\t\tconst total = contentLength ? parseInt( contentLength ) : 0;\n\t\t\t\t\tconst lengthComputable = total !== 0;\n\t\t\t\t\tlet loaded = 0;\n\n\t\t\t\t\t// periodically read data into the new stream tracking while download progress\n\t\t\t\t\tconst stream = new ReadableStream( {\n\t\t\t\t\t\tstart( controller ) {\n\n\t\t\t\t\t\t\treadData();\n\n\t\t\t\t\t\t\tfunction readData() {\n\n\t\t\t\t\t\t\t\treader.read().then( ( { done, value } ) => {\n\n\t\t\t\t\t\t\t\t\tif ( done ) {\n\n\t\t\t\t\t\t\t\t\t\tcontroller.close();\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tloaded += value.byteLength;\n\n\t\t\t\t\t\t\t\t\t\tconst event = new ProgressEvent( 'progress', { lengthComputable, loaded, total } );\n\t\t\t\t\t\t\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\t\t\t\t\t\t\tif ( callback.onProgress ) callback.onProgress( event );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tcontroller.enqueue( value );\n\t\t\t\t\t\t\t\t\t\treadData();\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}, ( e ) => {\n\n\t\t\t\t\t\t\t\t\tcontroller.error( e );\n\n\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t\treturn new Response( stream );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new HttpError( `fetch for \"${response.url}\" responded with ${response.status}: ${response.statusText}`, response );\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.then( response => {\n\n\t\t\t\tswitch ( responseType ) {\n\n\t\t\t\t\tcase 'arraybuffer':\n\n\t\t\t\t\t\treturn response.arrayBuffer();\n\n\t\t\t\t\tcase 'blob':\n\n\t\t\t\t\t\treturn response.blob();\n\n\t\t\t\t\tcase 'document':\n\n\t\t\t\t\t\treturn response.text()\n\t\t\t\t\t\t\t.then( text => {\n\n\t\t\t\t\t\t\t\tconst parser = new DOMParser();\n\t\t\t\t\t\t\t\treturn parser.parseFromString( text, mimeType );\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\tcase 'json':\n\n\t\t\t\t\t\treturn response.json();\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tif ( mimeType === undefined ) {\n\n\t\t\t\t\t\t\treturn response.text();\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// sniff encoding\n\t\t\t\t\t\t\tconst re = /charset=\"?([^;\"\\s]*)\"?/i;\n\t\t\t\t\t\t\tconst exec = re.exec( mimeType );\n\t\t\t\t\t\t\tconst label = exec && exec[ 1 ] ? exec[ 1 ].toLowerCase() : undefined;\n\t\t\t\t\t\t\tconst decoder = new TextDecoder( label );\n\t\t\t\t\t\t\treturn response.arrayBuffer().then( ab => decoder.decode( ab ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.then( data => {\n\n\t\t\t\t// Add to cache only on HTTP success, so that we do not cache\n\t\t\t\t// error response bodies as proper responses to requests.\n\t\t\t\tCache.add( url, data );\n\n\t\t\t\tconst callbacks = loading[ url ];\n\t\t\t\tdelete loading[ url ];\n\n\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\tif ( callback.onLoad ) callback.onLoad( data );\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.catch( err => {\n\n\t\t\t\t// Abort errors and other errors are handled the same\n\n\t\t\t\tconst callbacks = loading[ url ];\n\n\t\t\t\tif ( callbacks === undefined ) {\n\n\t\t\t\t\t// When onLoad was called and url was deleted in `loading`\n\t\t\t\t\tthis.manager.itemError( url );\n\t\t\t\t\tthrow err;\n\n\t\t\t\t}\n\n\t\t\t\tdelete loading[ url ];\n\n\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\tif ( callback.onError ) callback.onError( err );\n\n\t\t\t\t}\n\n\t\t\t\tthis.manager.itemError( url );\n\n\t\t\t} )\n\t\t\t.finally( () => {\n\n\t\t\t\tthis.manager.itemEnd( url );\n\n\t\t\t} );\n\n\t\tthis.manager.itemStart( url );\n\n\t}\n\n\tsetResponseType( value ) {\n\n\t\tthis.responseType = value;\n\t\treturn this;\n\n\t}\n\n\tsetMimeType( value ) {\n\n\t\tthis.mimeType = value;\n\t\treturn this;\n\n\t}\n\n}\n\nclass AnimationLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( json ) {\n\n\t\tconst animations = [];\n\n\t\tfor ( let i = 0; i < json.length; i ++ ) {\n\n\t\t\tconst clip = AnimationClip.parse( json[ i ] );\n\n\t\t\tanimations.push( clip );\n\n\t\t}\n\n\t\treturn animations;\n\n\t}\n\n}\n\n/**\n * Abstract Base class to block based textures loader (dds, pvr, ...)\n *\n * Sub classes have to implement the parse() method which will be used in load().\n */\n\nclass CompressedTextureLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst images = [];\n\n\t\tconst texture = new CompressedTexture();\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\n\t\tlet loaded = 0;\n\n\t\tfunction loadTexture( i ) {\n\n\t\t\tloader.load( url[ i ], function ( buffer ) {\n\n\t\t\t\tconst texDatas = scope.parse( buffer, true );\n\n\t\t\t\timages[ i ] = {\n\t\t\t\t\twidth: texDatas.width,\n\t\t\t\t\theight: texDatas.height,\n\t\t\t\t\tformat: texDatas.format,\n\t\t\t\t\tmipmaps: texDatas.mipmaps\n\t\t\t\t};\n\n\t\t\t\tloaded += 1;\n\n\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 ) texture.minFilter = LinearFilter;\n\n\t\t\t\t\ttexture.image = images;\n\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\tif ( Array.isArray( url ) ) {\n\n\t\t\tfor ( let i = 0, il = url.length; i < il; ++ i ) {\n\n\t\t\t\tloadTexture( i );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// compressed cubemap texture stored in a single DDS file\n\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tconst texDatas = scope.parse( buffer, true );\n\n\t\t\t\tif ( texDatas.isCubemap ) {\n\n\t\t\t\t\tconst faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\n\t\t\t\t\tfor ( let f = 0; f < faces; f ++ ) {\n\n\t\t\t\t\t\timages[ f ] = { mipmaps: [] };\n\n\t\t\t\t\t\tfor ( let i = 0; i < texDatas.mipmapCount; i ++ ) {\n\n\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\n\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\n\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\n\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.image = images;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttexture.image.width = texDatas.width;\n\t\t\t\t\ttexture.image.height = texDatas.height;\n\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\n\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t\t}\n\n\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n}\n\nclass ImageLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\turl = this.manager.resolveURL( url );\n\n\t\tconst scope = this;\n\n\t\tconst cached = Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\tsetTimeout( function () {\n\n\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, 0 );\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\tconst image = createElementNS( 'img' );\n\n\t\tfunction onImageLoad() {\n\n\t\t\tremoveEventListeners();\n\n\t\t\tCache.add( url, this );\n\n\t\t\tif ( onLoad ) onLoad( this );\n\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t}\n\n\t\tfunction onImageError( event ) {\n\n\t\t\tremoveEventListeners();\n\n\t\t\tif ( onError ) onError( event );\n\n\t\t\tscope.manager.itemError( url );\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t}\n\n\t\tfunction removeEventListeners() {\n\n\t\t\timage.removeEventListener( 'load', onImageLoad, false );\n\t\t\timage.removeEventListener( 'error', onImageError, false );\n\n\t\t}\n\n\t\timage.addEventListener( 'load', onImageLoad, false );\n\t\timage.addEventListener( 'error', onImageError, false );\n\n\t\tif ( url.slice( 0, 5 ) !== 'data:' ) {\n\n\t\t\tif ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\n\n\t\t}\n\n\t\tscope.manager.itemStart( url );\n\n\t\timage.src = url;\n\n\t\treturn image;\n\n\t}\n\n}\n\nclass CubeTextureLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( urls, onLoad, onProgress, onError ) {\n\n\t\tconst texture = new CubeTexture();\n\t\ttexture.colorSpace = SRGBColorSpace;\n\n\t\tconst loader = new ImageLoader( this.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setPath( this.path );\n\n\t\tlet loaded = 0;\n\n\t\tfunction loadTexture( i ) {\n\n\t\t\tloader.load( urls[ i ], function ( image ) {\n\n\t\t\t\ttexture.images[ i ] = image;\n\n\t\t\t\tloaded ++;\n\n\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, undefined, onError );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < urls.length; ++ i ) {\n\n\t\t\tloadTexture( i );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n}\n\n/**\n * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n *\n * Sub classes have to implement the parse() method which will be used in load().\n */\n\nclass DataTextureLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst texture = new DataTexture();\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setPath( this.path );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\tlet texData;\n\n\t\t\ttry {\n\n\t\t\t\ttexData = scope.parse( buffer );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tif ( onError !== undefined ) {\n\n\t\t\t\t\tonError( error );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( error );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( texData.image !== undefined ) {\n\n\t\t\t\ttexture.image = texData.image;\n\n\t\t\t} else if ( texData.data !== undefined ) {\n\n\t\t\t\ttexture.image.width = texData.width;\n\t\t\t\ttexture.image.height = texData.height;\n\t\t\t\ttexture.image.data = texData.data;\n\n\t\t\t}\n\n\t\t\ttexture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;\n\t\t\ttexture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;\n\n\t\t\ttexture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;\n\t\t\ttexture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;\n\n\t\t\ttexture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;\n\n\t\t\tif ( texData.colorSpace !== undefined ) {\n\n\t\t\t\ttexture.colorSpace = texData.colorSpace;\n\n\t\t\t}\n\n\t\t\tif ( texData.flipY !== undefined ) {\n\n\t\t\t\ttexture.flipY = texData.flipY;\n\n\t\t\t}\n\n\t\t\tif ( texData.format !== undefined ) {\n\n\t\t\t\ttexture.format = texData.format;\n\n\t\t\t}\n\n\t\t\tif ( texData.type !== undefined ) {\n\n\t\t\t\ttexture.type = texData.type;\n\n\t\t\t}\n\n\t\t\tif ( texData.mipmaps !== undefined ) {\n\n\t\t\t\ttexture.mipmaps = texData.mipmaps;\n\t\t\t\ttexture.minFilter = LinearMipmapLinearFilter; // presumably...\n\n\t\t\t}\n\n\t\t\tif ( texData.mipmapCount === 1 ) {\n\n\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t}\n\n\t\t\tif ( texData.generateMipmaps !== undefined ) {\n\n\t\t\t\ttexture.generateMipmaps = texData.generateMipmaps;\n\n\t\t\t}\n\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t}, onProgress, onError );\n\n\n\t\treturn texture;\n\n\t}\n\n}\n\nclass TextureLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst texture = new Texture();\n\n\t\tconst loader = new ImageLoader( this.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setPath( this.path );\n\n\t\tloader.load( url, function ( image ) {\n\n\t\t\ttexture.image = image;\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad !== undefined ) {\n\n\t\t\t\tonLoad( texture );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t\treturn texture;\n\n\t}\n\n}\n\nclass Light extends Object3D {\n\n\tconstructor( color, intensity = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.isLight = true;\n\n\t\tthis.type = 'Light';\n\n\t\tthis.color = new Color( color );\n\t\tthis.intensity = intensity;\n\n\t}\n\n\tdispose() {\n\n\t\t// Empty here in base class; some subclasses override.\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.color.copy( source.color );\n\t\tthis.intensity = source.intensity;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.color = this.color.getHex();\n\t\tdata.object.intensity = this.intensity;\n\n\t\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\n\n\t\tif ( this.distance !== undefined ) data.object.distance = this.distance;\n\t\tif ( this.angle !== undefined ) data.object.angle = this.angle;\n\t\tif ( this.decay !== undefined ) data.object.decay = this.decay;\n\t\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\n\n\t\tif ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();\n\t\tif ( this.target !== undefined ) data.object.target = this.target.uuid;\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass HemisphereLight extends Light {\n\n\tconstructor( skyColor, groundColor, intensity ) {\n\n\t\tsuper( skyColor, intensity );\n\n\t\tthis.isHemisphereLight = true;\n\n\t\tthis.type = 'HemisphereLight';\n\n\t\tthis.position.copy( Object3D.DEFAULT_UP );\n\t\tthis.updateMatrix();\n\n\t\tthis.groundColor = new Color( groundColor );\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.groundColor.copy( source.groundColor );\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();\nconst _lightPositionWorld$1 = /*@__PURE__*/ new Vector3();\nconst _lookTarget$1 = /*@__PURE__*/ new Vector3();\n\nclass LightShadow {\n\n\tconstructor( camera ) {\n\n\t\tthis.camera = camera;\n\n\t\tthis.intensity = 1;\n\n\t\tthis.bias = 0;\n\t\tthis.normalBias = 0;\n\t\tthis.radius = 1;\n\t\tthis.blurSamples = 8;\n\n\t\tthis.mapSize = new Vector2( 512, 512 );\n\n\t\tthis.map = null;\n\t\tthis.mapPass = null;\n\t\tthis.matrix = new Matrix4();\n\n\t\tthis.autoUpdate = true;\n\t\tthis.needsUpdate = false;\n\n\t\tthis._frustum = new Frustum();\n\t\tthis._frameExtents = new Vector2( 1, 1 );\n\n\t\tthis._viewportCount = 1;\n\n\t\tthis._viewports = [\n\n\t\t\tnew Vector4( 0, 0, 1, 1 )\n\n\t\t];\n\n\t}\n\n\tgetViewportCount() {\n\n\t\treturn this._viewportCount;\n\n\t}\n\n\tgetFrustum() {\n\n\t\treturn this._frustum;\n\n\t}\n\n\tupdateMatrices( light ) {\n\n\t\tconst shadowCamera = this.camera;\n\t\tconst shadowMatrix = this.matrix;\n\n\t\t_lightPositionWorld$1.setFromMatrixPosition( light.matrixWorld );\n\t\tshadowCamera.position.copy( _lightPositionWorld$1 );\n\n\t\t_lookTarget$1.setFromMatrixPosition( light.target.matrixWorld );\n\t\tshadowCamera.lookAt( _lookTarget$1 );\n\t\tshadowCamera.updateMatrixWorld();\n\n\t\t_projScreenMatrix$1.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\n\t\tthis._frustum.setFromProjectionMatrix( _projScreenMatrix$1 );\n\n\t\tshadowMatrix.set(\n\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t);\n\n\t\tshadowMatrix.multiply( _projScreenMatrix$1 );\n\n\t}\n\n\tgetViewport( viewportIndex ) {\n\n\t\treturn this._viewports[ viewportIndex ];\n\n\t}\n\n\tgetFrameExtents() {\n\n\t\treturn this._frameExtents;\n\n\t}\n\n\tdispose() {\n\n\t\tif ( this.map ) {\n\n\t\t\tthis.map.dispose();\n\n\t\t}\n\n\t\tif ( this.mapPass ) {\n\n\t\t\tthis.mapPass.dispose();\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.camera = source.camera.clone();\n\n\t\tthis.intensity = source.intensity;\n\n\t\tthis.bias = source.bias;\n\t\tthis.radius = source.radius;\n\n\t\tthis.mapSize.copy( source.mapSize );\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst object = {};\n\n\t\tif ( this.intensity !== 1 ) object.intensity = this.intensity;\n\t\tif ( this.bias !== 0 ) object.bias = this.bias;\n\t\tif ( this.normalBias !== 0 ) object.normalBias = this.normalBias;\n\t\tif ( this.radius !== 1 ) object.radius = this.radius;\n\t\tif ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();\n\n\t\tobject.camera = this.camera.toJSON( false ).object;\n\t\tdelete object.camera.matrix;\n\n\t\treturn object;\n\n\t}\n\n}\n\nclass SpotLightShadow extends LightShadow {\n\n\tconstructor() {\n\n\t\tsuper( new PerspectiveCamera( 50, 1, 0.5, 500 ) );\n\n\t\tthis.isSpotLightShadow = true;\n\n\t\tthis.focus = 1;\n\n\t}\n\n\tupdateMatrices( light ) {\n\n\t\tconst camera = this.camera;\n\n\t\tconst fov = RAD2DEG * 2 * light.angle * this.focus;\n\t\tconst aspect = this.mapSize.width / this.mapSize.height;\n\t\tconst far = light.distance || camera.far;\n\n\t\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\n\n\t\t\tcamera.fov = fov;\n\t\t\tcamera.aspect = aspect;\n\t\t\tcamera.far = far;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t}\n\n\t\tsuper.updateMatrices( light );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.focus = source.focus;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass SpotLight extends Light {\n\n\tconstructor( color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 2 ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.isSpotLight = true;\n\n\t\tthis.type = 'SpotLight';\n\n\t\tthis.position.copy( Object3D.DEFAULT_UP );\n\t\tthis.updateMatrix();\n\n\t\tthis.target = new Object3D();\n\n\t\tthis.distance = distance;\n\t\tthis.angle = angle;\n\t\tthis.penumbra = penumbra;\n\t\tthis.decay = decay;\n\n\t\tthis.map = null;\n\n\t\tthis.shadow = new SpotLightShadow();\n\n\t}\n\n\tget power() {\n\n\t\t// compute the light's luminous power (in lumens) from its intensity (in candela)\n\t\t// by convention for a spotlight, luminous power (lm) = π * luminous intensity (cd)\n\t\treturn this.intensity * Math.PI;\n\n\t}\n\n\tset power( power ) {\n\n\t\t// set the light's intensity (in candela) from the desired luminous power (in lumens)\n\t\tthis.intensity = power / Math.PI;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.shadow.dispose();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.distance = source.distance;\n\t\tthis.angle = source.angle;\n\t\tthis.penumbra = source.penumbra;\n\t\tthis.decay = source.decay;\n\n\t\tthis.target = source.target.clone();\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _projScreenMatrix = /*@__PURE__*/ new Matrix4();\nconst _lightPositionWorld = /*@__PURE__*/ new Vector3();\nconst _lookTarget = /*@__PURE__*/ new Vector3();\n\nclass PointLightShadow extends LightShadow {\n\n\tconstructor() {\n\n\t\tsuper( new PerspectiveCamera( 90, 1, 0.5, 500 ) );\n\n\t\tthis.isPointLightShadow = true;\n\n\t\tthis._frameExtents = new Vector2( 4, 2 );\n\n\t\tthis._viewportCount = 6;\n\n\t\tthis._viewports = [\n\t\t\t// These viewports map a cube-map onto a 2D texture with the\n\t\t\t// following orientation:\n\t\t\t//\n\t\t\t//  xzXZ\n\t\t\t//   y Y\n\t\t\t//\n\t\t\t// X - Positive x direction\n\t\t\t// x - Negative x direction\n\t\t\t// Y - Positive y direction\n\t\t\t// y - Negative y direction\n\t\t\t// Z - Positive z direction\n\t\t\t// z - Negative z direction\n\n\t\t\t// positive X\n\t\t\tnew Vector4( 2, 1, 1, 1 ),\n\t\t\t// negative X\n\t\t\tnew Vector4( 0, 1, 1, 1 ),\n\t\t\t// positive Z\n\t\t\tnew Vector4( 3, 1, 1, 1 ),\n\t\t\t// negative Z\n\t\t\tnew Vector4( 1, 1, 1, 1 ),\n\t\t\t// positive Y\n\t\t\tnew Vector4( 3, 0, 1, 1 ),\n\t\t\t// negative Y\n\t\t\tnew Vector4( 1, 0, 1, 1 )\n\t\t];\n\n\t\tthis._cubeDirections = [\n\t\t\tnew Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),\n\t\t\tnew Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )\n\t\t];\n\n\t\tthis._cubeUps = [\n\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),\n\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),\tnew Vector3( 0, 0, - 1 )\n\t\t];\n\n\t}\n\n\tupdateMatrices( light, viewportIndex = 0 ) {\n\n\t\tconst camera = this.camera;\n\t\tconst shadowMatrix = this.matrix;\n\n\t\tconst far = light.distance || camera.far;\n\n\t\tif ( far !== camera.far ) {\n\n\t\t\tcamera.far = far;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t}\n\n\t\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\n\t\tcamera.position.copy( _lightPositionWorld );\n\n\t\t_lookTarget.copy( camera.position );\n\t\t_lookTarget.add( this._cubeDirections[ viewportIndex ] );\n\t\tcamera.up.copy( this._cubeUps[ viewportIndex ] );\n\t\tcamera.lookAt( _lookTarget );\n\t\tcamera.updateMatrixWorld();\n\n\t\tshadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );\n\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\tthis._frustum.setFromProjectionMatrix( _projScreenMatrix );\n\n\t}\n\n}\n\nclass PointLight extends Light {\n\n\tconstructor( color, intensity, distance = 0, decay = 2 ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.isPointLight = true;\n\n\t\tthis.type = 'PointLight';\n\n\t\tthis.distance = distance;\n\t\tthis.decay = decay;\n\n\t\tthis.shadow = new PointLightShadow();\n\n\t}\n\n\tget power() {\n\n\t\t// compute the light's luminous power (in lumens) from its intensity (in candela)\n\t\t// for an isotropic light source, luminous power (lm) = 4 π luminous intensity (cd)\n\t\treturn this.intensity * 4 * Math.PI;\n\n\t}\n\n\tset power( power ) {\n\n\t\t// set the light's intensity (in candela) from the desired luminous power (in lumens)\n\t\tthis.intensity = power / ( 4 * Math.PI );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.shadow.dispose();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.distance = source.distance;\n\t\tthis.decay = source.decay;\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass OrthographicCamera extends Camera {\n\n\tconstructor( left = - 1, right = 1, top = 1, bottom = - 1, near = 0.1, far = 2000 ) {\n\n\t\tsuper();\n\n\t\tthis.isOrthographicCamera = true;\n\n\t\tthis.type = 'OrthographicCamera';\n\n\t\tthis.zoom = 1;\n\t\tthis.view = null;\n\n\t\tthis.left = left;\n\t\tthis.right = right;\n\t\tthis.top = top;\n\t\tthis.bottom = bottom;\n\n\t\tthis.near = near;\n\t\tthis.far = far;\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.left = source.left;\n\t\tthis.right = source.right;\n\t\tthis.top = source.top;\n\t\tthis.bottom = source.bottom;\n\t\tthis.near = source.near;\n\t\tthis.far = source.far;\n\n\t\tthis.zoom = source.zoom;\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\treturn this;\n\n\t}\n\n\tsetViewOffset( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\tif ( this.view === null ) {\n\n\t\t\tthis.view = {\n\t\t\t\tenabled: true,\n\t\t\t\tfullWidth: 1,\n\t\t\t\tfullHeight: 1,\n\t\t\t\toffsetX: 0,\n\t\t\t\toffsetY: 0,\n\t\t\t\twidth: 1,\n\t\t\t\theight: 1\n\t\t\t};\n\n\t\t}\n\n\t\tthis.view.enabled = true;\n\t\tthis.view.fullWidth = fullWidth;\n\t\tthis.view.fullHeight = fullHeight;\n\t\tthis.view.offsetX = x;\n\t\tthis.view.offsetY = y;\n\t\tthis.view.width = width;\n\t\tthis.view.height = height;\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tclearViewOffset() {\n\n\t\tif ( this.view !== null ) {\n\n\t\t\tthis.view.enabled = false;\n\n\t\t}\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tupdateProjectionMatrix() {\n\n\t\tconst dx = ( this.right - this.left ) / ( 2 * this.zoom );\n\t\tconst dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\n\t\tconst cx = ( this.right + this.left ) / 2;\n\t\tconst cy = ( this.top + this.bottom ) / 2;\n\n\t\tlet left = cx - dx;\n\t\tlet right = cx + dx;\n\t\tlet top = cy + dy;\n\t\tlet bottom = cy - dy;\n\n\t\tif ( this.view !== null && this.view.enabled ) {\n\n\t\t\tconst scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;\n\t\t\tconst scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;\n\n\t\t\tleft += scaleW * this.view.offsetX;\n\t\t\tright = left + scaleW * this.view.width;\n\t\t\ttop -= scaleH * this.view.offsetY;\n\t\t\tbottom = top - scaleH * this.view.height;\n\n\t\t}\n\n\t\tthis.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far, this.coordinateSystem );\n\n\t\tthis.projectionMatrixInverse.copy( this.projectionMatrix ).invert();\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.zoom = this.zoom;\n\t\tdata.object.left = this.left;\n\t\tdata.object.right = this.right;\n\t\tdata.object.top = this.top;\n\t\tdata.object.bottom = this.bottom;\n\t\tdata.object.near = this.near;\n\t\tdata.object.far = this.far;\n\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass DirectionalLightShadow extends LightShadow {\n\n\tconstructor() {\n\n\t\tsuper( new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\n\n\t\tthis.isDirectionalLightShadow = true;\n\n\t}\n\n}\n\nclass DirectionalLight extends Light {\n\n\tconstructor( color, intensity ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.isDirectionalLight = true;\n\n\t\tthis.type = 'DirectionalLight';\n\n\t\tthis.position.copy( Object3D.DEFAULT_UP );\n\t\tthis.updateMatrix();\n\n\t\tthis.target = new Object3D();\n\n\t\tthis.shadow = new DirectionalLightShadow();\n\n\t}\n\n\tdispose() {\n\n\t\tthis.shadow.dispose();\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.target = source.target.clone();\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass AmbientLight extends Light {\n\n\tconstructor( color, intensity ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.isAmbientLight = true;\n\n\t\tthis.type = 'AmbientLight';\n\n\t}\n\n}\n\nclass RectAreaLight extends Light {\n\n\tconstructor( color, intensity, width = 10, height = 10 ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.isRectAreaLight = true;\n\n\t\tthis.type = 'RectAreaLight';\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\n\t}\n\n\tget power() {\n\n\t\t// compute the light's luminous power (in lumens) from its intensity (in nits)\n\t\treturn this.intensity * this.width * this.height * Math.PI;\n\n\t}\n\n\tset power( power ) {\n\n\t\t// set the light's intensity (in nits) from the desired luminous power (in lumens)\n\t\tthis.intensity = power / ( this.width * this.height * Math.PI );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.width = source.width;\n\t\tthis.height = source.height;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.width = this.width;\n\t\tdata.object.height = this.height;\n\n\t\treturn data;\n\n\t}\n\n}\n\n/**\n * Primary reference:\n *   https://graphics.stanford.edu/papers/envmap/envmap.pdf\n *\n * Secondary reference:\n *   https://www.ppsloan.org/publications/StupidSH36.pdf\n */\n\n// 3-band SH defined by 9 coefficients\n\nclass SphericalHarmonics3 {\n\n\tconstructor() {\n\n\t\tthis.isSphericalHarmonics3 = true;\n\n\t\tthis.coefficients = [];\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients.push( new Vector3() );\n\n\t\t}\n\n\t}\n\n\tset( coefficients ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].copy( coefficients[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tzero() {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].set( 0, 0, 0 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// get the radiance in the direction of the normal\n\t// target is a Vector3\n\tgetAt( normal, target ) {\n\n\t\t// normal is assumed to be unit length\n\n\t\tconst x = normal.x, y = normal.y, z = normal.z;\n\n\t\tconst coeff = this.coefficients;\n\n\t\t// band 0\n\t\ttarget.copy( coeff[ 0 ] ).multiplyScalar( 0.282095 );\n\n\t\t// band 1\n\t\ttarget.addScaledVector( coeff[ 1 ], 0.488603 * y );\n\t\ttarget.addScaledVector( coeff[ 2 ], 0.488603 * z );\n\t\ttarget.addScaledVector( coeff[ 3 ], 0.488603 * x );\n\n\t\t// band 2\n\t\ttarget.addScaledVector( coeff[ 4 ], 1.092548 * ( x * y ) );\n\t\ttarget.addScaledVector( coeff[ 5 ], 1.092548 * ( y * z ) );\n\t\ttarget.addScaledVector( coeff[ 6 ], 0.315392 * ( 3.0 * z * z - 1.0 ) );\n\t\ttarget.addScaledVector( coeff[ 7 ], 1.092548 * ( x * z ) );\n\t\ttarget.addScaledVector( coeff[ 8 ], 0.546274 * ( x * x - y * y ) );\n\n\t\treturn target;\n\n\t}\n\n\t// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal\n\t// target is a Vector3\n\t// https://graphics.stanford.edu/papers/envmap/envmap.pdf\n\tgetIrradianceAt( normal, target ) {\n\n\t\t// normal is assumed to be unit length\n\n\t\tconst x = normal.x, y = normal.y, z = normal.z;\n\n\t\tconst coeff = this.coefficients;\n\n\t\t// band 0\n\t\ttarget.copy( coeff[ 0 ] ).multiplyScalar( 0.886227 ); // π * 0.282095\n\n\t\t// band 1\n\t\ttarget.addScaledVector( coeff[ 1 ], 2.0 * 0.511664 * y ); // ( 2 * π / 3 ) * 0.488603\n\t\ttarget.addScaledVector( coeff[ 2 ], 2.0 * 0.511664 * z );\n\t\ttarget.addScaledVector( coeff[ 3 ], 2.0 * 0.511664 * x );\n\n\t\t// band 2\n\t\ttarget.addScaledVector( coeff[ 4 ], 2.0 * 0.429043 * x * y ); // ( π / 4 ) * 1.092548\n\t\ttarget.addScaledVector( coeff[ 5 ], 2.0 * 0.429043 * y * z );\n\t\ttarget.addScaledVector( coeff[ 6 ], 0.743125 * z * z - 0.247708 ); // ( π / 4 ) * 0.315392 * 3\n\t\ttarget.addScaledVector( coeff[ 7 ], 2.0 * 0.429043 * x * z );\n\t\ttarget.addScaledVector( coeff[ 8 ], 0.429043 * ( x * x - y * y ) ); // ( π / 4 ) * 0.546274\n\n\t\treturn target;\n\n\t}\n\n\tadd( sh ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].add( sh.coefficients[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\taddScaledSH( sh, s ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].addScaledVector( sh.coefficients[ i ], s );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tscale( s ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].multiplyScalar( s );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tlerp( sh, alpha ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].lerp( sh.coefficients[ i ], alpha );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tequals( sh ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tif ( ! this.coefficients[ i ].equals( sh.coefficients[ i ] ) ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tcopy( sh ) {\n\n\t\treturn this.set( sh.coefficients );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tconst coefficients = this.coefficients;\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tcoefficients[ i ].fromArray( array, offset + ( i * 3 ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tconst coefficients = this.coefficients;\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tcoefficients[ i ].toArray( array, offset + ( i * 3 ) );\n\n\t\t}\n\n\t\treturn array;\n\n\t}\n\n\t// evaluate the basis functions\n\t// shBasis is an Array[ 9 ]\n\tstatic getBasisAt( normal, shBasis ) {\n\n\t\t// normal is assumed to be unit length\n\n\t\tconst x = normal.x, y = normal.y, z = normal.z;\n\n\t\t// band 0\n\t\tshBasis[ 0 ] = 0.282095;\n\n\t\t// band 1\n\t\tshBasis[ 1 ] = 0.488603 * y;\n\t\tshBasis[ 2 ] = 0.488603 * z;\n\t\tshBasis[ 3 ] = 0.488603 * x;\n\n\t\t// band 2\n\t\tshBasis[ 4 ] = 1.092548 * x * y;\n\t\tshBasis[ 5 ] = 1.092548 * y * z;\n\t\tshBasis[ 6 ] = 0.315392 * ( 3 * z * z - 1 );\n\t\tshBasis[ 7 ] = 1.092548 * x * z;\n\t\tshBasis[ 8 ] = 0.546274 * ( x * x - y * y );\n\n\t}\n\n}\n\nclass LightProbe extends Light {\n\n\tconstructor( sh = new SphericalHarmonics3(), intensity = 1 ) {\n\n\t\tsuper( undefined, intensity );\n\n\t\tthis.isLightProbe = true;\n\n\t\tthis.sh = sh;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.sh.copy( source.sh );\n\n\t\treturn this;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tthis.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();\n\t\tthis.sh.fromArray( json.sh );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.sh = this.sh.toArray();\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass MaterialLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\t\tthis.textures = {};\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( json ) {\n\n\t\tconst textures = this.textures;\n\n\t\tfunction getTexture( name ) {\n\n\t\t\tif ( textures[ name ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\n\n\t\t\t}\n\n\t\t\treturn textures[ name ];\n\n\t\t}\n\n\t\tconst material = this.createMaterialFromType( json.type );\n\n\t\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\n\t\tif ( json.name !== undefined ) material.name = json.name;\n\t\tif ( json.color !== undefined && material.color !== undefined ) material.color.setHex( json.color );\n\t\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\n\t\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\n\t\tif ( json.sheen !== undefined ) material.sheen = json.sheen;\n\t\tif ( json.sheenColor !== undefined ) material.sheenColor = new Color().setHex( json.sheenColor );\n\t\tif ( json.sheenRoughness !== undefined ) material.sheenRoughness = json.sheenRoughness;\n\t\tif ( json.emissive !== undefined && material.emissive !== undefined ) material.emissive.setHex( json.emissive );\n\t\tif ( json.specular !== undefined && material.specular !== undefined ) material.specular.setHex( json.specular );\n\t\tif ( json.specularIntensity !== undefined ) material.specularIntensity = json.specularIntensity;\n\t\tif ( json.specularColor !== undefined && material.specularColor !== undefined ) material.specularColor.setHex( json.specularColor );\n\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\n\t\tif ( json.clearcoat !== undefined ) material.clearcoat = json.clearcoat;\n\t\tif ( json.clearcoatRoughness !== undefined ) material.clearcoatRoughness = json.clearcoatRoughness;\n\t\tif ( json.dispersion !== undefined ) material.dispersion = json.dispersion;\n\t\tif ( json.iridescence !== undefined ) material.iridescence = json.iridescence;\n\t\tif ( json.iridescenceIOR !== undefined ) material.iridescenceIOR = json.iridescenceIOR;\n\t\tif ( json.iridescenceThicknessRange !== undefined ) material.iridescenceThicknessRange = json.iridescenceThicknessRange;\n\t\tif ( json.transmission !== undefined ) material.transmission = json.transmission;\n\t\tif ( json.thickness !== undefined ) material.thickness = json.thickness;\n\t\tif ( json.attenuationDistance !== undefined ) material.attenuationDistance = json.attenuationDistance;\n\t\tif ( json.attenuationColor !== undefined && material.attenuationColor !== undefined ) material.attenuationColor.setHex( json.attenuationColor );\n\t\tif ( json.anisotropy !== undefined ) material.anisotropy = json.anisotropy;\n\t\tif ( json.anisotropyRotation !== undefined ) material.anisotropyRotation = json.anisotropyRotation;\n\t\tif ( json.fog !== undefined ) material.fog = json.fog;\n\t\tif ( json.flatShading !== undefined ) material.flatShading = json.flatShading;\n\t\tif ( json.blending !== undefined ) material.blending = json.blending;\n\t\tif ( json.combine !== undefined ) material.combine = json.combine;\n\t\tif ( json.side !== undefined ) material.side = json.side;\n\t\tif ( json.shadowSide !== undefined ) material.shadowSide = json.shadowSide;\n\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\n\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\n\t\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\n\t\tif ( json.alphaHash !== undefined ) material.alphaHash = json.alphaHash;\n\t\tif ( json.depthFunc !== undefined ) material.depthFunc = json.depthFunc;\n\t\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\n\t\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\n\t\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\n\t\tif ( json.blendSrc !== undefined ) material.blendSrc = json.blendSrc;\n\t\tif ( json.blendDst !== undefined ) material.blendDst = json.blendDst;\n\t\tif ( json.blendEquation !== undefined ) material.blendEquation = json.blendEquation;\n\t\tif ( json.blendSrcAlpha !== undefined ) material.blendSrcAlpha = json.blendSrcAlpha;\n\t\tif ( json.blendDstAlpha !== undefined ) material.blendDstAlpha = json.blendDstAlpha;\n\t\tif ( json.blendEquationAlpha !== undefined ) material.blendEquationAlpha = json.blendEquationAlpha;\n\t\tif ( json.blendColor !== undefined && material.blendColor !== undefined ) material.blendColor.setHex( json.blendColor );\n\t\tif ( json.blendAlpha !== undefined ) material.blendAlpha = json.blendAlpha;\n\t\tif ( json.stencilWriteMask !== undefined ) material.stencilWriteMask = json.stencilWriteMask;\n\t\tif ( json.stencilFunc !== undefined ) material.stencilFunc = json.stencilFunc;\n\t\tif ( json.stencilRef !== undefined ) material.stencilRef = json.stencilRef;\n\t\tif ( json.stencilFuncMask !== undefined ) material.stencilFuncMask = json.stencilFuncMask;\n\t\tif ( json.stencilFail !== undefined ) material.stencilFail = json.stencilFail;\n\t\tif ( json.stencilZFail !== undefined ) material.stencilZFail = json.stencilZFail;\n\t\tif ( json.stencilZPass !== undefined ) material.stencilZPass = json.stencilZPass;\n\t\tif ( json.stencilWrite !== undefined ) material.stencilWrite = json.stencilWrite;\n\n\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\n\t\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\n\t\tif ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;\n\t\tif ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;\n\n\t\tif ( json.rotation !== undefined ) material.rotation = json.rotation;\n\n\t\tif ( json.linewidth !== undefined ) material.linewidth = json.linewidth;\n\t\tif ( json.dashSize !== undefined ) material.dashSize = json.dashSize;\n\t\tif ( json.gapSize !== undefined ) material.gapSize = json.gapSize;\n\t\tif ( json.scale !== undefined ) material.scale = json.scale;\n\n\t\tif ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset;\n\t\tif ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor;\n\t\tif ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits;\n\n\t\tif ( json.dithering !== undefined ) material.dithering = json.dithering;\n\n\t\tif ( json.alphaToCoverage !== undefined ) material.alphaToCoverage = json.alphaToCoverage;\n\t\tif ( json.premultipliedAlpha !== undefined ) material.premultipliedAlpha = json.premultipliedAlpha;\n\t\tif ( json.forceSinglePass !== undefined ) material.forceSinglePass = json.forceSinglePass;\n\n\t\tif ( json.visible !== undefined ) material.visible = json.visible;\n\n\t\tif ( json.toneMapped !== undefined ) material.toneMapped = json.toneMapped;\n\n\t\tif ( json.userData !== undefined ) material.userData = json.userData;\n\n\t\tif ( json.vertexColors !== undefined ) {\n\n\t\t\tif ( typeof json.vertexColors === 'number' ) {\n\n\t\t\t\tmaterial.vertexColors = ( json.vertexColors > 0 ) ? true : false;\n\n\t\t\t} else {\n\n\t\t\t\tmaterial.vertexColors = json.vertexColors;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Shader Material\n\n\t\tif ( json.uniforms !== undefined ) {\n\n\t\t\tfor ( const name in json.uniforms ) {\n\n\t\t\t\tconst uniform = json.uniforms[ name ];\n\n\t\t\t\tmaterial.uniforms[ name ] = {};\n\n\t\t\t\tswitch ( uniform.type ) {\n\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = getTexture( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Color().setHex( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v2':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Vector2().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v3':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Vector3().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v4':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Vector4().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'm3':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Matrix3().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'm4':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Matrix4().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = uniform.value;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( json.defines !== undefined ) material.defines = json.defines;\n\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\n\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\n\t\tif ( json.glslVersion !== undefined ) material.glslVersion = json.glslVersion;\n\n\t\tif ( json.extensions !== undefined ) {\n\n\t\t\tfor ( const key in json.extensions ) {\n\n\t\t\t\tmaterial.extensions[ key ] = json.extensions[ key ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( json.lights !== undefined ) material.lights = json.lights;\n\t\tif ( json.clipping !== undefined ) material.clipping = json.clipping;\n\n\t\t// for PointsMaterial\n\n\t\tif ( json.size !== undefined ) material.size = json.size;\n\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\n\n\t\t// maps\n\n\t\tif ( json.map !== undefined ) material.map = getTexture( json.map );\n\t\tif ( json.matcap !== undefined ) material.matcap = getTexture( json.matcap );\n\n\t\tif ( json.alphaMap !== undefined ) material.alphaMap = getTexture( json.alphaMap );\n\n\t\tif ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );\n\t\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\n\n\t\tif ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );\n\t\tif ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType;\n\t\tif ( json.normalScale !== undefined ) {\n\n\t\t\tlet normalScale = json.normalScale;\n\n\t\t\tif ( Array.isArray( normalScale ) === false ) {\n\n\t\t\t\t// Blender exporter used to export a scalar. See #7459\n\n\t\t\t\tnormalScale = [ normalScale, normalScale ];\n\n\t\t\t}\n\n\t\t\tmaterial.normalScale = new Vector2().fromArray( normalScale );\n\n\t\t}\n\n\t\tif ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );\n\t\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\n\t\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\n\n\t\tif ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );\n\t\tif ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );\n\n\t\tif ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );\n\t\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\n\n\t\tif ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );\n\t\tif ( json.specularIntensityMap !== undefined ) material.specularIntensityMap = getTexture( json.specularIntensityMap );\n\t\tif ( json.specularColorMap !== undefined ) material.specularColorMap = getTexture( json.specularColorMap );\n\n\t\tif ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );\n\t\tif ( json.envMapRotation !== undefined ) material.envMapRotation.fromArray( json.envMapRotation );\n\t\tif ( json.envMapIntensity !== undefined ) material.envMapIntensity = json.envMapIntensity;\n\n\t\tif ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;\n\t\tif ( json.refractionRatio !== undefined ) material.refractionRatio = json.refractionRatio;\n\n\t\tif ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );\n\t\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\n\n\t\tif ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );\n\t\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\n\n\t\tif ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );\n\n\t\tif ( json.clearcoatMap !== undefined ) material.clearcoatMap = getTexture( json.clearcoatMap );\n\t\tif ( json.clearcoatRoughnessMap !== undefined ) material.clearcoatRoughnessMap = getTexture( json.clearcoatRoughnessMap );\n\t\tif ( json.clearcoatNormalMap !== undefined ) material.clearcoatNormalMap = getTexture( json.clearcoatNormalMap );\n\t\tif ( json.clearcoatNormalScale !== undefined ) material.clearcoatNormalScale = new Vector2().fromArray( json.clearcoatNormalScale );\n\n\t\tif ( json.iridescenceMap !== undefined ) material.iridescenceMap = getTexture( json.iridescenceMap );\n\t\tif ( json.iridescenceThicknessMap !== undefined ) material.iridescenceThicknessMap = getTexture( json.iridescenceThicknessMap );\n\n\t\tif ( json.transmissionMap !== undefined ) material.transmissionMap = getTexture( json.transmissionMap );\n\t\tif ( json.thicknessMap !== undefined ) material.thicknessMap = getTexture( json.thicknessMap );\n\n\t\tif ( json.anisotropyMap !== undefined ) material.anisotropyMap = getTexture( json.anisotropyMap );\n\n\t\tif ( json.sheenColorMap !== undefined ) material.sheenColorMap = getTexture( json.sheenColorMap );\n\t\tif ( json.sheenRoughnessMap !== undefined ) material.sheenRoughnessMap = getTexture( json.sheenRoughnessMap );\n\n\t\treturn material;\n\n\t}\n\n\tsetTextures( value ) {\n\n\t\tthis.textures = value;\n\t\treturn this;\n\n\t}\n\n\tcreateMaterialFromType( type ) {\n\n\t\treturn MaterialLoader.createMaterialFromType( type );\n\n\t}\n\n\tstatic createMaterialFromType( type ) {\n\n\t\tconst materialLib = {\n\t\t\tShadowMaterial,\n\t\t\tSpriteMaterial,\n\t\t\tRawShaderMaterial,\n\t\t\tShaderMaterial,\n\t\t\tPointsMaterial,\n\t\t\tMeshPhysicalMaterial,\n\t\t\tMeshStandardMaterial,\n\t\t\tMeshPhongMaterial,\n\t\t\tMeshToonMaterial,\n\t\t\tMeshNormalMaterial,\n\t\t\tMeshLambertMaterial,\n\t\t\tMeshDepthMaterial,\n\t\t\tMeshDistanceMaterial,\n\t\t\tMeshBasicMaterial,\n\t\t\tMeshMatcapMaterial,\n\t\t\tLineDashedMaterial,\n\t\t\tLineBasicMaterial,\n\t\t\tMaterial\n\t\t};\n\n\t\treturn new materialLib[ type ]();\n\n\t}\n\n}\n\nclass LoaderUtils {\n\n\tstatic decodeText( array ) { // @deprecated, r165\n\n\t\tconsole.warn( 'THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead.' );\n\n\t\tif ( typeof TextDecoder !== 'undefined' ) {\n\n\t\t\treturn new TextDecoder().decode( array );\n\n\t\t}\n\n\t\t// Avoid the String.fromCharCode.apply(null, array) shortcut, which\n\t\t// throws a \"maximum call stack size exceeded\" error for large arrays.\n\n\t\tlet s = '';\n\n\t\tfor ( let i = 0, il = array.length; i < il; i ++ ) {\n\n\t\t\t// Implicitly assumes little-endian.\n\t\t\ts += String.fromCharCode( array[ i ] );\n\n\t\t}\n\n\t\ttry {\n\n\t\t\t// merges multi-byte utf-8 characters.\n\n\t\t\treturn decodeURIComponent( escape( s ) );\n\n\t\t} catch ( e ) { // see #16358\n\n\t\t\treturn s;\n\n\t\t}\n\n\t}\n\n\tstatic extractUrlBase( url ) {\n\n\t\tconst index = url.lastIndexOf( '/' );\n\n\t\tif ( index === - 1 ) return './';\n\n\t\treturn url.slice( 0, index + 1 );\n\n\t}\n\n\tstatic resolveURL( url, path ) {\n\n\t\t// Invalid URL\n\t\tif ( typeof url !== 'string' || url === '' ) return '';\n\n\t\t// Host Relative URL\n\t\tif ( /^https?:\\/\\//i.test( path ) && /^\\//.test( url ) ) {\n\n\t\t\tpath = path.replace( /(^https?:\\/\\/[^\\/]+).*/i, '$1' );\n\n\t\t}\n\n\t\t// Absolute URL http://,https://,//\n\t\tif ( /^(https?:)?\\/\\//i.test( url ) ) return url;\n\n\t\t// Data URI\n\t\tif ( /^data:.*,.*$/i.test( url ) ) return url;\n\n\t\t// Blob URL\n\t\tif ( /^blob:.*$/i.test( url ) ) return url;\n\n\t\t// Relative URL\n\t\treturn path + url;\n\n\t}\n\n}\n\nclass InstancedBufferGeometry extends BufferGeometry {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isInstancedBufferGeometry = true;\n\n\t\tthis.type = 'InstancedBufferGeometry';\n\t\tthis.instanceCount = Infinity;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.instanceCount = source.instanceCount;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.instanceCount = this.instanceCount;\n\n\t\tdata.isInstancedBufferGeometry = true;\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass BufferGeometryLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( json ) {\n\n\t\tconst interleavedBufferMap = {};\n\t\tconst arrayBufferMap = {};\n\n\t\tfunction getInterleavedBuffer( json, uuid ) {\n\n\t\t\tif ( interleavedBufferMap[ uuid ] !== undefined ) return interleavedBufferMap[ uuid ];\n\n\t\t\tconst interleavedBuffers = json.interleavedBuffers;\n\t\t\tconst interleavedBuffer = interleavedBuffers[ uuid ];\n\n\t\t\tconst buffer = getArrayBuffer( json, interleavedBuffer.buffer );\n\n\t\t\tconst array = getTypedArray( interleavedBuffer.type, buffer );\n\t\t\tconst ib = new InterleavedBuffer( array, interleavedBuffer.stride );\n\t\t\tib.uuid = interleavedBuffer.uuid;\n\n\t\t\tinterleavedBufferMap[ uuid ] = ib;\n\n\t\t\treturn ib;\n\n\t\t}\n\n\t\tfunction getArrayBuffer( json, uuid ) {\n\n\t\t\tif ( arrayBufferMap[ uuid ] !== undefined ) return arrayBufferMap[ uuid ];\n\n\t\t\tconst arrayBuffers = json.arrayBuffers;\n\t\t\tconst arrayBuffer = arrayBuffers[ uuid ];\n\n\t\t\tconst ab = new Uint32Array( arrayBuffer ).buffer;\n\n\t\t\tarrayBufferMap[ uuid ] = ab;\n\n\t\t\treturn ab;\n\n\t\t}\n\n\t\tconst geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();\n\n\t\tconst index = json.data.index;\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tconst typedArray = getTypedArray( index.type, index.array );\n\t\t\tgeometry.setIndex( new BufferAttribute( typedArray, 1 ) );\n\n\t\t}\n\n\t\tconst attributes = json.data.attributes;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attribute = attributes[ key ];\n\t\t\tlet bufferAttribute;\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\tconst interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );\n\t\t\t\tbufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );\n\n\t\t\t} else {\n\n\t\t\t\tconst typedArray = getTypedArray( attribute.type, attribute.array );\n\t\t\t\tconst bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;\n\t\t\t\tbufferAttribute = new bufferAttributeConstr( typedArray, attribute.itemSize, attribute.normalized );\n\n\t\t\t}\n\n\t\t\tif ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;\n\t\t\tif ( attribute.usage !== undefined ) bufferAttribute.setUsage( attribute.usage );\n\n\t\t\tgeometry.setAttribute( key, bufferAttribute );\n\n\t\t}\n\n\t\tconst morphAttributes = json.data.morphAttributes;\n\n\t\tif ( morphAttributes ) {\n\n\t\t\tfor ( const key in morphAttributes ) {\n\n\t\t\t\tconst attributeArray = morphAttributes[ key ];\n\n\t\t\t\tconst array = [];\n\n\t\t\t\tfor ( let i = 0, il = attributeArray.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst attribute = attributeArray[ i ];\n\t\t\t\t\tlet bufferAttribute;\n\n\t\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\t\tconst interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );\n\t\t\t\t\t\tbufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst typedArray = getTypedArray( attribute.type, attribute.array );\n\t\t\t\t\t\tbufferAttribute = new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;\n\t\t\t\t\tarray.push( bufferAttribute );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.morphAttributes[ key ] = array;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst morphTargetsRelative = json.data.morphTargetsRelative;\n\n\t\tif ( morphTargetsRelative ) {\n\n\t\t\tgeometry.morphTargetsRelative = true;\n\n\t\t}\n\n\t\tconst groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n\n\t\tif ( groups !== undefined ) {\n\n\t\t\tfor ( let i = 0, n = groups.length; i !== n; ++ i ) {\n\n\t\t\t\tconst group = groups[ i ];\n\n\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst boundingSphere = json.data.boundingSphere;\n\n\t\tif ( boundingSphere !== undefined ) {\n\n\t\t\tconst center = new Vector3();\n\n\t\t\tif ( boundingSphere.center !== undefined ) {\n\n\t\t\t\tcenter.fromArray( boundingSphere.center );\n\n\t\t\t}\n\n\t\t\tgeometry.boundingSphere = new Sphere( center, boundingSphere.radius );\n\n\t\t}\n\n\t\tif ( json.name ) geometry.name = json.name;\n\t\tif ( json.userData ) geometry.userData = json.userData;\n\n\t\treturn geometry;\n\n\t}\n\n}\n\nclass ObjectLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;\n\t\tthis.resourcePath = this.resourcePath || path;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tlet json = null;\n\n\t\t\ttry {\n\n\t\t\t\tjson = JSON.parse( text );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tif ( onError !== undefined ) onError( error );\n\n\t\t\t\tconsole.error( 'THREE:ObjectLoader: Can\\'t parse ' + url + '.', error.message );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tconst metadata = json.metadata;\n\n\t\t\tif ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {\n\n\t\t\t\tif ( onError !== undefined ) onError( new Error( 'THREE.ObjectLoader: Can\\'t load ' + url ) );\n\n\t\t\t\tconsole.error( 'THREE.ObjectLoader: Can\\'t load ' + url );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tscope.parse( json, onLoad );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tasync loadAsync( url, onProgress ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;\n\t\tthis.resourcePath = this.resourcePath || path;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tconst text = await loader.loadAsync( url, onProgress );\n\n\t\tconst json = JSON.parse( text );\n\n\t\tconst metadata = json.metadata;\n\n\t\tif ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {\n\n\t\t\tthrow new Error( 'THREE.ObjectLoader: Can\\'t load ' + url );\n\n\t\t}\n\n\t\treturn await scope.parseAsync( json );\n\n\t}\n\n\tparse( json, onLoad ) {\n\n\t\tconst animations = this.parseAnimations( json.animations );\n\t\tconst shapes = this.parseShapes( json.shapes );\n\t\tconst geometries = this.parseGeometries( json.geometries, shapes );\n\n\t\tconst images = this.parseImages( json.images, function () {\n\n\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\n\t\t} );\n\n\t\tconst textures = this.parseTextures( json.textures, images );\n\t\tconst materials = this.parseMaterials( json.materials, textures );\n\n\t\tconst object = this.parseObject( json.object, geometries, materials, textures, animations );\n\t\tconst skeletons = this.parseSkeletons( json.skeletons, object );\n\n\t\tthis.bindSkeletons( object, skeletons );\n\t\tthis.bindLightTargets( object );\n\n\t\t//\n\n\t\tif ( onLoad !== undefined ) {\n\n\t\t\tlet hasImages = false;\n\n\t\t\tfor ( const uuid in images ) {\n\n\t\t\t\tif ( images[ uuid ].data instanceof HTMLImageElement ) {\n\n\t\t\t\t\thasImages = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasImages === false ) onLoad( object );\n\n\t\t}\n\n\t\treturn object;\n\n\t}\n\n\tasync parseAsync( json ) {\n\n\t\tconst animations = this.parseAnimations( json.animations );\n\t\tconst shapes = this.parseShapes( json.shapes );\n\t\tconst geometries = this.parseGeometries( json.geometries, shapes );\n\n\t\tconst images = await this.parseImagesAsync( json.images );\n\n\t\tconst textures = this.parseTextures( json.textures, images );\n\t\tconst materials = this.parseMaterials( json.materials, textures );\n\n\t\tconst object = this.parseObject( json.object, geometries, materials, textures, animations );\n\t\tconst skeletons = this.parseSkeletons( json.skeletons, object );\n\n\t\tthis.bindSkeletons( object, skeletons );\n\t\tthis.bindLightTargets( object );\n\n\t\treturn object;\n\n\t}\n\n\tparseShapes( json ) {\n\n\t\tconst shapes = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst shape = new Shape().fromJSON( json[ i ] );\n\n\t\t\t\tshapes[ shape.uuid ] = shape;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn shapes;\n\n\t}\n\n\tparseSkeletons( json, object ) {\n\n\t\tconst skeletons = {};\n\t\tconst bones = {};\n\n\t\t// generate bone lookup table\n\n\t\tobject.traverse( function ( child ) {\n\n\t\t\tif ( child.isBone ) bones[ child.uuid ] = child;\n\n\t\t} );\n\n\t\t// create skeletons\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst skeleton = new Skeleton().fromJSON( json[ i ], bones );\n\n\t\t\t\tskeletons[ skeleton.uuid ] = skeleton;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn skeletons;\n\n\t}\n\n\tparseGeometries( json, shapes ) {\n\n\t\tconst geometries = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tconst bufferGeometryLoader = new BufferGeometryLoader();\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tlet geometry;\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tswitch ( data.type ) {\n\n\t\t\t\t\tcase 'BufferGeometry':\n\t\t\t\t\tcase 'InstancedBufferGeometry':\n\n\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tif ( data.type in Geometries ) {\n\n\t\t\t\t\t\t\tgeometry = Geometries[ data.type ].fromJSON( data, shapes );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconsole.warn( `THREE.ObjectLoader: Unsupported geometry type \"${ data.type }\"` );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\n\t\t\t\tif ( data.userData !== undefined ) geometry.userData = data.userData;\n\n\t\t\t\tgeometries[ data.uuid ] = geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn geometries;\n\n\t}\n\n\tparseMaterials( json, textures ) {\n\n\t\tconst cache = {}; // MultiMaterial\n\t\tconst materials = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tconst loader = new MaterialLoader();\n\t\t\tloader.setTextures( textures );\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tif ( cache[ data.uuid ] === undefined ) {\n\n\t\t\t\t\tcache[ data.uuid ] = loader.parse( data );\n\n\t\t\t\t}\n\n\t\t\t\tmaterials[ data.uuid ] = cache[ data.uuid ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn materials;\n\n\t}\n\n\tparseAnimations( json ) {\n\n\t\tconst animations = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( let i = 0; i < json.length; i ++ ) {\n\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tconst clip = AnimationClip.parse( data );\n\n\t\t\t\tanimations[ clip.uuid ] = clip;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn animations;\n\n\t}\n\n\tparseImages( json, onLoad ) {\n\n\t\tconst scope = this;\n\t\tconst images = {};\n\n\t\tlet loader;\n\n\t\tfunction loadImage( url ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\treturn loader.load( url, function () {\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, undefined, function () {\n\n\t\t\t\tscope.manager.itemError( url );\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t} );\n\n\t\t}\n\n\t\tfunction deserializeImage( image ) {\n\n\t\t\tif ( typeof image === 'string' ) {\n\n\t\t\t\tconst url = image;\n\n\t\t\t\tconst path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( url ) ? url : scope.resourcePath + url;\n\n\t\t\t\treturn loadImage( path );\n\n\t\t\t} else {\n\n\t\t\t\tif ( image.data ) {\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdata: getTypedArray( image.type, image.data ),\n\t\t\t\t\t\twidth: image.width,\n\t\t\t\t\t\theight: image.height\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( json !== undefined && json.length > 0 ) {\n\n\t\t\tconst manager = new LoadingManager( onLoad );\n\n\t\t\tloader = new ImageLoader( manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\tfor ( let i = 0, il = json.length; i < il; i ++ ) {\n\n\t\t\t\tconst image = json[ i ];\n\t\t\t\tconst url = image.url;\n\n\t\t\t\tif ( Array.isArray( url ) ) {\n\n\t\t\t\t\t// load array of images e.g CubeTexture\n\n\t\t\t\t\tconst imageArray = [];\n\n\t\t\t\t\tfor ( let j = 0, jl = url.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tconst currentUrl = url[ j ];\n\n\t\t\t\t\t\tconst deserializedImage = deserializeImage( currentUrl );\n\n\t\t\t\t\t\tif ( deserializedImage !== null ) {\n\n\t\t\t\t\t\t\tif ( deserializedImage instanceof HTMLImageElement ) {\n\n\t\t\t\t\t\t\t\timageArray.push( deserializedImage );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// special case: handle array of data textures for cube textures\n\n\t\t\t\t\t\t\t\timageArray.push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\timages[ image.uuid ] = new Source( imageArray );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// load single image\n\n\t\t\t\t\tconst deserializedImage = deserializeImage( image.url );\n\t\t\t\t\timages[ image.uuid ] = new Source( deserializedImage );\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn images;\n\n\t}\n\n\tasync parseImagesAsync( json ) {\n\n\t\tconst scope = this;\n\t\tconst images = {};\n\n\t\tlet loader;\n\n\t\tasync function deserializeImage( image ) {\n\n\t\t\tif ( typeof image === 'string' ) {\n\n\t\t\t\tconst url = image;\n\n\t\t\t\tconst path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( url ) ? url : scope.resourcePath + url;\n\n\t\t\t\treturn await loader.loadAsync( path );\n\n\t\t\t} else {\n\n\t\t\t\tif ( image.data ) {\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdata: getTypedArray( image.type, image.data ),\n\t\t\t\t\t\twidth: image.width,\n\t\t\t\t\t\theight: image.height\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( json !== undefined && json.length > 0 ) {\n\n\t\t\tloader = new ImageLoader( this.manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\tfor ( let i = 0, il = json.length; i < il; i ++ ) {\n\n\t\t\t\tconst image = json[ i ];\n\t\t\t\tconst url = image.url;\n\n\t\t\t\tif ( Array.isArray( url ) ) {\n\n\t\t\t\t\t// load array of images e.g CubeTexture\n\n\t\t\t\t\tconst imageArray = [];\n\n\t\t\t\t\tfor ( let j = 0, jl = url.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tconst currentUrl = url[ j ];\n\n\t\t\t\t\t\tconst deserializedImage = await deserializeImage( currentUrl );\n\n\t\t\t\t\t\tif ( deserializedImage !== null ) {\n\n\t\t\t\t\t\t\tif ( deserializedImage instanceof HTMLImageElement ) {\n\n\t\t\t\t\t\t\t\timageArray.push( deserializedImage );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// special case: handle array of data textures for cube textures\n\n\t\t\t\t\t\t\t\timageArray.push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\timages[ image.uuid ] = new Source( imageArray );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// load single image\n\n\t\t\t\t\tconst deserializedImage = await deserializeImage( image.url );\n\t\t\t\t\timages[ image.uuid ] = new Source( deserializedImage );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn images;\n\n\t}\n\n\tparseTextures( json, images ) {\n\n\t\tfunction parseConstant( value, type ) {\n\n\t\t\tif ( typeof value === 'number' ) return value;\n\n\t\t\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\n\n\t\t\treturn type[ value ];\n\n\t\t}\n\n\t\tconst textures = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tif ( data.image === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\n\n\t\t\t\t}\n\n\t\t\t\tif ( images[ data.image ] === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\n\n\t\t\t\t}\n\n\t\t\t\tconst source = images[ data.image ];\n\t\t\t\tconst image = source.data;\n\n\t\t\t\tlet texture;\n\n\t\t\t\tif ( Array.isArray( image ) ) {\n\n\t\t\t\t\ttexture = new CubeTexture();\n\n\t\t\t\t\tif ( image.length === 6 ) texture.needsUpdate = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( image && image.data ) {\n\n\t\t\t\t\t\ttexture = new DataTexture();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttexture = new Texture();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( image ) texture.needsUpdate = true; // textures can have undefined image data\n\n\t\t\t\t}\n\n\t\t\t\ttexture.source = source;\n\n\t\t\t\ttexture.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\n\n\t\t\t\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );\n\t\t\t\tif ( data.channel !== undefined ) texture.channel = data.channel;\n\n\t\t\t\tif ( data.offset !== undefined ) texture.offset.fromArray( data.offset );\n\t\t\t\tif ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );\n\t\t\t\tif ( data.center !== undefined ) texture.center.fromArray( data.center );\n\t\t\t\tif ( data.rotation !== undefined ) texture.rotation = data.rotation;\n\n\t\t\t\tif ( data.wrap !== undefined ) {\n\n\t\t\t\t\ttexture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );\n\t\t\t\t\ttexture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.format !== undefined ) texture.format = data.format;\n\t\t\t\tif ( data.internalFormat !== undefined ) texture.internalFormat = data.internalFormat;\n\t\t\t\tif ( data.type !== undefined ) texture.type = data.type;\n\t\t\t\tif ( data.colorSpace !== undefined ) texture.colorSpace = data.colorSpace;\n\n\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );\n\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );\n\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\n\n\t\t\t\tif ( data.flipY !== undefined ) texture.flipY = data.flipY;\n\n\t\t\t\tif ( data.generateMipmaps !== undefined ) texture.generateMipmaps = data.generateMipmaps;\n\t\t\t\tif ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha;\n\t\t\t\tif ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment;\n\t\t\t\tif ( data.compareFunction !== undefined ) texture.compareFunction = data.compareFunction;\n\n\t\t\t\tif ( data.userData !== undefined ) texture.userData = data.userData;\n\n\t\t\t\ttextures[ data.uuid ] = texture;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn textures;\n\n\t}\n\n\tparseObject( data, geometries, materials, textures, animations ) {\n\n\t\tlet object;\n\n\t\tfunction getGeometry( name ) {\n\n\t\t\tif ( geometries[ name ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\n\n\t\t\t}\n\n\t\t\treturn geometries[ name ];\n\n\t\t}\n\n\t\tfunction getMaterial( name ) {\n\n\t\t\tif ( name === undefined ) return undefined;\n\n\t\t\tif ( Array.isArray( name ) ) {\n\n\t\t\t\tconst array = [];\n\n\t\t\t\tfor ( let i = 0, l = name.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst uuid = name[ i ];\n\n\t\t\t\t\tif ( materials[ uuid ] === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', uuid );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tarray.push( materials[ uuid ] );\n\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\n\t\t\t}\n\n\t\t\tif ( materials[ name ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\n\n\t\t\t}\n\n\t\t\treturn materials[ name ];\n\n\t\t}\n\n\t\tfunction getTexture( uuid ) {\n\n\t\t\tif ( textures[ uuid ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined texture', uuid );\n\n\t\t\t}\n\n\t\t\treturn textures[ uuid ];\n\n\t\t}\n\n\t\tlet geometry, material;\n\n\t\tswitch ( data.type ) {\n\n\t\t\tcase 'Scene':\n\n\t\t\t\tobject = new Scene();\n\n\t\t\t\tif ( data.background !== undefined ) {\n\n\t\t\t\t\tif ( Number.isInteger( data.background ) ) {\n\n\t\t\t\t\t\tobject.background = new Color( data.background );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tobject.background = getTexture( data.background );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.environment !== undefined ) {\n\n\t\t\t\t\tobject.environment = getTexture( data.environment );\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.fog !== undefined ) {\n\n\t\t\t\t\tif ( data.fog.type === 'Fog' ) {\n\n\t\t\t\t\t\tobject.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );\n\n\t\t\t\t\t} else if ( data.fog.type === 'FogExp2' ) {\n\n\t\t\t\t\t\tobject.fog = new FogExp2( data.fog.color, data.fog.density );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( data.fog.name !== '' ) {\n\n\t\t\t\t\t\tobject.fog.name = data.fog.name;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.backgroundBlurriness !== undefined ) object.backgroundBlurriness = data.backgroundBlurriness;\n\t\t\t\tif ( data.backgroundIntensity !== undefined ) object.backgroundIntensity = data.backgroundIntensity;\n\t\t\t\tif ( data.backgroundRotation !== undefined ) object.backgroundRotation.fromArray( data.backgroundRotation );\n\n\t\t\t\tif ( data.environmentIntensity !== undefined ) object.environmentIntensity = data.environmentIntensity;\n\t\t\t\tif ( data.environmentRotation !== undefined ) object.environmentRotation.fromArray( data.environmentRotation );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'PerspectiveCamera':\n\n\t\t\t\tobject = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\n\n\t\t\t\tif ( data.focus !== undefined ) object.focus = data.focus;\n\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\n\t\t\t\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\n\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'OrthographicCamera':\n\n\t\t\t\tobject = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\n\n\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'AmbientLight':\n\n\t\t\t\tobject = new AmbientLight( data.color, data.intensity );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'DirectionalLight':\n\n\t\t\t\tobject = new DirectionalLight( data.color, data.intensity );\n\t\t\t\tobject.target = data.target || '';\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'PointLight':\n\n\t\t\t\tobject = new PointLight( data.color, data.intensity, data.distance, data.decay );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'RectAreaLight':\n\n\t\t\t\tobject = new RectAreaLight( data.color, data.intensity, data.width, data.height );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'SpotLight':\n\n\t\t\t\tobject = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\n\t\t\t\tobject.target = data.target || '';\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'HemisphereLight':\n\n\t\t\t\tobject = new HemisphereLight( data.color, data.groundColor, data.intensity );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LightProbe':\n\n\t\t\t\tobject = new LightProbe().fromJSON( data );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'SkinnedMesh':\n\n\t\t\t\tgeometry = getGeometry( data.geometry );\n\t\t\t \tmaterial = getMaterial( data.material );\n\n\t\t\t\tobject = new SkinnedMesh( geometry, material );\n\n\t\t\t\tif ( data.bindMode !== undefined ) object.bindMode = data.bindMode;\n\t\t\t\tif ( data.bindMatrix !== undefined ) object.bindMatrix.fromArray( data.bindMatrix );\n\t\t\t\tif ( data.skeleton !== undefined ) object.skeleton = data.skeleton;\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Mesh':\n\n\t\t\t\tgeometry = getGeometry( data.geometry );\n\t\t\t\tmaterial = getMaterial( data.material );\n\n\t\t\t\tobject = new Mesh( geometry, material );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'InstancedMesh':\n\n\t\t\t\tgeometry = getGeometry( data.geometry );\n\t\t\t\tmaterial = getMaterial( data.material );\n\t\t\t\tconst count = data.count;\n\t\t\t\tconst instanceMatrix = data.instanceMatrix;\n\t\t\t\tconst instanceColor = data.instanceColor;\n\n\t\t\t\tobject = new InstancedMesh( geometry, material, count );\n\t\t\t\tobject.instanceMatrix = new InstancedBufferAttribute( new Float32Array( instanceMatrix.array ), 16 );\n\t\t\t\tif ( instanceColor !== undefined ) object.instanceColor = new InstancedBufferAttribute( new Float32Array( instanceColor.array ), instanceColor.itemSize );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'BatchedMesh':\n\n\t\t\t\tgeometry = getGeometry( data.geometry );\n\t\t\t\tmaterial = getMaterial( data.material );\n\n\t\t\t\tobject = new BatchedMesh( data.maxInstanceCount, data.maxVertexCount, data.maxIndexCount, material );\n\t\t\t\tobject.geometry = geometry;\n\t\t\t\tobject.perObjectFrustumCulled = data.perObjectFrustumCulled;\n\t\t\t\tobject.sortObjects = data.sortObjects;\n\n\t\t\t\tobject._drawRanges = data.drawRanges;\n\t\t\t\tobject._reservedRanges = data.reservedRanges;\n\n\t\t\t\tobject._visibility = data.visibility;\n\t\t\t\tobject._active = data.active;\n\t\t\t\tobject._bounds = data.bounds.map( bound => {\n\n\t\t\t\t\tconst box = new Box3();\n\t\t\t\t\tbox.min.fromArray( bound.boxMin );\n\t\t\t\t\tbox.max.fromArray( bound.boxMax );\n\n\t\t\t\t\tconst sphere = new Sphere();\n\t\t\t\t\tsphere.radius = bound.sphereRadius;\n\t\t\t\t\tsphere.center.fromArray( bound.sphereCenter );\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tboxInitialized: bound.boxInitialized,\n\t\t\t\t\t\tbox: box,\n\n\t\t\t\t\t\tsphereInitialized: bound.sphereInitialized,\n\t\t\t\t\t\tsphere: sphere\n\t\t\t\t\t};\n\n\t\t\t\t} );\n\n\t\t\t\tobject._maxInstanceCount = data.maxInstanceCount;\n\t\t\t\tobject._maxVertexCount = data.maxVertexCount;\n\t\t\t\tobject._maxIndexCount = data.maxIndexCount;\n\n\t\t\t\tobject._geometryInitialized = data.geometryInitialized;\n\t\t\t\tobject._geometryCount = data.geometryCount;\n\n\t\t\t\tobject._matricesTexture = getTexture( data.matricesTexture.uuid );\n\t\t\t\tif ( data.colorsTexture !== undefined ) object._colorsTexture = getTexture( data.colorsTexture.uuid );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LOD':\n\n\t\t\t\tobject = new LOD();\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Line':\n\n\t\t\t\tobject = new Line( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LineLoop':\n\n\t\t\t\tobject = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LineSegments':\n\n\t\t\t\tobject = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'PointCloud':\n\t\t\tcase 'Points':\n\n\t\t\t\tobject = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Sprite':\n\n\t\t\t\tobject = new Sprite( getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Group':\n\n\t\t\t\tobject = new Group();\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Bone':\n\n\t\t\t\tobject = new Bone();\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tobject = new Object3D();\n\n\t\t}\n\n\t\tobject.uuid = data.uuid;\n\n\t\tif ( data.name !== undefined ) object.name = data.name;\n\n\t\tif ( data.matrix !== undefined ) {\n\n\t\t\tobject.matrix.fromArray( data.matrix );\n\n\t\t\tif ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;\n\t\t\tif ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t} else {\n\n\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\n\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\n\t\t\tif ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );\n\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\n\n\t\t}\n\n\t\tif ( data.up !== undefined ) object.up.fromArray( data.up );\n\n\t\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\n\t\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\n\n\t\tif ( data.shadow ) {\n\n\t\t\tif ( data.shadow.intensity !== undefined ) object.shadow.intensity = data.shadow.intensity;\n\t\t\tif ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;\n\t\t\tif ( data.shadow.normalBias !== undefined ) object.shadow.normalBias = data.shadow.normalBias;\n\t\t\tif ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;\n\t\t\tif ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );\n\t\t\tif ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );\n\n\t\t}\n\n\t\tif ( data.visible !== undefined ) object.visible = data.visible;\n\t\tif ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;\n\t\tif ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;\n\t\tif ( data.userData !== undefined ) object.userData = data.userData;\n\t\tif ( data.layers !== undefined ) object.layers.mask = data.layers;\n\n\t\tif ( data.children !== undefined ) {\n\n\t\t\tconst children = data.children;\n\n\t\t\tfor ( let i = 0; i < children.length; i ++ ) {\n\n\t\t\t\tobject.add( this.parseObject( children[ i ], geometries, materials, textures, animations ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( data.animations !== undefined ) {\n\n\t\t\tconst objectAnimations = data.animations;\n\n\t\t\tfor ( let i = 0; i < objectAnimations.length; i ++ ) {\n\n\t\t\t\tconst uuid = objectAnimations[ i ];\n\n\t\t\t\tobject.animations.push( animations[ uuid ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( data.type === 'LOD' ) {\n\n\t\t\tif ( data.autoUpdate !== undefined ) object.autoUpdate = data.autoUpdate;\n\n\t\t\tconst levels = data.levels;\n\n\t\t\tfor ( let l = 0; l < levels.length; l ++ ) {\n\n\t\t\t\tconst level = levels[ l ];\n\t\t\t\tconst child = object.getObjectByProperty( 'uuid', level.object );\n\n\t\t\t\tif ( child !== undefined ) {\n\n\t\t\t\t\tobject.addLevel( child, level.distance, level.hysteresis );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn object;\n\n\t}\n\n\tbindSkeletons( object, skeletons ) {\n\n\t\tif ( Object.keys( skeletons ).length === 0 ) return;\n\n\t\tobject.traverse( function ( child ) {\n\n\t\t\tif ( child.isSkinnedMesh === true && child.skeleton !== undefined ) {\n\n\t\t\t\tconst skeleton = skeletons[ child.skeleton ];\n\n\t\t\t\tif ( skeleton === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tchild.bind( skeleton, child.bindMatrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\tbindLightTargets( object ) {\n\n\t\tobject.traverse( function ( child ) {\n\n\t\t\tif ( child.isDirectionalLight || child.isSpotLight ) {\n\n\t\t\t\tconst uuid = child.target;\n\n\t\t\t\tconst target = object.getObjectByProperty( 'uuid', uuid );\n\n\t\t\t\tif ( target !== undefined ) {\n\n\t\t\t\t\tchild.target = target;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tchild.target = new Object3D();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n}\n\nconst TEXTURE_MAPPING = {\n\tUVMapping: UVMapping,\n\tCubeReflectionMapping: CubeReflectionMapping,\n\tCubeRefractionMapping: CubeRefractionMapping,\n\tEquirectangularReflectionMapping: EquirectangularReflectionMapping,\n\tEquirectangularRefractionMapping: EquirectangularRefractionMapping,\n\tCubeUVReflectionMapping: CubeUVReflectionMapping\n};\n\nconst TEXTURE_WRAPPING = {\n\tRepeatWrapping: RepeatWrapping,\n\tClampToEdgeWrapping: ClampToEdgeWrapping,\n\tMirroredRepeatWrapping: MirroredRepeatWrapping\n};\n\nconst TEXTURE_FILTER = {\n\tNearestFilter: NearestFilter,\n\tNearestMipmapNearestFilter: NearestMipmapNearestFilter,\n\tNearestMipmapLinearFilter: NearestMipmapLinearFilter,\n\tLinearFilter: LinearFilter,\n\tLinearMipmapNearestFilter: LinearMipmapNearestFilter,\n\tLinearMipmapLinearFilter: LinearMipmapLinearFilter\n};\n\nclass ImageBitmapLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.isImageBitmapLoader = true;\n\n\t\tif ( typeof createImageBitmap === 'undefined' ) {\n\n\t\t\tconsole.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );\n\n\t\t}\n\n\t\tif ( typeof fetch === 'undefined' ) {\n\n\t\t\tconsole.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );\n\n\t\t}\n\n\t\tthis.options = { premultiplyAlpha: 'none' };\n\n\t}\n\n\tsetOptions( options ) {\n\n\t\tthis.options = options;\n\n\t\treturn this;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tif ( url === undefined ) url = '';\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\turl = this.manager.resolveURL( url );\n\n\t\tconst scope = this;\n\n\t\tconst cached = Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\t// If cached is a promise, wait for it to resolve\n\t\t\tif ( cached.then ) {\n\n\t\t\t\tcached.then( imageBitmap => {\n\n\t\t\t\t\tif ( onLoad ) onLoad( imageBitmap );\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t} ).catch( e => {\n\n\t\t\t\t\tif ( onError ) onError( e );\n\n\t\t\t\t} );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// If cached is not a promise (i.e., it's already an imageBitmap)\n\t\t\tsetTimeout( function () {\n\n\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, 0 );\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\tconst fetchOptions = {};\n\t\tfetchOptions.credentials = ( this.crossOrigin === 'anonymous' ) ? 'same-origin' : 'include';\n\t\tfetchOptions.headers = this.requestHeader;\n\n\t\tconst promise = fetch( url, fetchOptions ).then( function ( res ) {\n\n\t\t\treturn res.blob();\n\n\t\t} ).then( function ( blob ) {\n\n\t\t\treturn createImageBitmap( blob, Object.assign( scope.options, { colorSpaceConversion: 'none' } ) );\n\n\t\t} ).then( function ( imageBitmap ) {\n\n\t\t\tCache.add( url, imageBitmap );\n\n\t\t\tif ( onLoad ) onLoad( imageBitmap );\n\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t\treturn imageBitmap;\n\n\t\t} ).catch( function ( e ) {\n\n\t\t\tif ( onError ) onError( e );\n\n\t\t\tCache.remove( url );\n\n\t\t\tscope.manager.itemError( url );\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t} );\n\n\t\tCache.add( url, promise );\n\t\tscope.manager.itemStart( url );\n\n\t}\n\n}\n\nlet _context;\n\nclass AudioContext {\n\n\tstatic getContext() {\n\n\t\tif ( _context === undefined ) {\n\n\t\t\t_context = new ( window.AudioContext || window.webkitAudioContext )();\n\n\t\t}\n\n\t\treturn _context;\n\n\t}\n\n\tstatic setContext( value ) {\n\n\t\t_context = value;\n\n\t}\n\n}\n\nclass AudioLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\ttry {\n\n\t\t\t\t// Create a copy of the buffer. The `decodeAudioData` method\n\t\t\t\t// detaches the buffer when complete, preventing reuse.\n\t\t\t\tconst bufferCopy = buffer.slice( 0 );\n\n\t\t\t\tconst context = AudioContext.getContext();\n\t\t\t\tcontext.decodeAudioData( bufferCopy, function ( audioBuffer ) {\n\n\t\t\t\t\tonLoad( audioBuffer );\n\n\t\t\t\t} ).catch( handleError );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\thandleError( e );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t\tfunction handleError( e ) {\n\n\t\t\tif ( onError ) {\n\n\t\t\t\tonError( e );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( e );\n\n\t\t\t}\n\n\t\t\tscope.manager.itemError( url );\n\n\t\t}\n\n\t}\n\n}\n\nconst _eyeRight = /*@__PURE__*/ new Matrix4();\nconst _eyeLeft = /*@__PURE__*/ new Matrix4();\nconst _projectionMatrix = /*@__PURE__*/ new Matrix4();\n\nclass StereoCamera {\n\n\tconstructor() {\n\n\t\tthis.type = 'StereoCamera';\n\n\t\tthis.aspect = 1;\n\n\t\tthis.eyeSep = 0.064;\n\n\t\tthis.cameraL = new PerspectiveCamera();\n\t\tthis.cameraL.layers.enable( 1 );\n\t\tthis.cameraL.matrixAutoUpdate = false;\n\n\t\tthis.cameraR = new PerspectiveCamera();\n\t\tthis.cameraR.layers.enable( 2 );\n\t\tthis.cameraR.matrixAutoUpdate = false;\n\n\t\tthis._cache = {\n\t\t\tfocus: null,\n\t\t\tfov: null,\n\t\t\taspect: null,\n\t\t\tnear: null,\n\t\t\tfar: null,\n\t\t\tzoom: null,\n\t\t\teyeSep: null\n\t\t};\n\n\t}\n\n\tupdate( camera ) {\n\n\t\tconst cache = this._cache;\n\n\t\tconst needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov ||\n\t\t\tcache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near ||\n\t\t\tcache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;\n\n\t\tif ( needsUpdate ) {\n\n\t\t\tcache.focus = camera.focus;\n\t\t\tcache.fov = camera.fov;\n\t\t\tcache.aspect = camera.aspect * this.aspect;\n\t\t\tcache.near = camera.near;\n\t\t\tcache.far = camera.far;\n\t\t\tcache.zoom = camera.zoom;\n\t\t\tcache.eyeSep = this.eyeSep;\n\n\t\t\t// Off-axis stereoscopic effect based on\n\t\t\t// http://paulbourke.net/stereographics/stereorender/\n\n\t\t\t_projectionMatrix.copy( camera.projectionMatrix );\n\t\t\tconst eyeSepHalf = cache.eyeSep / 2;\n\t\t\tconst eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;\n\t\t\tconst ymax = ( cache.near * Math.tan( DEG2RAD * cache.fov * 0.5 ) ) / cache.zoom;\n\t\t\tlet xmin, xmax;\n\n\t\t\t// translate xOffset\n\n\t\t\t_eyeLeft.elements[ 12 ] = - eyeSepHalf;\n\t\t\t_eyeRight.elements[ 12 ] = eyeSepHalf;\n\n\t\t\t// for left eye\n\n\t\t\txmin = - ymax * cache.aspect + eyeSepOnProjection;\n\t\t\txmax = ymax * cache.aspect + eyeSepOnProjection;\n\n\t\t\t_projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );\n\t\t\t_projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\tthis.cameraL.projectionMatrix.copy( _projectionMatrix );\n\n\t\t\t// for right eye\n\n\t\t\txmin = - ymax * cache.aspect - eyeSepOnProjection;\n\t\t\txmax = ymax * cache.aspect - eyeSepOnProjection;\n\n\t\t\t_projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );\n\t\t\t_projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\tthis.cameraR.projectionMatrix.copy( _projectionMatrix );\n\n\t\t}\n\n\t\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeLeft );\n\t\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeRight );\n\n\t}\n\n}\n\nclass ArrayCamera extends PerspectiveCamera {\n\n\tconstructor( array = [] ) {\n\n\t\tsuper();\n\n\t\tthis.isArrayCamera = true;\n\n\t\tthis.cameras = array;\n\n\t}\n\n}\n\nclass Clock {\n\n\tconstructor( autoStart = true ) {\n\n\t\tthis.autoStart = autoStart;\n\n\t\tthis.startTime = 0;\n\t\tthis.oldTime = 0;\n\t\tthis.elapsedTime = 0;\n\n\t\tthis.running = false;\n\n\t}\n\n\tstart() {\n\n\t\tthis.startTime = now();\n\n\t\tthis.oldTime = this.startTime;\n\t\tthis.elapsedTime = 0;\n\t\tthis.running = true;\n\n\t}\n\n\tstop() {\n\n\t\tthis.getElapsedTime();\n\t\tthis.running = false;\n\t\tthis.autoStart = false;\n\n\t}\n\n\tgetElapsedTime() {\n\n\t\tthis.getDelta();\n\t\treturn this.elapsedTime;\n\n\t}\n\n\tgetDelta() {\n\n\t\tlet diff = 0;\n\n\t\tif ( this.autoStart && ! this.running ) {\n\n\t\t\tthis.start();\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tif ( this.running ) {\n\n\t\t\tconst newTime = now();\n\n\t\t\tdiff = ( newTime - this.oldTime ) / 1000;\n\t\t\tthis.oldTime = newTime;\n\n\t\t\tthis.elapsedTime += diff;\n\n\t\t}\n\n\t\treturn diff;\n\n\t}\n\n}\n\nfunction now() {\n\n\treturn performance.now();\n\n}\n\nconst _position$1 = /*@__PURE__*/ new Vector3();\nconst _quaternion$1 = /*@__PURE__*/ new Quaternion();\nconst _scale$1 = /*@__PURE__*/ new Vector3();\nconst _orientation$1 = /*@__PURE__*/ new Vector3();\n\nclass AudioListener extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.type = 'AudioListener';\n\n\t\tthis.context = AudioContext.getContext();\n\n\t\tthis.gain = this.context.createGain();\n\t\tthis.gain.connect( this.context.destination );\n\n\t\tthis.filter = null;\n\n\t\tthis.timeDelta = 0;\n\n\t\t// private\n\n\t\tthis._clock = new Clock();\n\n\t}\n\n\tgetInput() {\n\n\t\treturn this.gain;\n\n\t}\n\n\tremoveFilter() {\n\n\t\tif ( this.filter !== null ) {\n\n\t\t\tthis.gain.disconnect( this.filter );\n\t\t\tthis.filter.disconnect( this.context.destination );\n\t\t\tthis.gain.connect( this.context.destination );\n\t\t\tthis.filter = null;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetFilter() {\n\n\t\treturn this.filter;\n\n\t}\n\n\tsetFilter( value ) {\n\n\t\tif ( this.filter !== null ) {\n\n\t\t\tthis.gain.disconnect( this.filter );\n\t\t\tthis.filter.disconnect( this.context.destination );\n\n\t\t} else {\n\n\t\t\tthis.gain.disconnect( this.context.destination );\n\n\t\t}\n\n\t\tthis.filter = value;\n\t\tthis.gain.connect( this.filter );\n\t\tthis.filter.connect( this.context.destination );\n\n\t\treturn this;\n\n\t}\n\n\tgetMasterVolume() {\n\n\t\treturn this.gain.gain.value;\n\n\t}\n\n\tsetMasterVolume( value ) {\n\n\t\tthis.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );\n\n\t\treturn this;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tconst listener = this.context.listener;\n\t\tconst up = this.up;\n\n\t\tthis.timeDelta = this._clock.getDelta();\n\n\t\tthis.matrixWorld.decompose( _position$1, _quaternion$1, _scale$1 );\n\n\t\t_orientation$1.set( 0, 0, - 1 ).applyQuaternion( _quaternion$1 );\n\n\t\tif ( listener.positionX ) {\n\n\t\t\t// code path for Chrome (see #14393)\n\n\t\t\tconst endTime = this.context.currentTime + this.timeDelta;\n\n\t\t\tlistener.positionX.linearRampToValueAtTime( _position$1.x, endTime );\n\t\t\tlistener.positionY.linearRampToValueAtTime( _position$1.y, endTime );\n\t\t\tlistener.positionZ.linearRampToValueAtTime( _position$1.z, endTime );\n\t\t\tlistener.forwardX.linearRampToValueAtTime( _orientation$1.x, endTime );\n\t\t\tlistener.forwardY.linearRampToValueAtTime( _orientation$1.y, endTime );\n\t\t\tlistener.forwardZ.linearRampToValueAtTime( _orientation$1.z, endTime );\n\t\t\tlistener.upX.linearRampToValueAtTime( up.x, endTime );\n\t\t\tlistener.upY.linearRampToValueAtTime( up.y, endTime );\n\t\t\tlistener.upZ.linearRampToValueAtTime( up.z, endTime );\n\n\t\t} else {\n\n\t\t\tlistener.setPosition( _position$1.x, _position$1.y, _position$1.z );\n\t\t\tlistener.setOrientation( _orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z );\n\n\t\t}\n\n\t}\n\n}\n\nclass Audio extends Object3D {\n\n\tconstructor( listener ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'Audio';\n\n\t\tthis.listener = listener;\n\t\tthis.context = listener.context;\n\n\t\tthis.gain = this.context.createGain();\n\t\tthis.gain.connect( listener.getInput() );\n\n\t\tthis.autoplay = false;\n\n\t\tthis.buffer = null;\n\t\tthis.detune = 0;\n\t\tthis.loop = false;\n\t\tthis.loopStart = 0;\n\t\tthis.loopEnd = 0;\n\t\tthis.offset = 0;\n\t\tthis.duration = undefined;\n\t\tthis.playbackRate = 1;\n\t\tthis.isPlaying = false;\n\t\tthis.hasPlaybackControl = true;\n\t\tthis.source = null;\n\t\tthis.sourceType = 'empty';\n\n\t\tthis._startedAt = 0;\n\t\tthis._progress = 0;\n\t\tthis._connected = false;\n\n\t\tthis.filters = [];\n\n\t}\n\n\tgetOutput() {\n\n\t\treturn this.gain;\n\n\t}\n\n\tsetNodeSource( audioNode ) {\n\n\t\tthis.hasPlaybackControl = false;\n\t\tthis.sourceType = 'audioNode';\n\t\tthis.source = audioNode;\n\t\tthis.connect();\n\n\t\treturn this;\n\n\t}\n\n\tsetMediaElementSource( mediaElement ) {\n\n\t\tthis.hasPlaybackControl = false;\n\t\tthis.sourceType = 'mediaNode';\n\t\tthis.source = this.context.createMediaElementSource( mediaElement );\n\t\tthis.connect();\n\n\t\treturn this;\n\n\t}\n\n\tsetMediaStreamSource( mediaStream ) {\n\n\t\tthis.hasPlaybackControl = false;\n\t\tthis.sourceType = 'mediaStreamNode';\n\t\tthis.source = this.context.createMediaStreamSource( mediaStream );\n\t\tthis.connect();\n\n\t\treturn this;\n\n\t}\n\n\tsetBuffer( audioBuffer ) {\n\n\t\tthis.buffer = audioBuffer;\n\t\tthis.sourceType = 'buffer';\n\n\t\tif ( this.autoplay ) this.play();\n\n\t\treturn this;\n\n\t}\n\n\tplay( delay = 0 ) {\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis._startedAt = this.context.currentTime + delay;\n\n\t\tconst source = this.context.createBufferSource();\n\t\tsource.buffer = this.buffer;\n\t\tsource.loop = this.loop;\n\t\tsource.loopStart = this.loopStart;\n\t\tsource.loopEnd = this.loopEnd;\n\t\tsource.onended = this.onEnded.bind( this );\n\t\tsource.start( this._startedAt, this._progress + this.offset, this.duration );\n\n\t\tthis.isPlaying = true;\n\n\t\tthis.source = source;\n\n\t\tthis.setDetune( this.detune );\n\t\tthis.setPlaybackRate( this.playbackRate );\n\n\t\treturn this.connect();\n\n\t}\n\n\tpause() {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\t// update current progress\n\n\t\t\tthis._progress += Math.max( this.context.currentTime - this._startedAt, 0 ) * this.playbackRate;\n\n\t\t\tif ( this.loop === true ) {\n\n\t\t\t\t// ensure _progress does not exceed duration with looped audios\n\n\t\t\t\tthis._progress = this._progress % ( this.duration || this.buffer.duration );\n\n\t\t\t}\n\n\t\t\tthis.source.stop();\n\t\t\tthis.source.onended = null;\n\n\t\t\tthis.isPlaying = false;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tstop( delay = 0 ) {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis._progress = 0;\n\n\t\tif ( this.source !== null ) {\n\n\t\t\tthis.source.stop( this.context.currentTime + delay );\n\t\t\tthis.source.onended = null;\n\n\t\t}\n\n\t\tthis.isPlaying = false;\n\n\t\treturn this;\n\n\t}\n\n\tconnect() {\n\n\t\tif ( this.filters.length > 0 ) {\n\n\t\t\tthis.source.connect( this.filters[ 0 ] );\n\n\t\t\tfor ( let i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\tthis.filters[ i - 1 ].connect( this.filters[ i ] );\n\n\t\t\t}\n\n\t\t\tthis.filters[ this.filters.length - 1 ].connect( this.getOutput() );\n\n\t\t} else {\n\n\t\t\tthis.source.connect( this.getOutput() );\n\n\t\t}\n\n\t\tthis._connected = true;\n\n\t\treturn this;\n\n\t}\n\n\tdisconnect() {\n\n\t\tif ( this._connected === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.filters.length > 0 ) {\n\n\t\t\tthis.source.disconnect( this.filters[ 0 ] );\n\n\t\t\tfor ( let i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\tthis.filters[ i - 1 ].disconnect( this.filters[ i ] );\n\n\t\t\t}\n\n\t\t\tthis.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );\n\n\t\t} else {\n\n\t\t\tthis.source.disconnect( this.getOutput() );\n\n\t\t}\n\n\t\tthis._connected = false;\n\n\t\treturn this;\n\n\t}\n\n\tgetFilters() {\n\n\t\treturn this.filters;\n\n\t}\n\n\tsetFilters( value ) {\n\n\t\tif ( ! value ) value = [];\n\n\t\tif ( this._connected === true ) {\n\n\t\t\tthis.disconnect();\n\t\t\tthis.filters = value.slice();\n\t\t\tthis.connect();\n\n\t\t} else {\n\n\t\t\tthis.filters = value.slice();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetDetune( value ) {\n\n\t\tthis.detune = value;\n\n\t\tif ( this.isPlaying === true && this.source.detune !== undefined ) {\n\n\t\t\tthis.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetDetune() {\n\n\t\treturn this.detune;\n\n\t}\n\n\tgetFilter() {\n\n\t\treturn this.getFilters()[ 0 ];\n\n\t}\n\n\tsetFilter( filter ) {\n\n\t\treturn this.setFilters( filter ? [ filter ] : [] );\n\n\t}\n\n\tsetPlaybackRate( value ) {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.playbackRate = value;\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetPlaybackRate() {\n\n\t\treturn this.playbackRate;\n\n\t}\n\n\tonEnded() {\n\n\t\tthis.isPlaying = false;\n\t\tthis._progress = 0;\n\n\t}\n\n\tgetLoop() {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn this.loop;\n\n\t}\n\n\tsetLoop( value ) {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.loop = value;\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.source.loop = this.loop;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetLoopStart( value ) {\n\n\t\tthis.loopStart = value;\n\n\t\treturn this;\n\n\t}\n\n\tsetLoopEnd( value ) {\n\n\t\tthis.loopEnd = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetVolume() {\n\n\t\treturn this.gain.gain.value;\n\n\t}\n\n\tsetVolume( value ) {\n\n\t\tthis.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tif ( source.sourceType !== 'buffer' ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: Audio source type cannot be copied.' );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tthis.autoplay = source.autoplay;\n\n\t\tthis.buffer = source.buffer;\n\t\tthis.detune = source.detune;\n\t\tthis.loop = source.loop;\n\t\tthis.loopStart = source.loopStart;\n\t\tthis.loopEnd = source.loopEnd;\n\t\tthis.offset = source.offset;\n\t\tthis.duration = source.duration;\n\t\tthis.playbackRate = source.playbackRate;\n\t\tthis.hasPlaybackControl = source.hasPlaybackControl;\n\t\tthis.sourceType = source.sourceType;\n\n\t\tthis.filters = source.filters.slice();\n\n\t\treturn this;\n\n\t}\n\n\tclone( recursive ) {\n\n\t\treturn new this.constructor( this.listener ).copy( this, recursive );\n\n\t}\n\n}\n\nconst _position = /*@__PURE__*/ new Vector3();\nconst _quaternion = /*@__PURE__*/ new Quaternion();\nconst _scale = /*@__PURE__*/ new Vector3();\nconst _orientation = /*@__PURE__*/ new Vector3();\n\nclass PositionalAudio extends Audio {\n\n\tconstructor( listener ) {\n\n\t\tsuper( listener );\n\n\t\tthis.panner = this.context.createPanner();\n\t\tthis.panner.panningModel = 'HRTF';\n\t\tthis.panner.connect( this.gain );\n\n\t}\n\n\tconnect() {\n\n\t\tsuper.connect();\n\n\t\tthis.panner.connect( this.gain );\n\n\t}\n\n\tdisconnect() {\n\n\t\tsuper.disconnect();\n\n\t\tthis.panner.disconnect( this.gain );\n\n\t}\n\n\tgetOutput() {\n\n\t\treturn this.panner;\n\n\t}\n\n\tgetRefDistance() {\n\n\t\treturn this.panner.refDistance;\n\n\t}\n\n\tsetRefDistance( value ) {\n\n\t\tthis.panner.refDistance = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetRolloffFactor() {\n\n\t\treturn this.panner.rolloffFactor;\n\n\t}\n\n\tsetRolloffFactor( value ) {\n\n\t\tthis.panner.rolloffFactor = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetDistanceModel() {\n\n\t\treturn this.panner.distanceModel;\n\n\t}\n\n\tsetDistanceModel( value ) {\n\n\t\tthis.panner.distanceModel = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetMaxDistance() {\n\n\t\treturn this.panner.maxDistance;\n\n\t}\n\n\tsetMaxDistance( value ) {\n\n\t\tthis.panner.maxDistance = value;\n\n\t\treturn this;\n\n\t}\n\n\tsetDirectionalCone( coneInnerAngle, coneOuterAngle, coneOuterGain ) {\n\n\t\tthis.panner.coneInnerAngle = coneInnerAngle;\n\t\tthis.panner.coneOuterAngle = coneOuterAngle;\n\t\tthis.panner.coneOuterGain = coneOuterGain;\n\n\t\treturn this;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tif ( this.hasPlaybackControl === true && this.isPlaying === false ) return;\n\n\t\tthis.matrixWorld.decompose( _position, _quaternion, _scale );\n\n\t\t_orientation.set( 0, 0, 1 ).applyQuaternion( _quaternion );\n\n\t\tconst panner = this.panner;\n\n\t\tif ( panner.positionX ) {\n\n\t\t\t// code path for Chrome and Firefox (see #14393)\n\n\t\t\tconst endTime = this.context.currentTime + this.listener.timeDelta;\n\n\t\t\tpanner.positionX.linearRampToValueAtTime( _position.x, endTime );\n\t\t\tpanner.positionY.linearRampToValueAtTime( _position.y, endTime );\n\t\t\tpanner.positionZ.linearRampToValueAtTime( _position.z, endTime );\n\t\t\tpanner.orientationX.linearRampToValueAtTime( _orientation.x, endTime );\n\t\t\tpanner.orientationY.linearRampToValueAtTime( _orientation.y, endTime );\n\t\t\tpanner.orientationZ.linearRampToValueAtTime( _orientation.z, endTime );\n\n\t\t} else {\n\n\t\t\tpanner.setPosition( _position.x, _position.y, _position.z );\n\t\t\tpanner.setOrientation( _orientation.x, _orientation.y, _orientation.z );\n\n\t\t}\n\n\t}\n\n}\n\nclass AudioAnalyser {\n\n\tconstructor( audio, fftSize = 2048 ) {\n\n\t\tthis.analyser = audio.context.createAnalyser();\n\t\tthis.analyser.fftSize = fftSize;\n\n\t\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\n\n\t\taudio.getOutput().connect( this.analyser );\n\n\t}\n\n\n\tgetFrequencyData() {\n\n\t\tthis.analyser.getByteFrequencyData( this.data );\n\n\t\treturn this.data;\n\n\t}\n\n\tgetAverageFrequency() {\n\n\t\tlet value = 0;\n\t\tconst data = this.getFrequencyData();\n\n\t\tfor ( let i = 0; i < data.length; i ++ ) {\n\n\t\t\tvalue += data[ i ];\n\n\t\t}\n\n\t\treturn value / data.length;\n\n\t}\n\n}\n\nclass PropertyMixer {\n\n\tconstructor( binding, typeName, valueSize ) {\n\n\t\tthis.binding = binding;\n\t\tthis.valueSize = valueSize;\n\n\t\tlet mixFunction,\n\t\t\tmixFunctionAdditive,\n\t\t\tsetIdentity;\n\n\t\t// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]\n\t\t//\n\t\t// interpolators can use .buffer as their .result\n\t\t// the data then goes to 'incoming'\n\t\t//\n\t\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t\t// the cumulative result and are compared to detect\n\t\t// changes\n\t\t//\n\t\t// 'orig' stores the original state of the property\n\t\t//\n\t\t// 'add' is used for additive cumulative results\n\t\t//\n\t\t// 'work' is optional and is only present for quaternion types. It is used\n\t\t// to store intermediate quaternion multiplication results\n\n\t\tswitch ( typeName ) {\n\n\t\t\tcase 'quaternion':\n\t\t\t\tmixFunction = this._slerp;\n\t\t\t\tmixFunctionAdditive = this._slerpAdditive;\n\t\t\t\tsetIdentity = this._setAdditiveIdentityQuaternion;\n\n\t\t\t\tthis.buffer = new Float64Array( valueSize * 6 );\n\t\t\t\tthis._workIndex = 5;\n\t\t\t\tbreak;\n\n\t\t\tcase 'string':\n\t\t\tcase 'bool':\n\t\t\t\tmixFunction = this._select;\n\n\t\t\t\t// Use the regular mix function and for additive on these types,\n\t\t\t\t// additive is not relevant for non-numeric types\n\t\t\t\tmixFunctionAdditive = this._select;\n\n\t\t\t\tsetIdentity = this._setAdditiveIdentityOther;\n\n\t\t\t\tthis.buffer = new Array( valueSize * 5 );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tmixFunction = this._lerp;\n\t\t\t\tmixFunctionAdditive = this._lerpAdditive;\n\t\t\t\tsetIdentity = this._setAdditiveIdentityNumeric;\n\n\t\t\t\tthis.buffer = new Float64Array( valueSize * 5 );\n\n\t\t}\n\n\t\tthis._mixBufferRegion = mixFunction;\n\t\tthis._mixBufferRegionAdditive = mixFunctionAdditive;\n\t\tthis._setIdentity = setIdentity;\n\t\tthis._origIndex = 3;\n\t\tthis._addIndex = 4;\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t\tthis.useCount = 0;\n\t\tthis.referenceCount = 0;\n\n\t}\n\n\t// accumulate data in the 'incoming' region into 'accu<i>'\n\taccumulate( accuIndex, weight ) {\n\n\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t// the weight and shouldn't have made the call in the first place\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = accuIndex * stride + stride;\n\n\t\tlet currentWeight = this.cumulativeWeight;\n\n\t\tif ( currentWeight === 0 ) {\n\n\t\t\t// accuN := incoming * weight\n\n\t\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\n\n\t\t\t}\n\n\t\t\tcurrentWeight = weight;\n\n\t\t} else {\n\n\t\t\t// accuN := accuN + incoming * weight\n\n\t\t\tcurrentWeight += weight;\n\t\t\tconst mix = weight / currentWeight;\n\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\n\n\t\t}\n\n\t\tthis.cumulativeWeight = currentWeight;\n\n\t}\n\n\t// accumulate data in the 'incoming' region into 'add'\n\taccumulateAdditive( weight ) {\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = stride * this._addIndex;\n\n\t\tif ( this.cumulativeWeightAdditive === 0 ) {\n\n\t\t\t// add = identity\n\n\t\t\tthis._setIdentity();\n\n\t\t}\n\n\t\t// add := add + incoming * weight\n\n\t\tthis._mixBufferRegionAdditive( buffer, offset, 0, weight, stride );\n\t\tthis.cumulativeWeightAdditive += weight;\n\n\t}\n\n\t// apply the state of 'accu<i>' to the binding when accus differ\n\tapply( accuIndex ) {\n\n\t\tconst stride = this.valueSize,\n\t\t\tbuffer = this.buffer,\n\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\tweight = this.cumulativeWeight,\n\t\t\tweightAdditive = this.cumulativeWeightAdditive,\n\n\t\t\tbinding = this.binding;\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t\tif ( weight < 1 ) {\n\n\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\n\t\t\tconst originalValueOffset = stride * this._origIndex;\n\n\t\t\tthis._mixBufferRegion(\n\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\n\n\t\t}\n\n\t\tif ( weightAdditive > 0 ) {\n\n\t\t\t// accuN := accuN + additive accuN\n\n\t\t\tthis._mixBufferRegionAdditive( buffer, offset, this._addIndex * stride, 1, stride );\n\n\t\t}\n\n\t\tfor ( let i = stride, e = stride + stride; i !== e; ++ i ) {\n\n\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\n\n\t\t\t\t// value has changed -> update scene graph\n\n\t\t\t\tbinding.setValue( buffer, offset );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// remember the state of the bound property and copy it to both accus\n\tsaveOriginalState() {\n\n\t\tconst binding = this.binding;\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\n\t\t\toriginalValueOffset = stride * this._origIndex;\n\n\t\tbinding.getValue( buffer, originalValueOffset );\n\n\t\t// accu[0..1] := orig -- initially detect changes against the original\n\t\tfor ( let i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\n\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\n\t\t}\n\n\t\t// Add to identity for additive\n\t\tthis._setIdentity();\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t}\n\n\t// apply the state previously taken via 'saveOriginalState' to the binding\n\trestoreOriginalState() {\n\n\t\tconst originalValueOffset = this.valueSize * 3;\n\t\tthis.binding.setValue( this.buffer, originalValueOffset );\n\n\t}\n\n\t_setAdditiveIdentityNumeric() {\n\n\t\tconst startIndex = this._addIndex * this.valueSize;\n\t\tconst endIndex = startIndex + this.valueSize;\n\n\t\tfor ( let i = startIndex; i < endIndex; i ++ ) {\n\n\t\t\tthis.buffer[ i ] = 0;\n\n\t\t}\n\n\t}\n\n\t_setAdditiveIdentityQuaternion() {\n\n\t\tthis._setAdditiveIdentityNumeric();\n\t\tthis.buffer[ this._addIndex * this.valueSize + 3 ] = 1;\n\n\t}\n\n\t_setAdditiveIdentityOther() {\n\n\t\tconst startIndex = this._origIndex * this.valueSize;\n\t\tconst targetIndex = this._addIndex * this.valueSize;\n\n\t\tfor ( let i = 0; i < this.valueSize; i ++ ) {\n\n\t\t\tthis.buffer[ targetIndex + i ] = this.buffer[ startIndex + i ];\n\n\t\t}\n\n\t}\n\n\n\t// mix functions\n\n\t_select( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tif ( t >= 0.5 ) {\n\n\t\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_slerp( buffer, dstOffset, srcOffset, t ) {\n\n\t\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );\n\n\t}\n\n\t_slerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tconst workOffset = this._workIndex * stride;\n\n\t\t// Store result in intermediate buffer offset\n\t\tQuaternion.multiplyQuaternionsFlat( buffer, workOffset, buffer, dstOffset, buffer, srcOffset );\n\n\t\t// Slerp to the intermediate result\n\t\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t );\n\n\t}\n\n\t_lerp( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tconst s = 1 - t;\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tconst j = dstOffset + i;\n\n\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\n\n\t\t}\n\n\t}\n\n\t_lerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tconst j = dstOffset + i;\n\n\t\t\tbuffer[ j ] = buffer[ j ] + buffer[ srcOffset + i ] * t;\n\n\t\t}\n\n\t}\n\n}\n\n// Characters [].:/ are reserved for track binding syntax.\nconst _RESERVED_CHARS_RE = '\\\\[\\\\]\\\\.:\\\\/';\nconst _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );\n\n// Attempts to allow node names from any language. ES5's `\\w` regexp matches\n// only latin characters, and the unicode \\p{L} is not yet supported. So\n// instead, we exclude reserved characters and match everything else.\nconst _wordChar = '[^' + _RESERVED_CHARS_RE + ']';\nconst _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\\\.', '' ) + ']';\n\n// Parent directories, delimited by '/' or ':'. Currently unused, but must\n// be matched to parse the rest of the track name.\nconst _directoryRe = /*@__PURE__*/ /((?:WC+[\\/:])*)/.source.replace( 'WC', _wordChar );\n\n// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.\nconst _nodeRe = /*@__PURE__*/ /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );\n\n// Object on target node, and accessor. May not contain reserved\n// characters. Accessor may contain any character except closing bracket.\nconst _objectRe = /*@__PURE__*/ /(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace( 'WC', _wordChar );\n\n// Property and accessor. May not contain reserved characters. Accessor may\n// contain any non-bracket characters.\nconst _propertyRe = /*@__PURE__*/ /\\.(WC+)(?:\\[(.+)\\])?/.source.replace( 'WC', _wordChar );\n\nconst _trackRe = new RegExp( ''\n\t+ '^'\n\t+ _directoryRe\n\t+ _nodeRe\n\t+ _objectRe\n\t+ _propertyRe\n\t+ '$'\n);\n\nconst _supportedObjectNames = [ 'material', 'materials', 'bones', 'map' ];\n\nclass Composite {\n\n\tconstructor( targetGroup, path, optionalParsedPath ) {\n\n\t\tconst parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );\n\n\t\tthis._targetGroup = targetGroup;\n\t\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\n\n\t}\n\n\tgetValue( array, offset ) {\n\n\t\tthis.bind(); // bind all binding\n\n\t\tconst firstValidIndex = this._targetGroup.nCachedObjects_,\n\t\t\tbinding = this._bindings[ firstValidIndex ];\n\n\t\t// and only call .getValue on the first\n\t\tif ( binding !== undefined ) binding.getValue( array, offset );\n\n\t}\n\n\tsetValue( array, offset ) {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].setValue( array, offset );\n\n\t\t}\n\n\t}\n\n\tbind() {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].bind();\n\n\t\t}\n\n\t}\n\n\tunbind() {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].unbind();\n\n\t\t}\n\n\t}\n\n}\n\n// Note: This class uses a State pattern on a per-method basis:\n// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n// prototype version of these methods with one that represents\n// the bound state. When the property is not found, the methods\n// become no-ops.\nclass PropertyBinding {\n\n\tconstructor( rootNode, path, parsedPath ) {\n\n\t\tthis.path = path;\n\t\tthis.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );\n\n\t\tthis.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName );\n\n\t\tthis.rootNode = rootNode;\n\n\t\t// initial state of these methods that calls 'bind'\n\t\tthis.getValue = this._getValue_unbound;\n\t\tthis.setValue = this._setValue_unbound;\n\n\t}\n\n\n\tstatic create( root, path, parsedPath ) {\n\n\t\tif ( ! ( root && root.isAnimationObjectGroup ) ) {\n\n\t\t\treturn new PropertyBinding( root, path, parsedPath );\n\n\t\t} else {\n\n\t\t\treturn new PropertyBinding.Composite( root, path, parsedPath );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Replaces spaces with underscores and removes unsupported characters from\n\t * node names, to ensure compatibility with parseTrackName().\n\t *\n\t * @param {string} name Node name to be sanitized.\n\t * @return {string}\n\t */\n\tstatic sanitizeNodeName( name ) {\n\n\t\treturn name.replace( /\\s/g, '_' ).replace( _reservedRe, '' );\n\n\t}\n\n\tstatic parseTrackName( trackName ) {\n\n\t\tconst matches = _trackRe.exec( trackName );\n\n\t\tif ( matches === null ) {\n\n\t\t\tthrow new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );\n\n\t\t}\n\n\t\tconst results = {\n\t\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\n\t\t\tnodeName: matches[ 2 ],\n\t\t\tobjectName: matches[ 3 ],\n\t\t\tobjectIndex: matches[ 4 ],\n\t\t\tpropertyName: matches[ 5 ], // required\n\t\t\tpropertyIndex: matches[ 6 ]\n\t\t};\n\n\t\tconst lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );\n\n\t\tif ( lastDot !== undefined && lastDot !== - 1 ) {\n\n\t\t\tconst objectName = results.nodeName.substring( lastDot + 1 );\n\n\t\t\t// Object names must be checked against an allowlist. Otherwise, there\n\t\t\t// is no way to parse 'foo.bar.baz': 'baz' must be a property, but\n\t\t\t// 'bar' could be the objectName, or part of a nodeName (which can\n\t\t\t// include '.' characters).\n\t\t\tif ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {\n\n\t\t\t\tresults.nodeName = results.nodeName.substring( 0, lastDot );\n\t\t\t\tresults.objectName = objectName;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\n\n\t\t\tthrow new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );\n\n\t\t}\n\n\t\treturn results;\n\n\t}\n\n\tstatic findNode( root, nodeName ) {\n\n\t\tif ( nodeName === undefined || nodeName === '' || nodeName === '.' || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {\n\n\t\t\treturn root;\n\n\t\t}\n\n\t\t// search into skeleton bones.\n\t\tif ( root.skeleton ) {\n\n\t\t\tconst bone = root.skeleton.getBoneByName( nodeName );\n\n\t\t\tif ( bone !== undefined ) {\n\n\t\t\t\treturn bone;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// search into node subtree.\n\t\tif ( root.children ) {\n\n\t\t\tconst searchNodeSubtree = function ( children ) {\n\n\t\t\t\tfor ( let i = 0; i < children.length; i ++ ) {\n\n\t\t\t\t\tconst childNode = children[ i ];\n\n\t\t\t\t\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\n\n\t\t\t\t\t\treturn childNode;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = searchNodeSubtree( childNode.children );\n\n\t\t\t\t\tif ( result ) return result;\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t};\n\n\t\t\tconst subTreeNode = searchNodeSubtree( root.children );\n\n\t\t\tif ( subTreeNode ) {\n\n\t\t\t\treturn subTreeNode;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t// these are used to \"bind\" a nonexistent property\n\t_getValue_unavailable() {}\n\t_setValue_unavailable() {}\n\n\t// Getters\n\n\t_getValue_direct( buffer, offset ) {\n\n\t\tbuffer[ offset ] = this.targetObject[ this.propertyName ];\n\n\t}\n\n\t_getValue_array( buffer, offset ) {\n\n\t\tconst source = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = source.length; i !== n; ++ i ) {\n\n\t\t\tbuffer[ offset ++ ] = source[ i ];\n\n\t\t}\n\n\t}\n\n\t_getValue_arrayElement( buffer, offset ) {\n\n\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\n\n\t}\n\n\t_getValue_toArray( buffer, offset ) {\n\n\t\tthis.resolvedProperty.toArray( buffer, offset );\n\n\t}\n\n\t// Direct\n\n\t_setValue_direct( buffer, offset ) {\n\n\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\n\t}\n\n\t_setValue_direct_setNeedsUpdate( buffer, offset ) {\n\n\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t// EntireArray\n\n\t_setValue_array( buffer, offset ) {\n\n\t\tconst dest = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t}\n\n\t}\n\n\t_setValue_array_setNeedsUpdate( buffer, offset ) {\n\n\t\tconst dest = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t}\n\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tconst dest = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t}\n\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t// ArrayElement\n\n\t_setValue_arrayElement( buffer, offset ) {\n\n\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\n\t}\n\n\t_setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t// HasToFromArray\n\n\t_setValue_fromArray( buffer, offset ) {\n\n\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\n\t}\n\n\t_setValue_fromArray_setNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t_getValue_unbound( targetArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.getValue( targetArray, offset );\n\n\t}\n\n\t_setValue_unbound( sourceArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.setValue( sourceArray, offset );\n\n\t}\n\n\t// create getter / setter pair for a property in the scene graph\n\tbind() {\n\n\t\tlet targetObject = this.node;\n\t\tconst parsedPath = this.parsedPath;\n\n\t\tconst objectName = parsedPath.objectName;\n\t\tconst propertyName = parsedPath.propertyName;\n\t\tlet propertyIndex = parsedPath.propertyIndex;\n\n\t\tif ( ! targetObject ) {\n\n\t\t\ttargetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName );\n\n\t\t\tthis.node = targetObject;\n\n\t\t}\n\n\t\t// set fail state so we can just 'return' on error\n\t\tthis.getValue = this._getValue_unavailable;\n\t\tthis.setValue = this._setValue_unavailable;\n\n\t\t// ensure there is a value node\n\t\tif ( ! targetObject ) {\n\n\t\t\tconsole.warn( 'THREE.PropertyBinding: No target node found for track: ' + this.path + '.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( objectName ) {\n\n\t\t\tlet objectIndex = parsedPath.objectIndex;\n\n\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\n\t\t\tswitch ( objectName ) {\n\n\t\t\t\tcase 'materials':\n\n\t\t\t\t\tif ( ! targetObject.material ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material.materials ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject.material.materials;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bones':\n\n\t\t\t\t\tif ( ! targetObject.skeleton ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\n\t\t\t\t\t// and convert the integer string to a true integer.\n\n\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\n\n\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\tfor ( let i = 0; i < targetObject.length; i ++ ) {\n\n\t\t\t\t\t\tif ( targetObject[ i ].name === objectIndex ) {\n\n\t\t\t\t\t\t\tobjectIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map':\n\n\t\t\t\t\tif ( 'map' in targetObject ) {\n\n\t\t\t\t\t\ttargetObject = targetObject.map;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material.map ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject.material.map;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject[ objectName ];\n\n\t\t\t}\n\n\n\t\t\tif ( objectIndex !== undefined ) {\n\n\t\t\t\tif ( targetObject[ objectIndex ] === undefined ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\ttargetObject = targetObject[ objectIndex ];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// resolve property\n\t\tconst nodeProperty = targetObject[ propertyName ];\n\n\t\tif ( nodeProperty === undefined ) {\n\n\t\t\tconst nodeName = parsedPath.nodeName;\n\n\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +\n\t\t\t\t'.' + propertyName + ' but it wasn\\'t found.', targetObject );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// determine versioning scheme\n\t\tlet versioning = this.Versioning.None;\n\n\t\tthis.targetObject = targetObject;\n\n\t\tif ( targetObject.needsUpdate !== undefined ) { // material\n\n\t\t\tversioning = this.Versioning.NeedsUpdate;\n\n\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\n\n\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\n\n\t\t}\n\n\t\t// determine how the property gets bound\n\t\tlet bindingType = this.BindingType.Direct;\n\n\t\tif ( propertyIndex !== undefined ) {\n\n\t\t\t// access a sub element of the property array (only primitives are supported right now)\n\n\t\t\tif ( propertyName === 'morphTargetInfluences' ) {\n\n\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\n\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\tif ( ! targetObject.geometry ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! targetObject.geometry.morphAttributes ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {\n\n\t\t\t\t\tpropertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbindingType = this.BindingType.ArrayElement;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\tthis.propertyIndex = propertyIndex;\n\n\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\n\n\t\t\t// must use copy for Object3D.Euler/Quaternion\n\n\t\t\tbindingType = this.BindingType.HasFromToArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else if ( Array.isArray( nodeProperty ) ) {\n\n\t\t\tbindingType = this.BindingType.EntireArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else {\n\n\t\t\tthis.propertyName = propertyName;\n\n\t\t}\n\n\t\t// select getter / setter\n\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\n\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\n\n\t}\n\n\tunbind() {\n\n\t\tthis.node = null;\n\n\t\t// back to the prototype version of getValue / setValue\n\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\n\t\tthis.getValue = this._getValue_unbound;\n\t\tthis.setValue = this._setValue_unbound;\n\n\t}\n\n}\n\nPropertyBinding.Composite = Composite;\n\nPropertyBinding.prototype.BindingType = {\n\tDirect: 0,\n\tEntireArray: 1,\n\tArrayElement: 2,\n\tHasFromToArray: 3\n};\n\nPropertyBinding.prototype.Versioning = {\n\tNone: 0,\n\tNeedsUpdate: 1,\n\tMatrixWorldNeedsUpdate: 2\n};\n\nPropertyBinding.prototype.GetterByBindingType = [\n\n\tPropertyBinding.prototype._getValue_direct,\n\tPropertyBinding.prototype._getValue_array,\n\tPropertyBinding.prototype._getValue_arrayElement,\n\tPropertyBinding.prototype._getValue_toArray,\n\n];\n\nPropertyBinding.prototype.SetterByBindingTypeAndVersioning = [\n\n\t[\n\t\t// Direct\n\t\tPropertyBinding.prototype._setValue_direct,\n\t\tPropertyBinding.prototype._setValue_direct_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate,\n\n\t], [\n\n\t\t// EntireArray\n\n\t\tPropertyBinding.prototype._setValue_array,\n\t\tPropertyBinding.prototype._setValue_array_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,\n\n\t], [\n\n\t\t// ArrayElement\n\t\tPropertyBinding.prototype._setValue_arrayElement,\n\t\tPropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,\n\n\t], [\n\n\t\t// HasToFromArray\n\t\tPropertyBinding.prototype._setValue_fromArray,\n\t\tPropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,\n\n\t]\n\n];\n\n/**\n *\n * A group of objects that receives a shared animation state.\n *\n * Usage:\n *\n *  - Add objects you would otherwise pass as 'root' to the\n *    constructor or the .clipAction method of AnimationMixer.\n *\n *  - Instead pass this object as 'root'.\n *\n *  - You can also add and remove objects later when the mixer\n *    is running.\n *\n * Note:\n *\n *    Objects of this class appear as one object to the mixer,\n *    so cache control of the individual objects must be done\n *    on the group.\n *\n * Limitation:\n *\n *  - The animated properties must be compatible among the\n *    all objects in the group.\n *\n *  - A single property can either be controlled through a\n *    target group or directly, but not both.\n */\n\nclass AnimationObjectGroup {\n\n\tconstructor() {\n\n\t\tthis.isAnimationObjectGroup = true;\n\n\t\tthis.uuid = generateUUID();\n\n\t\t// cached objects followed by the active ones\n\t\tthis._objects = Array.prototype.slice.call( arguments );\n\n\t\tthis.nCachedObjects_ = 0; // threshold\n\t\t// note: read by PropertyBinding.Composite\n\n\t\tconst indices = {};\n\t\tthis._indicesByUUID = indices; // for bookkeeping\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tindices[ arguments[ i ].uuid ] = i;\n\n\t\t}\n\n\t\tthis._paths = []; // inside: string\n\t\tthis._parsedPaths = []; // inside: { we don't care, here }\n\t\tthis._bindings = []; // inside: Array< PropertyBinding >\n\t\tthis._bindingsIndicesByPath = {}; // inside: indices in these arrays\n\n\t\tconst scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tobjects: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._objects.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn this.total - scope.nCachedObjects_;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tget bindingsPerObject() {\n\n\t\t\t\treturn scope._bindings.length;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tadd() {\n\n\t\tconst objects = this._objects,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tpaths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tlet knownObject = undefined,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_;\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tconst object = arguments[ i ],\n\t\t\t\tuuid = object.uuid;\n\t\t\tlet index = indicesByUUID[ uuid ];\n\n\t\t\tif ( index === undefined ) {\n\n\t\t\t\t// unknown object -> add it to the ACTIVE region\n\n\t\t\t\tindex = nObjects ++;\n\t\t\t\tindicesByUUID[ uuid ] = index;\n\t\t\t\tobjects.push( object );\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tbindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );\n\n\t\t\t\t}\n\n\t\t\t} else if ( index < nCachedObjects ) {\n\n\t\t\t\tknownObject = objects[ index ];\n\n\t\t\t\t// move existing object to the ACTIVE region\n\n\t\t\t\tconst firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\n\n\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\n\t\t\t\tobjects[ firstActiveIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tconst bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ];\n\n\t\t\t\t\tlet binding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\n\t\t\t\t\tif ( binding === undefined ) {\n\n\t\t\t\t\t\t// since we do not bother to create new bindings\n\t\t\t\t\t\t// for objects that are cached, the binding may\n\t\t\t\t\t\t// or may not exist\n\n\t\t\t\t\t\tbinding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t} else if ( objects[ index ] !== knownObject ) {\n\n\t\t\t\tconsole.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +\n\t\t\t\t\t'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );\n\n\t\t\t} // else the object is already where we want it to be\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t}\n\n\tremove() {\n\n\t\tconst objects = this._objects,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tlet nCachedObjects = this.nCachedObjects_;\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tconst object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\n\n\t\t\t\t// move existing object into the CACHED region\n\n\t\t\t\tconst lastCachedIndex = nCachedObjects ++,\n\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\n\n\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = firstActiveObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\n\t\t\t\tobjects[ lastCachedIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tconst bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = firstActive;\n\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t}\n\n\t// remove & forget\n\tuncache() {\n\n\t\tconst objects = this._objects,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tlet nCachedObjects = this.nCachedObjects_,\n\t\t\tnObjects = objects.length;\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tconst object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tdelete indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index < nCachedObjects ) {\n\n\t\t\t\t\t// object is cached, shrink the CACHED region\n\n\t\t\t\t\tconst firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\n\t\t\t\t\t\tlastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\t// last cached object takes this object's place\n\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\t\t// last object goes to the activated slot and pop\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\n\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tconst bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// object is active, just swap with the last and pop\n\n\t\t\t\t\tconst lastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\tif ( lastIndex > 0 ) {\n\n\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobjects[ index ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tconst bindingsForPath = bindings[ j ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} // cached or active\n\n\t\t\t} // if object is known\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t}\n\n\t// Internal interface used by befriended PropertyBinding.Composite:\n\n\tsubscribe_( path, parsedPath ) {\n\n\t\t// returns an array of bindings for the given path that is changed\n\t\t// according to the contained objects in the group\n\n\t\tconst indicesByPath = this._bindingsIndicesByPath;\n\t\tlet index = indicesByPath[ path ];\n\t\tconst bindings = this._bindings;\n\n\t\tif ( index !== undefined ) return bindings[ index ];\n\n\t\tconst paths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tobjects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tbindingsForPath = new Array( nObjects );\n\n\t\tindex = bindings.length;\n\n\t\tindicesByPath[ path ] = index;\n\n\t\tpaths.push( path );\n\t\tparsedPaths.push( parsedPath );\n\t\tbindings.push( bindingsForPath );\n\n\t\tfor ( let i = nCachedObjects, n = objects.length; i !== n; ++ i ) {\n\n\t\t\tconst object = objects[ i ];\n\t\t\tbindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );\n\n\t\t}\n\n\t\treturn bindingsForPath;\n\n\t}\n\n\tunsubscribe_( path ) {\n\n\t\t// tells the group to forget about a property path and no longer\n\t\t// update the array previously obtained with 'subscribe_'\n\n\t\tconst indicesByPath = this._bindingsIndicesByPath,\n\t\t\tindex = indicesByPath[ path ];\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tconst paths = this._paths,\n\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tlastBindingsIndex = bindings.length - 1,\n\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\n\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\n\n\t\t\tindicesByPath[ lastBindingsPath ] = index;\n\n\t\t\tbindings[ index ] = lastBindings;\n\t\t\tbindings.pop();\n\n\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\n\t\t\tparsedPaths.pop();\n\n\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\n\t\t\tpaths.pop();\n\n\t\t}\n\n\t}\n\n}\n\nclass AnimationAction {\n\n\tconstructor( mixer, clip, localRoot = null, blendMode = clip.blendMode ) {\n\n\t\tthis._mixer = mixer;\n\t\tthis._clip = clip;\n\t\tthis._localRoot = localRoot;\n\t\tthis.blendMode = blendMode;\n\n\t\tconst tracks = clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tinterpolants = new Array( nTracks );\n\n\t\tconst interpolantSettings = {\n\t\t\tendingStart: ZeroCurvatureEnding,\n\t\t\tendingEnd: ZeroCurvatureEnding\n\t\t};\n\n\t\tfor ( let i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tconst interpolant = tracks[ i ].createInterpolant( null );\n\t\t\tinterpolants[ i ] = interpolant;\n\t\t\tinterpolant.settings = interpolantSettings;\n\n\t\t}\n\n\t\tthis._interpolantSettings = interpolantSettings;\n\n\t\tthis._interpolants = interpolants; // bound by the mixer\n\n\t\t// inside: PropertyMixer (managed by the mixer)\n\t\tthis._propertyBindings = new Array( nTracks );\n\n\t\tthis._cacheIndex = null; // for the memory manager\n\t\tthis._byClipCacheIndex = null; // for the memory manager\n\n\t\tthis._timeScaleInterpolant = null;\n\t\tthis._weightInterpolant = null;\n\n\t\tthis.loop = LoopRepeat;\n\t\tthis._loopCount = - 1;\n\n\t\t// global mixer time when the action is to be started\n\t\t// it's set back to 'null' upon start of the action\n\t\tthis._startTime = null;\n\n\t\t// scaled local time of the action\n\t\t// gets clamped or wrapped to 0..clip.duration according to loop\n\t\tthis.time = 0;\n\n\t\tthis.timeScale = 1;\n\t\tthis._effectiveTimeScale = 1;\n\n\t\tthis.weight = 1;\n\t\tthis._effectiveWeight = 1;\n\n\t\tthis.repetitions = Infinity; // no. of repetitions when looping\n\n\t\tthis.paused = false; // true -> zero effective time scale\n\t\tthis.enabled = true; // false -> zero effective weight\n\n\t\tthis.clampWhenFinished = false;// keep feeding the last frame?\n\n\t\tthis.zeroSlopeAtStart = true;// for smooth interpolation w/o separate\n\t\tthis.zeroSlopeAtEnd = true;// clips for start, loop and end\n\n\t}\n\n\t// State & Scheduling\n\n\tplay() {\n\n\t\tthis._mixer._activateAction( this );\n\n\t\treturn this;\n\n\t}\n\n\tstop() {\n\n\t\tthis._mixer._deactivateAction( this );\n\n\t\treturn this.reset();\n\n\t}\n\n\treset() {\n\n\t\tthis.paused = false;\n\t\tthis.enabled = true;\n\n\t\tthis.time = 0; // restart clip\n\t\tthis._loopCount = - 1;// forget previous loops\n\t\tthis._startTime = null;// forget scheduling\n\n\t\treturn this.stopFading().stopWarping();\n\n\t}\n\n\tisRunning() {\n\n\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\n\t\t\tthis._startTime === null && this._mixer._isActiveAction( this );\n\n\t}\n\n\t// return true when play has been called\n\tisScheduled() {\n\n\t\treturn this._mixer._isActiveAction( this );\n\n\t}\n\n\tstartAt( time ) {\n\n\t\tthis._startTime = time;\n\n\t\treturn this;\n\n\t}\n\n\tsetLoop( mode, repetitions ) {\n\n\t\tthis.loop = mode;\n\t\tthis.repetitions = repetitions;\n\n\t\treturn this;\n\n\t}\n\n\t// Weight\n\n\t// set the weight stopping any scheduled fading\n\t// although .enabled = false yields an effective weight of zero, this\n\t// method does *not* change .enabled, because it would be confusing\n\tsetEffectiveWeight( weight ) {\n\n\t\tthis.weight = weight;\n\n\t\t// note: same logic as when updated at runtime\n\t\tthis._effectiveWeight = this.enabled ? weight : 0;\n\n\t\treturn this.stopFading();\n\n\t}\n\n\t// return the weight considering fading and .enabled\n\tgetEffectiveWeight() {\n\n\t\treturn this._effectiveWeight;\n\n\t}\n\n\tfadeIn( duration ) {\n\n\t\treturn this._scheduleFading( duration, 0, 1 );\n\n\t}\n\n\tfadeOut( duration ) {\n\n\t\treturn this._scheduleFading( duration, 1, 0 );\n\n\t}\n\n\tcrossFadeFrom( fadeOutAction, duration, warp ) {\n\n\t\tfadeOutAction.fadeOut( duration );\n\t\tthis.fadeIn( duration );\n\n\t\tif ( warp ) {\n\n\t\t\tconst fadeInDuration = this._clip.duration,\n\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\n\n\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\n\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\n\n\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\n\t\t\tthis.warp( endStartRatio, 1.0, duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tcrossFadeTo( fadeInAction, duration, warp ) {\n\n\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\n\n\t}\n\n\tstopFading() {\n\n\t\tconst weightInterpolant = this._weightInterpolant;\n\n\t\tif ( weightInterpolant !== null ) {\n\n\t\t\tthis._weightInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Time Scale Control\n\n\t// set the time scale stopping any scheduled warping\n\t// although .paused = true yields an effective time scale of zero, this\n\t// method does *not* change .paused, because it would be confusing\n\tsetEffectiveTimeScale( timeScale ) {\n\n\t\tthis.timeScale = timeScale;\n\t\tthis._effectiveTimeScale = this.paused ? 0 : timeScale;\n\n\t\treturn this.stopWarping();\n\n\t}\n\n\t// return the time scale considering warping and .paused\n\tgetEffectiveTimeScale() {\n\n\t\treturn this._effectiveTimeScale;\n\n\t}\n\n\tsetDuration( duration ) {\n\n\t\tthis.timeScale = this._clip.duration / duration;\n\n\t\treturn this.stopWarping();\n\n\t}\n\n\tsyncWith( action ) {\n\n\t\tthis.time = action.time;\n\t\tthis.timeScale = action.timeScale;\n\n\t\treturn this.stopWarping();\n\n\t}\n\n\thalt( duration ) {\n\n\t\treturn this.warp( this._effectiveTimeScale, 0, duration );\n\n\t}\n\n\twarp( startTimeScale, endTimeScale, duration ) {\n\n\t\tconst mixer = this._mixer,\n\t\t\tnow = mixer.time,\n\t\t\ttimeScale = this.timeScale;\n\n\t\tlet interpolant = this._timeScaleInterpolant;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\tthis._timeScaleInterpolant = interpolant;\n\n\t\t}\n\n\t\tconst times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now;\n\t\ttimes[ 1 ] = now + duration;\n\n\t\tvalues[ 0 ] = startTimeScale / timeScale;\n\t\tvalues[ 1 ] = endTimeScale / timeScale;\n\n\t\treturn this;\n\n\t}\n\n\tstopWarping() {\n\n\t\tconst timeScaleInterpolant = this._timeScaleInterpolant;\n\n\t\tif ( timeScaleInterpolant !== null ) {\n\n\t\t\tthis._timeScaleInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Object Accessors\n\n\tgetMixer() {\n\n\t\treturn this._mixer;\n\n\t}\n\n\tgetClip() {\n\n\t\treturn this._clip;\n\n\t}\n\n\tgetRoot() {\n\n\t\treturn this._localRoot || this._mixer._root;\n\n\t}\n\n\t// Interna\n\n\t_update( time, deltaTime, timeDirection, accuIndex ) {\n\n\t\t// called by the mixer\n\n\t\tif ( ! this.enabled ) {\n\n\t\t\t// call ._updateWeight() to update ._effectiveWeight\n\n\t\t\tthis._updateWeight( time );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst startTime = this._startTime;\n\n\t\tif ( startTime !== null ) {\n\n\t\t\t// check for scheduled start of action\n\n\t\t\tconst timeRunning = ( time - startTime ) * timeDirection;\n\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\n\n\t\t\t\tdeltaTime = 0;\n\n\t\t\t} else {\n\n\n\t\t\t\tthis._startTime = null; // unschedule\n\t\t\t\tdeltaTime = timeDirection * timeRunning;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// apply time scale and advance time\n\n\t\tdeltaTime *= this._updateTimeScale( time );\n\t\tconst clipTime = this._updateTime( deltaTime );\n\n\t\t// note: _updateTime may disable the action resulting in\n\t\t// an effective weight of 0\n\n\t\tconst weight = this._updateWeight( time );\n\n\t\tif ( weight > 0 ) {\n\n\t\t\tconst interpolants = this._interpolants;\n\t\t\tconst propertyMixers = this._propertyBindings;\n\n\t\t\tswitch ( this.blendMode ) {\n\n\t\t\t\tcase AdditiveAnimationBlendMode:\n\n\t\t\t\t\tfor ( let j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\t\t\tpropertyMixers[ j ].accumulateAdditive( weight );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NormalAnimationBlendMode:\n\t\t\t\tdefault:\n\n\t\t\t\t\tfor ( let j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\n\n\t\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_updateWeight( time ) {\n\n\t\tlet weight = 0;\n\n\t\tif ( this.enabled ) {\n\n\t\t\tweight = this.weight;\n\t\t\tconst interpolant = this._weightInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tconst interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\tweight *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopFading();\n\n\t\t\t\t\tif ( interpolantValue === 0 ) {\n\n\t\t\t\t\t\t// faded out, disable\n\t\t\t\t\t\tthis.enabled = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveWeight = weight;\n\t\treturn weight;\n\n\t}\n\n\t_updateTimeScale( time ) {\n\n\t\tlet timeScale = 0;\n\n\t\tif ( ! this.paused ) {\n\n\t\t\ttimeScale = this.timeScale;\n\n\t\t\tconst interpolant = this._timeScaleInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tconst interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\ttimeScale *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopWarping();\n\n\t\t\t\t\tif ( timeScale === 0 ) {\n\n\t\t\t\t\t\t// motion has halted, pause\n\t\t\t\t\t\tthis.paused = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// warp done - apply final time scale\n\t\t\t\t\t\tthis.timeScale = timeScale;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveTimeScale = timeScale;\n\t\treturn timeScale;\n\n\t}\n\n\t_updateTime( deltaTime ) {\n\n\t\tconst duration = this._clip.duration;\n\t\tconst loop = this.loop;\n\n\t\tlet time = this.time + deltaTime;\n\t\tlet loopCount = this._loopCount;\n\n\t\tconst pingPong = ( loop === LoopPingPong );\n\n\t\tif ( deltaTime === 0 ) {\n\n\t\t\tif ( loopCount === - 1 ) return time;\n\n\t\t\treturn ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;\n\n\t\t}\n\n\t\tif ( loop === LoopOnce ) {\n\n\t\t\tif ( loopCount === - 1 ) {\n\n\t\t\t\t// just started\n\n\t\t\t\tthis._loopCount = 0;\n\t\t\t\tthis._setEndings( true, true, false );\n\n\t\t\t}\n\n\t\t\thandle_stop: {\n\n\t\t\t\tif ( time >= duration ) {\n\n\t\t\t\t\ttime = duration;\n\n\t\t\t\t} else if ( time < 0 ) {\n\n\t\t\t\t\ttime = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tbreak handle_stop;\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\telse this.enabled = false;\n\n\t\t\t\tthis.time = time;\n\n\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\tdirection: deltaTime < 0 ? - 1 : 1\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} else { // repetitive Repeat or PingPong\n\n\t\t\tif ( loopCount === - 1 ) {\n\n\t\t\t\t// just started\n\n\t\t\t\tif ( deltaTime >= 0 ) {\n\n\t\t\t\t\tloopCount = 0;\n\n\t\t\t\t\tthis._setEndings( true, this.repetitions === 0, pingPong );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// when looping in reverse direction, the initial\n\t\t\t\t\t// transition through zero counts as a repetition,\n\t\t\t\t\t// so leave loopCount at -1\n\n\t\t\t\t\tthis._setEndings( this.repetitions === 0, true, pingPong );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( time >= duration || time < 0 ) {\n\n\t\t\t\t// wrap around\n\n\t\t\t\tconst loopDelta = Math.floor( time / duration ); // signed\n\t\t\t\ttime -= duration * loopDelta;\n\n\t\t\t\tloopCount += Math.abs( loopDelta );\n\n\t\t\t\tconst pending = this.repetitions - loopCount;\n\n\t\t\t\tif ( pending <= 0 ) {\n\n\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\n\n\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\telse this.enabled = false;\n\n\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : - 1\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// keep running\n\n\t\t\t\t\tif ( pending === 1 ) {\n\n\t\t\t\t\t\t// entering the last round\n\n\t\t\t\t\t\tconst atStart = deltaTime < 0;\n\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._loopCount = loopCount;\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis.time = time;\n\n\t\t\t}\n\n\t\t\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\n\n\t\t\t\t// invert time for the \"pong round\"\n\n\t\t\t\treturn duration - time;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn time;\n\n\t}\n\n\t_setEndings( atStart, atEnd, pingPong ) {\n\n\t\tconst settings = this._interpolantSettings;\n\n\t\tif ( pingPong ) {\n\n\t\t\tsettings.endingStart = ZeroSlopeEnding;\n\t\t\tsettings.endingEnd = ZeroSlopeEnding;\n\n\t\t} else {\n\n\t\t\t// assuming for LoopOnce atStart == atEnd == true\n\n\t\t\tif ( atStart ) {\n\n\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingStart = WrapAroundEnding;\n\n\t\t\t}\n\n\t\t\tif ( atEnd ) {\n\n\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingEnd \t = WrapAroundEnding;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_scheduleFading( duration, weightNow, weightThen ) {\n\n\t\tconst mixer = this._mixer, now = mixer.time;\n\t\tlet interpolant = this._weightInterpolant;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\tthis._weightInterpolant = interpolant;\n\n\t\t}\n\n\t\tconst times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now;\n\t\tvalues[ 0 ] = weightNow;\n\t\ttimes[ 1 ] = now + duration;\n\t\tvalues[ 1 ] = weightThen;\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _controlInterpolantsResultBuffer = new Float32Array( 1 );\n\n\nclass AnimationMixer extends EventDispatcher {\n\n\tconstructor( root ) {\n\n\t\tsuper();\n\n\t\tthis._root = root;\n\t\tthis._initMemoryManager();\n\t\tthis._accuIndex = 0;\n\t\tthis.time = 0;\n\t\tthis.timeScale = 1.0;\n\n\t}\n\n\t_bindAction( action, prototypeAction ) {\n\n\t\tconst root = action._localRoot || this._root,\n\t\t\ttracks = action._clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tbindings = action._propertyBindings,\n\t\t\tinterpolants = action._interpolants,\n\t\t\trootUuid = root.uuid,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName;\n\n\t\tlet bindingsByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingsByName === undefined ) {\n\n\t\t\tbindingsByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\n\n\t\t}\n\n\t\tfor ( let i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tconst track = tracks[ i ],\n\t\t\t\ttrackName = track.name;\n\n\t\t\tlet binding = bindingsByName[ trackName ];\n\n\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t++ binding.referenceCount;\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t} else {\n\n\t\t\t\tbinding = bindings[ i ];\n\n\t\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t\t// existing binding, make sure the cache knows\n\n\t\t\t\t\tif ( binding._cacheIndex === null ) {\n\n\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tconst path = prototypeAction && prototypeAction.\n\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\n\n\t\t\t\tbinding = new PropertyMixer(\n\t\t\t\t\tPropertyBinding.create( root, trackName, path ),\n\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\n\n\t\t\t\t++ binding.referenceCount;\n\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t}\n\n\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\n\n\t\t}\n\n\t}\n\n\t_activateAction( action ) {\n\n\t\tif ( ! this._isActiveAction( action ) ) {\n\n\t\t\tif ( action._cacheIndex === null ) {\n\n\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t// appears to be still using it -> rebind\n\n\t\t\t\tconst rootUuid = ( action._localRoot || this._root ).uuid,\n\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\t\t\tthis._bindAction( action,\n\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\n\n\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\n\n\t\t\t}\n\n\t\t\tconst bindings = action._propertyBindings;\n\n\t\t\t// increment reference counts / sort out state\n\t\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tconst binding = bindings[ i ];\n\n\t\t\t\tif ( binding.useCount ++ === 0 ) {\n\n\t\t\t\t\tthis._lendBinding( binding );\n\t\t\t\t\tbinding.saveOriginalState();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._lendAction( action );\n\n\t\t}\n\n\t}\n\n\t_deactivateAction( action ) {\n\n\t\tif ( this._isActiveAction( action ) ) {\n\n\t\t\tconst bindings = action._propertyBindings;\n\n\t\t\t// decrement reference counts / sort out state\n\t\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tconst binding = bindings[ i ];\n\n\t\t\t\tif ( -- binding.useCount === 0 ) {\n\n\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\tthis._takeBackBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._takeBackAction( action );\n\n\t\t}\n\n\t}\n\n\t// Memory manager\n\n\t_initMemoryManager() {\n\n\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\t\tthis._nActiveActions = 0;\n\n\t\tthis._actionsByClip = {};\n\t\t// inside:\n\t\t// {\n\t\t// \tknownActions: Array< AnimationAction > - used as prototypes\n\t\t// \tactionByRoot: AnimationAction - lookup\n\t\t// }\n\n\n\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\t\tthis._nActiveBindings = 0;\n\n\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n\n\t\tthis._controlInterpolants = []; // same game as above\n\t\tthis._nActiveControlInterpolants = 0;\n\n\t\tconst scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tactions: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._actions.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveActions;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tbindings: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._bindings.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveBindings;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tcontrolInterpolants: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._controlInterpolants.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveControlInterpolants;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t// Memory management for AnimationAction objects\n\n\t_isActiveAction( action ) {\n\n\t\tconst index = action._cacheIndex;\n\t\treturn index !== null && index < this._nActiveActions;\n\n\t}\n\n\t_addInactiveAction( action, clipUuid, rootUuid ) {\n\n\t\tconst actions = this._actions,\n\t\t\tactionsByClip = this._actionsByClip;\n\n\t\tlet actionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip === undefined ) {\n\n\t\t\tactionsForClip = {\n\n\t\t\t\tknownActions: [ action ],\n\t\t\t\tactionByRoot: {}\n\n\t\t\t};\n\n\t\t\taction._byClipCacheIndex = 0;\n\n\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\n\n\t\t} else {\n\n\t\t\tconst knownActions = actionsForClip.knownActions;\n\n\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\tknownActions.push( action );\n\n\t\t}\n\n\t\taction._cacheIndex = actions.length;\n\t\tactions.push( action );\n\n\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\n\n\t}\n\n\t_removeInactiveAction( action ) {\n\n\t\tconst actions = this._actions,\n\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\n\t\t\tcacheIndex = action._cacheIndex;\n\n\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\tactions.pop();\n\n\t\taction._cacheIndex = null;\n\n\n\t\tconst clipUuid = action._clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ],\n\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\n\t\t\tlastKnownAction =\n\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\n\n\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\n\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\n\t\tknownActionsForClip.pop();\n\n\t\taction._byClipCacheIndex = null;\n\n\n\t\tconst actionByRoot = actionsForClip.actionByRoot,\n\t\t\trootUuid = ( action._localRoot || this._root ).uuid;\n\n\t\tdelete actionByRoot[ rootUuid ];\n\n\t\tif ( knownActionsForClip.length === 0 ) {\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t\tthis._removeInactiveBindingsForAction( action );\n\n\t}\n\n\t_removeInactiveBindingsForAction( action ) {\n\n\t\tconst bindings = action._propertyBindings;\n\n\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tconst binding = bindings[ i ];\n\n\t\t\tif ( -- binding.referenceCount === 0 ) {\n\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_lendAction( action ) {\n\n\t\t// [ active actions |  inactive actions  ]\n\t\t// [  active actions >| inactive actions ]\n\t\t//                 s        a\n\t\t//                  <-swap->\n\t\t//                 a        s\n\n\t\tconst actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveActions ++,\n\n\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\n\n\t\taction._cacheIndex = lastActiveIndex;\n\t\tactions[ lastActiveIndex ] = action;\n\n\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = firstInactiveAction;\n\n\t}\n\n\t_takeBackAction( action ) {\n\n\t\t// [  active actions  | inactive actions ]\n\t\t// [ active actions |< inactive actions  ]\n\t\t//        a        s\n\t\t//         <-swap->\n\t\t//        s        a\n\n\t\tconst actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveActions,\n\n\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\n\n\t\taction._cacheIndex = firstInactiveIndex;\n\t\tactions[ firstInactiveIndex ] = action;\n\n\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = lastActiveAction;\n\n\t}\n\n\t// Memory management for PropertyMixer objects\n\n\t_addInactiveBinding( binding, rootUuid, trackName ) {\n\n\t\tconst bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindings = this._bindings;\n\n\t\tlet bindingByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingByName === undefined ) {\n\n\t\t\tbindingByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\n\n\t\t}\n\n\t\tbindingByName[ trackName ] = binding;\n\n\t\tbinding._cacheIndex = bindings.length;\n\t\tbindings.push( binding );\n\n\t}\n\n\t_removeInactiveBinding( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tpropBinding = binding.binding,\n\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\ttrackName = propBinding.path,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\n\t\t\tcacheIndex = binding._cacheIndex;\n\n\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\tbindings[ cacheIndex ] = lastInactiveBinding;\n\t\tbindings.pop();\n\n\t\tdelete bindingByName[ trackName ];\n\n\t\tif ( Object.keys( bindingByName ).length === 0 ) {\n\n\t\t\tdelete bindingsByRoot[ rootUuid ];\n\n\t\t}\n\n\t}\n\n\t_lendBinding( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveBindings ++,\n\n\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\n\n\t\tbinding._cacheIndex = lastActiveIndex;\n\t\tbindings[ lastActiveIndex ] = binding;\n\n\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = firstInactiveBinding;\n\n\t}\n\n\t_takeBackBinding( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\n\n\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\n\n\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\tbindings[ firstInactiveIndex ] = binding;\n\n\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = lastActiveBinding;\n\n\t}\n\n\n\t// Memory management of Interpolants for weight and time scale\n\n\t_lendControlInterpolant() {\n\n\t\tconst interpolants = this._controlInterpolants,\n\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++;\n\n\t\tlet interpolant = interpolants[ lastActiveIndex ];\n\n\t\tif ( interpolant === undefined ) {\n\n\t\t\tinterpolant = new LinearInterpolant(\n\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\n\t\t\t\t1, _controlInterpolantsResultBuffer );\n\n\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\n\n\t\t}\n\n\t\treturn interpolant;\n\n\t}\n\n\t_takeBackControlInterpolant( interpolant ) {\n\n\t\tconst interpolants = this._controlInterpolants,\n\t\t\tprevIndex = interpolant.__cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\n\n\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\n\n\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\tinterpolants[ firstInactiveIndex ] = interpolant;\n\n\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\n\n\t}\n\n\t// return an action for a clip optionally using a custom root target\n\t// object (this method allocates a lot of dynamic memory in case a\n\t// previously unknown clip/root combination is specified)\n\tclipAction( clip, optionalRoot, blendMode ) {\n\n\t\tconst root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid;\n\n\t\tlet clipObject = typeof clip === 'string' ? AnimationClip.findByName( root, clip ) : clip;\n\n\t\tconst clipUuid = clipObject !== null ? clipObject.uuid : clip;\n\n\t\tconst actionsForClip = this._actionsByClip[ clipUuid ];\n\t\tlet prototypeAction = null;\n\n\t\tif ( blendMode === undefined ) {\n\n\t\t\tif ( clipObject !== null ) {\n\n\t\t\t\tblendMode = clipObject.blendMode;\n\n\t\t\t} else {\n\n\t\t\t\tblendMode = NormalAnimationBlendMode;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\tconst existingAction = actionsForClip.actionByRoot[ rootUuid ];\n\n\t\t\tif ( existingAction !== undefined && existingAction.blendMode === blendMode ) {\n\n\t\t\t\treturn existingAction;\n\n\t\t\t}\n\n\t\t\t// we know the clip, so we don't have to parse all\n\t\t\t// the bindings again but can just copy\n\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\n\n\t\t\t// also, take the clip from the prototype action\n\t\t\tif ( clipObject === null )\n\t\t\t\tclipObject = prototypeAction._clip;\n\n\t\t}\n\n\t\t// clip must be known when specified via string\n\t\tif ( clipObject === null ) return null;\n\n\t\t// allocate all resources required to run it\n\t\tconst newAction = new AnimationAction( this, clipObject, optionalRoot, blendMode );\n\n\t\tthis._bindAction( newAction, prototypeAction );\n\n\t\t// and make the action known to the memory manager\n\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\n\n\t\treturn newAction;\n\n\t}\n\n\t// get an existing action\n\texistingAction( clip, optionalRoot ) {\n\n\t\tconst root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid,\n\n\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\n\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\n\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t// deactivates all previously scheduled actions\n\tstopAllAction() {\n\n\t\tconst actions = this._actions,\n\t\t\tnActions = this._nActiveActions;\n\n\t\tfor ( let i = nActions - 1; i >= 0; -- i ) {\n\n\t\t\tactions[ i ].stop();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// advance the time and update apply the animation\n\tupdate( deltaTime ) {\n\n\t\tdeltaTime *= this.timeScale;\n\n\t\tconst actions = this._actions,\n\t\t\tnActions = this._nActiveActions,\n\n\t\t\ttime = this.time += deltaTime,\n\t\t\ttimeDirection = Math.sign( deltaTime ),\n\n\t\t\taccuIndex = this._accuIndex ^= 1;\n\n\t\t// run active actions\n\n\t\tfor ( let i = 0; i !== nActions; ++ i ) {\n\n\t\t\tconst action = actions[ i ];\n\n\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\n\n\t\t}\n\n\t\t// update scene graph\n\n\t\tconst bindings = this._bindings,\n\t\t\tnBindings = this._nActiveBindings;\n\n\t\tfor ( let i = 0; i !== nBindings; ++ i ) {\n\n\t\t\tbindings[ i ].apply( accuIndex );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Allows you to seek to a specific time in an animation.\n\tsetTime( timeInSeconds ) {\n\n\t\tthis.time = 0; // Zero out time attribute for AnimationMixer object;\n\t\tfor ( let i = 0; i < this._actions.length; i ++ ) {\n\n\t\t\tthis._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.\n\n\t\t}\n\n\t\treturn this.update( timeInSeconds ); // Update used to set exact time. Returns \"this\" AnimationMixer object.\n\n\t}\n\n\t// return this mixer's root target object\n\tgetRoot() {\n\n\t\treturn this._root;\n\n\t}\n\n\t// free all resources specific to a particular clip\n\tuncacheClip( clip ) {\n\n\t\tconst actions = this._actions,\n\t\t\tclipUuid = clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t// iteration state and also require updating the state we can\n\t\t\t// just throw away\n\n\t\t\tconst actionsToRemove = actionsForClip.knownActions;\n\n\t\t\tfor ( let i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\n\n\t\t\t\tconst action = actionsToRemove[ i ];\n\n\t\t\t\tthis._deactivateAction( action );\n\n\t\t\t\tconst cacheIndex = action._cacheIndex,\n\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\n\n\t\t\t\taction._cacheIndex = null;\n\t\t\t\taction._byClipCacheIndex = null;\n\n\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\tactions.pop();\n\n\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\n\t\t\t}\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t}\n\n\t// free all resources specific to a particular root target object\n\tuncacheRoot( root ) {\n\n\t\tconst rootUuid = root.uuid,\n\t\t\tactionsByClip = this._actionsByClip;\n\n\t\tfor ( const clipUuid in actionsByClip ) {\n\n\t\t\tconst actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\n\t\t\t\taction = actionByRoot[ rootUuid ];\n\n\t\t\tif ( action !== undefined ) {\n\n\t\t\t\tthis._deactivateAction( action );\n\t\t\t\tthis._removeInactiveAction( action );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingByName !== undefined ) {\n\n\t\t\tfor ( const trackName in bindingByName ) {\n\n\t\t\t\tconst binding = bindingByName[ trackName ];\n\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// remove a targeted clip from the cache\n\tuncacheAction( clip, optionalRoot ) {\n\n\t\tconst action = this.existingAction( clip, optionalRoot );\n\n\t\tif ( action !== null ) {\n\n\t\t\tthis._deactivateAction( action );\n\t\t\tthis._removeInactiveAction( action );\n\n\t\t}\n\n\t}\n\n}\n\nclass Uniform {\n\n\tconstructor( value ) {\n\n\t\tthis.value = value;\n\n\t}\n\n\tclone() {\n\n\t\treturn new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );\n\n\t}\n\n}\n\nlet _id = 0;\n\nclass UniformsGroup extends EventDispatcher {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isUniformsGroup = true;\n\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\tthis.name = '';\n\n\t\tthis.usage = StaticDrawUsage;\n\t\tthis.uniforms = [];\n\n\t}\n\n\tadd( uniform ) {\n\n\t\tthis.uniforms.push( uniform );\n\n\t\treturn this;\n\n\t}\n\n\tremove( uniform ) {\n\n\t\tconst index = this.uniforms.indexOf( uniform );\n\n\t\tif ( index !== - 1 ) this.uniforms.splice( index, 1 );\n\n\t\treturn this;\n\n\t}\n\n\tsetName( name ) {\n\n\t\tthis.name = name;\n\n\t\treturn this;\n\n\t}\n\n\tsetUsage( value ) {\n\n\t\tthis.usage = value;\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.name = source.name;\n\t\tthis.usage = source.usage;\n\n\t\tconst uniformsSource = source.uniforms;\n\n\t\tthis.uniforms.length = 0;\n\n\t\tfor ( let i = 0, l = uniformsSource.length; i < l; i ++ ) {\n\n\t\t\tconst uniforms = Array.isArray( uniformsSource[ i ] ) ? uniformsSource[ i ] : [ uniformsSource[ i ] ];\n\n\t\t\tfor ( let j = 0; j < uniforms.length; j ++ ) {\n\n\t\t\t\tthis.uniforms.push( uniforms[ j ].clone() );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nclass InstancedInterleavedBuffer extends InterleavedBuffer {\n\n\tconstructor( array, stride, meshPerAttribute = 1 ) {\n\n\t\tsuper( array, stride );\n\n\t\tthis.isInstancedInterleavedBuffer = true;\n\n\t\tthis.meshPerAttribute = meshPerAttribute;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\t\treturn this;\n\n\t}\n\n\tclone( data ) {\n\n\t\tconst ib = super.clone( data );\n\n\t\tib.meshPerAttribute = this.meshPerAttribute;\n\n\t\treturn ib;\n\n\t}\n\n\ttoJSON( data ) {\n\n\t\tconst json = super.toJSON( data );\n\n\t\tjson.isInstancedInterleavedBuffer = true;\n\t\tjson.meshPerAttribute = this.meshPerAttribute;\n\n\t\treturn json;\n\n\t}\n\n}\n\nclass GLBufferAttribute {\n\n\tconstructor( buffer, type, itemSize, elementSize, count ) {\n\n\t\tthis.isGLBufferAttribute = true;\n\n\t\tthis.name = '';\n\n\t\tthis.buffer = buffer;\n\t\tthis.type = type;\n\t\tthis.itemSize = itemSize;\n\t\tthis.elementSize = elementSize;\n\t\tthis.count = count;\n\n\t\tthis.version = 0;\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\tsetBuffer( buffer ) {\n\n\t\tthis.buffer = buffer;\n\n\t\treturn this;\n\n\t}\n\n\tsetType( type, elementSize ) {\n\n\t\tthis.type = type;\n\t\tthis.elementSize = elementSize;\n\n\t\treturn this;\n\n\t}\n\n\tsetItemSize( itemSize ) {\n\n\t\tthis.itemSize = itemSize;\n\n\t\treturn this;\n\n\t}\n\n\tsetCount( count ) {\n\n\t\tthis.count = count;\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _matrix = /*@__PURE__*/ new Matrix4();\n\nclass Raycaster {\n\n\tconstructor( origin, direction, near = 0, far = Infinity ) {\n\n\t\tthis.ray = new Ray( origin, direction );\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\tthis.near = near;\n\t\tthis.far = far;\n\t\tthis.camera = null;\n\t\tthis.layers = new Layers();\n\n\t\tthis.params = {\n\t\t\tMesh: {},\n\t\t\tLine: { threshold: 1 },\n\t\t\tLOD: {},\n\t\t\tPoints: { threshold: 1 },\n\t\t\tSprite: {}\n\t\t};\n\n\t}\n\n\tset( origin, direction ) {\n\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\tthis.ray.set( origin, direction );\n\n\t}\n\n\tsetFromCamera( coords, camera ) {\n\n\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\n\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\n\t\t\tthis.camera = camera;\n\n\t\t} else if ( camera.isOrthographicCamera ) {\n\n\t\t\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\n\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\t\t\tthis.camera = camera;\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type: ' + camera.type );\n\n\t\t}\n\n\t}\n\n\tsetFromXRController( controller ) {\n\n\t\t_matrix.identity().extractRotation( controller.matrixWorld );\n\n\t\tthis.ray.origin.setFromMatrixPosition( controller.matrixWorld );\n\t\tthis.ray.direction.set( 0, 0, - 1 ).applyMatrix4( _matrix );\n\n\t\treturn this;\n\n\t}\n\n\tintersectObject( object, recursive = true, intersects = [] ) {\n\n\t\tintersect( object, this, intersects, recursive );\n\n\t\tintersects.sort( ascSort );\n\n\t\treturn intersects;\n\n\t}\n\n\tintersectObjects( objects, recursive = true, intersects = [] ) {\n\n\t\tfor ( let i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\t\tintersect( objects[ i ], this, intersects, recursive );\n\n\t\t}\n\n\t\tintersects.sort( ascSort );\n\n\t\treturn intersects;\n\n\t}\n\n}\n\nfunction ascSort( a, b ) {\n\n\treturn a.distance - b.distance;\n\n}\n\nfunction intersect( object, raycaster, intersects, recursive ) {\n\n\tlet propagate = true;\n\n\tif ( object.layers.test( raycaster.layers ) ) {\n\n\t\tconst result = object.raycast( raycaster, intersects );\n\n\t\tif ( result === false ) propagate = false;\n\n\t}\n\n\tif ( propagate === true && recursive === true ) {\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tintersect( children[ i ], raycaster, intersects, true );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n *\n * phi (the polar angle) is measured from the positive y-axis. The positive y-axis is up.\n * theta (the azimuthal angle) is measured from the positive z-axis.\n */\nclass Spherical {\n\n\tconstructor( radius = 1, phi = 0, theta = 0 ) {\n\n\t\tthis.radius = radius;\n\t\tthis.phi = phi; // polar angle\n\t\tthis.theta = theta; // azimuthal angle\n\n\t\treturn this;\n\n\t}\n\n\tset( radius, phi, theta ) {\n\n\t\tthis.radius = radius;\n\t\tthis.phi = phi;\n\t\tthis.theta = theta;\n\n\t\treturn this;\n\n\t}\n\n\tcopy( other ) {\n\n\t\tthis.radius = other.radius;\n\t\tthis.phi = other.phi;\n\t\tthis.theta = other.theta;\n\n\t\treturn this;\n\n\t}\n\n\t// restrict phi to be between EPS and PI-EPS\n\tmakeSafe() {\n\n\t\tconst EPS = 0.000001;\n\t\tthis.phi = clamp( this.phi, EPS, Math.PI - EPS );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromVector3( v ) {\n\n\t\treturn this.setFromCartesianCoords( v.x, v.y, v.z );\n\n\t}\n\n\tsetFromCartesianCoords( x, y, z ) {\n\n\t\tthis.radius = Math.sqrt( x * x + y * y + z * z );\n\n\t\tif ( this.radius === 0 ) {\n\n\t\t\tthis.theta = 0;\n\t\t\tthis.phi = 0;\n\n\t\t} else {\n\n\t\t\tthis.theta = Math.atan2( x, z );\n\t\t\tthis.phi = Math.acos( clamp( y / this.radius, - 1, 1 ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\n/**\n * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system\n */\n\nclass Cylindrical {\n\n\tconstructor( radius = 1, theta = 0, y = 0 ) {\n\n\t\tthis.radius = radius; // distance from the origin to a point in the x-z plane\n\t\tthis.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis\n\t\tthis.y = y; // height above the x-z plane\n\n\t\treturn this;\n\n\t}\n\n\tset( radius, theta, y ) {\n\n\t\tthis.radius = radius;\n\t\tthis.theta = theta;\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tcopy( other ) {\n\n\t\tthis.radius = other.radius;\n\t\tthis.theta = other.theta;\n\t\tthis.y = other.y;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromVector3( v ) {\n\n\t\treturn this.setFromCartesianCoords( v.x, v.y, v.z );\n\n\t}\n\n\tsetFromCartesianCoords( x, y, z ) {\n\n\t\tthis.radius = Math.sqrt( x * x + z * z );\n\t\tthis.theta = Math.atan2( x, z );\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nclass Matrix2 {\n\n\tconstructor( n11, n12, n21, n22 ) {\n\n\t\tMatrix2.prototype.isMatrix2 = true;\n\n\t\tthis.elements = [\n\t\t\t1, 0,\n\t\t\t0, 1,\n\t\t];\n\n\t\tif ( n11 !== undefined ) {\n\n\t\t\tthis.set( n11, n12, n21, n22 );\n\n\t\t}\n\n\t}\n\n\tidentity() {\n\n\t\tthis.set(\n\t\t\t1, 0,\n\t\t\t0, 1,\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tset( n11, n12, n21, n22 ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 2 ] = n12;\n\t\tte[ 1 ] = n21; te[ 3 ] = n22;\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _vector$4 = /*@__PURE__*/ new Vector2();\n\nclass Box2 {\n\n\tconstructor( min = new Vector2( + Infinity, + Infinity ), max = new Vector2( - Infinity, - Infinity ) ) {\n\n\t\tthis.isBox2 = true;\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tset( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( let i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCenterAndSize( center, size ) {\n\n\t\tconst halfSize = _vector$4.copy( size ).multiplyScalar( 0.5 );\n\t\tthis.min.copy( center ).sub( halfSize );\n\t\tthis.max.copy( center ).add( halfSize );\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t}\n\n\tmakeEmpty() {\n\n\t\tthis.min.x = this.min.y = + Infinity;\n\t\tthis.max.x = this.max.y = - Infinity;\n\n\t\treturn this;\n\n\t}\n\n\tisEmpty() {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\n\n\t}\n\n\tgetCenter( target ) {\n\n\t\treturn this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t}\n\n\tgetSize( target ) {\n\n\t\treturn this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );\n\n\t}\n\n\texpandByPoint( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t}\n\n\texpandByVector( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t}\n\n\texpandByScalar( scalar ) {\n\n\t\tthis.min.addScalar( - scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn point.x >= this.min.x && point.x <= this.max.x &&\n\t\t\tpoint.y >= this.min.y && point.y <= this.max.y;\n\n\t}\n\n\tcontainsBox( box ) {\n\n\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\n\t\t\tthis.min.y <= box.min.y && box.max.y <= this.max.y;\n\n\t}\n\n\tgetParameter( point, target ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\treturn target.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\n\t\t);\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\t// using 4 splitting planes to rule out intersections\n\n\t\treturn box.max.x >= this.min.x && box.min.x <= this.max.x &&\n\t\t\tbox.max.y >= this.min.y && box.min.y <= this.max.y;\n\n\t}\n\n\tclampPoint( point, target ) {\n\n\t\treturn target.copy( point ).clamp( this.min, this.max );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn this.clampPoint( point, _vector$4 ).distanceTo( point );\n\n\t}\n\n\tintersect( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\tif ( this.isEmpty() ) this.makeEmpty();\n\n\t\treturn this;\n\n\t}\n\n\tunion( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t}\n\n\tequals( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t}\n\n}\n\nconst _startP = /*@__PURE__*/ new Vector3();\nconst _startEnd = /*@__PURE__*/ new Vector3();\n\nclass Line3 {\n\n\tconstructor( start = new Vector3(), end = new Vector3() ) {\n\n\t\tthis.start = start;\n\t\tthis.end = end;\n\n\t}\n\n\tset( start, end ) {\n\n\t\tthis.start.copy( start );\n\t\tthis.end.copy( end );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( line ) {\n\n\t\tthis.start.copy( line.start );\n\t\tthis.end.copy( line.end );\n\n\t\treturn this;\n\n\t}\n\n\tgetCenter( target ) {\n\n\t\treturn target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\n\n\t}\n\n\tdelta( target ) {\n\n\t\treturn target.subVectors( this.end, this.start );\n\n\t}\n\n\tdistanceSq() {\n\n\t\treturn this.start.distanceToSquared( this.end );\n\n\t}\n\n\tdistance() {\n\n\t\treturn this.start.distanceTo( this.end );\n\n\t}\n\n\tat( t, target ) {\n\n\t\treturn this.delta( target ).multiplyScalar( t ).add( this.start );\n\n\t}\n\n\tclosestPointToPointParameter( point, clampToLine ) {\n\n\t\t_startP.subVectors( point, this.start );\n\t\t_startEnd.subVectors( this.end, this.start );\n\n\t\tconst startEnd2 = _startEnd.dot( _startEnd );\n\t\tconst startEnd_startP = _startEnd.dot( _startP );\n\n\t\tlet t = startEnd_startP / startEnd2;\n\n\t\tif ( clampToLine ) {\n\n\t\t\tt = clamp( t, 0, 1 );\n\n\t\t}\n\n\t\treturn t;\n\n\t}\n\n\tclosestPointToPoint( point, clampToLine, target ) {\n\n\t\tconst t = this.closestPointToPointParameter( point, clampToLine );\n\n\t\treturn this.delta( target ).multiplyScalar( t ).add( this.start );\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tthis.start.applyMatrix4( matrix );\n\t\tthis.end.applyMatrix4( matrix );\n\n\t\treturn this;\n\n\t}\n\n\tequals( line ) {\n\n\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nconst _vector$3 = /*@__PURE__*/ new Vector3();\n\nclass SpotLightHelper extends Object3D {\n\n\tconstructor( light, color ) {\n\n\t\tsuper();\n\n\t\tthis.light = light;\n\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.color = color;\n\n\t\tthis.type = 'SpotLightHelper';\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tconst positions = [\n\t\t\t0, 0, 0, \t0, 0, 1,\n\t\t\t0, 0, 0, \t1, 0, 1,\n\t\t\t0, 0, 0,\t- 1, 0, 1,\n\t\t\t0, 0, 0, \t0, 1, 1,\n\t\t\t0, 0, 0, \t0, - 1, 1\n\t\t];\n\n\t\tfor ( let i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\n\n\t\t\tconst p1 = ( i / l ) * Math.PI * 2;\n\t\t\tconst p2 = ( j / l ) * Math.PI * 2;\n\n\t\t\tpositions.push(\n\t\t\t\tMath.cos( p1 ), Math.sin( p1 ), 1,\n\t\t\t\tMath.cos( p2 ), Math.sin( p2 ), 1\n\t\t\t);\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { fog: false, toneMapped: false } );\n\n\t\tthis.cone = new LineSegments( geometry, material );\n\t\tthis.add( this.cone );\n\n\t\tthis.update();\n\n\t}\n\n\tdispose() {\n\n\t\tthis.cone.geometry.dispose();\n\t\tthis.cone.material.dispose();\n\n\t}\n\n\tupdate() {\n\n\t\tthis.light.updateWorldMatrix( true, false );\n\t\tthis.light.target.updateWorldMatrix( true, false );\n\n\t\t// update the local matrix based on the parent and light target transforms\n\t\tif ( this.parent ) {\n\n\t\t\tthis.parent.updateWorldMatrix( true );\n\n\t\t\tthis.matrix\n\t\t\t\t.copy( this.parent.matrixWorld )\n\t\t\t\t.invert()\n\t\t\t\t.multiply( this.light.matrixWorld );\n\n\t\t} else {\n\n\t\t\tthis.matrix.copy( this.light.matrixWorld );\n\n\t\t}\n\n\t\tthis.matrixWorld.copy( this.light.matrixWorld );\n\n\t\tconst coneLength = this.light.distance ? this.light.distance : 1000;\n\t\tconst coneWidth = coneLength * Math.tan( this.light.angle );\n\n\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\n\n\t\t_vector$3.setFromMatrixPosition( this.light.target.matrixWorld );\n\n\t\tthis.cone.lookAt( _vector$3 );\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.cone.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tthis.cone.material.color.copy( this.light.color );\n\n\t\t}\n\n\t}\n\n}\n\nconst _vector$2 = /*@__PURE__*/ new Vector3();\nconst _boneMatrix = /*@__PURE__*/ new Matrix4();\nconst _matrixWorldInv = /*@__PURE__*/ new Matrix4();\n\n\nclass SkeletonHelper extends LineSegments {\n\n\tconstructor( object ) {\n\n\t\tconst bones = getBoneList( object );\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tconst vertices = [];\n\t\tconst colors = [];\n\n\t\tconst color1 = new Color( 0, 0, 1 );\n\t\tconst color2 = new Color( 0, 1, 0 );\n\n\t\tfor ( let i = 0; i < bones.length; i ++ ) {\n\n\t\t\tconst bone = bones[ i ];\n\n\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\tvertices.push( 0, 0, 0 );\n\t\t\t\tvertices.push( 0, 0, 0 );\n\t\t\t\tcolors.push( color1.r, color1.g, color1.b );\n\t\t\t\tcolors.push( color2.r, color2.g, color2.b );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isSkeletonHelper = true;\n\n\t\tthis.type = 'SkeletonHelper';\n\n\t\tthis.root = object;\n\t\tthis.bones = bones;\n\n\t\tthis.matrix = object.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tconst bones = this.bones;\n\n\t\tconst geometry = this.geometry;\n\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t_matrixWorldInv.copy( this.root.matrixWorld ).invert();\n\n\t\tfor ( let i = 0, j = 0; i < bones.length; i ++ ) {\n\n\t\t\tconst bone = bones[ i ];\n\n\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\t_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.matrixWorld );\n\t\t\t\t_vector$2.setFromMatrixPosition( _boneMatrix );\n\t\t\t\tposition.setXYZ( j, _vector$2.x, _vector$2.y, _vector$2.z );\n\n\t\t\t\t_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.parent.matrixWorld );\n\t\t\t\t_vector$2.setFromMatrixPosition( _boneMatrix );\n\t\t\t\tposition.setXYZ( j + 1, _vector$2.x, _vector$2.y, _vector$2.z );\n\n\t\t\t\tj += 2;\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.getAttribute( 'position' ).needsUpdate = true;\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\n\nfunction getBoneList( object ) {\n\n\tconst boneList = [];\n\n\tif ( object.isBone === true ) {\n\n\t\tboneList.push( object );\n\n\t}\n\n\tfor ( let i = 0; i < object.children.length; i ++ ) {\n\n\t\tboneList.push.apply( boneList, getBoneList( object.children[ i ] ) );\n\n\t}\n\n\treturn boneList;\n\n}\n\nclass PointLightHelper extends Mesh {\n\n\tconstructor( light, sphereSize, color ) {\n\n\t\tconst geometry = new SphereGeometry( sphereSize, 4, 2 );\n\t\tconst material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.light = light;\n\n\t\tthis.color = color;\n\n\t\tthis.type = 'PointLightHelper';\n\n\t\tthis.matrix = this.light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.update();\n\n\n\t\t/*\n\t// TODO: delete this comment?\n\tconst distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\n\tconst distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\n\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\n\tconst d = light.distance;\n\n\tif ( d === 0.0 ) {\n\n\t\tthis.lightDistance.visible = false;\n\n\t} else {\n\n\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t}\n\n\tthis.add( this.lightDistance );\n\t*/\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n\tupdate() {\n\n\t\tthis.light.updateWorldMatrix( true, false );\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tthis.material.color.copy( this.light.color );\n\n\t\t}\n\n\t\t/*\n\t\tconst d = this.light.distance;\n\n\t\tif ( d === 0.0 ) {\n\n\t\t\tthis.lightDistance.visible = false;\n\n\t\t} else {\n\n\t\t\tthis.lightDistance.visible = true;\n\t\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t\t}\n\t\t*/\n\n\t}\n\n}\n\nconst _vector$1 = /*@__PURE__*/ new Vector3();\nconst _color1 = /*@__PURE__*/ new Color();\nconst _color2 = /*@__PURE__*/ new Color();\n\nclass HemisphereLightHelper extends Object3D {\n\n\tconstructor( light, size, color ) {\n\n\t\tsuper();\n\n\t\tthis.light = light;\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.color = color;\n\n\t\tthis.type = 'HemisphereLightHelper';\n\n\t\tconst geometry = new OctahedronGeometry( size );\n\t\tgeometry.rotateY( Math.PI * 0.5 );\n\n\t\tthis.material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );\n\t\tif ( this.color === undefined ) this.material.vertexColors = true;\n\n\t\tconst position = geometry.getAttribute( 'position' );\n\t\tconst colors = new Float32Array( position.count * 3 );\n\n\t\tgeometry.setAttribute( 'color', new BufferAttribute( colors, 3 ) );\n\n\t\tthis.add( new Mesh( geometry, this.material ) );\n\n\t\tthis.update();\n\n\t}\n\n\tdispose() {\n\n\t\tthis.children[ 0 ].geometry.dispose();\n\t\tthis.children[ 0 ].material.dispose();\n\n\t}\n\n\tupdate() {\n\n\t\tconst mesh = this.children[ 0 ];\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tconst colors = mesh.geometry.getAttribute( 'color' );\n\n\t\t\t_color1.copy( this.light.color );\n\t\t\t_color2.copy( this.light.groundColor );\n\n\t\t\tfor ( let i = 0, l = colors.count; i < l; i ++ ) {\n\n\t\t\t\tconst color = ( i < ( l / 2 ) ) ? _color1 : _color2;\n\n\t\t\t\tcolors.setXYZ( i, color.r, color.g, color.b );\n\n\t\t\t}\n\n\t\t\tcolors.needsUpdate = true;\n\n\t\t}\n\n\t\tthis.light.updateWorldMatrix( true, false );\n\n\t\tmesh.lookAt( _vector$1.setFromMatrixPosition( this.light.matrixWorld ).negate() );\n\n\t}\n\n}\n\nclass GridHelper extends LineSegments {\n\n\tconstructor( size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888 ) {\n\n\t\tcolor1 = new Color( color1 );\n\t\tcolor2 = new Color( color2 );\n\n\t\tconst center = divisions / 2;\n\t\tconst step = size / divisions;\n\t\tconst halfSize = size / 2;\n\n\t\tconst vertices = [], colors = [];\n\n\t\tfor ( let i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {\n\n\t\t\tvertices.push( - halfSize, 0, k, halfSize, 0, k );\n\t\t\tvertices.push( k, 0, - halfSize, k, 0, halfSize );\n\n\t\t\tconst color = i === center ? color1 : color2;\n\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\n\t\t}\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'GridHelper';\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nclass PolarGridHelper extends LineSegments {\n\n\tconstructor( radius = 10, sectors = 16, rings = 8, divisions = 64, color1 = 0x444444, color2 = 0x888888 ) {\n\n\t\tcolor1 = new Color( color1 );\n\t\tcolor2 = new Color( color2 );\n\n\t\tconst vertices = [];\n\t\tconst colors = [];\n\n\t\t// create the sectors\n\n\t\tif ( sectors > 1 ) {\n\n\t\t\tfor ( let i = 0; i < sectors; i ++ ) {\n\n\t\t\t\tconst v = ( i / sectors ) * ( Math.PI * 2 );\n\n\t\t\t\tconst x = Math.sin( v ) * radius;\n\t\t\t\tconst z = Math.cos( v ) * radius;\n\n\t\t\t\tvertices.push( 0, 0, 0 );\n\t\t\t\tvertices.push( x, 0, z );\n\n\t\t\t\tconst color = ( i & 1 ) ? color1 : color2;\n\n\t\t\t\tcolors.push( color.r, color.g, color.b );\n\t\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// create the rings\n\n\t\tfor ( let i = 0; i < rings; i ++ ) {\n\n\t\t\tconst color = ( i & 1 ) ? color1 : color2;\n\n\t\t\tconst r = radius - ( radius / rings * i );\n\n\t\t\tfor ( let j = 0; j < divisions; j ++ ) {\n\n\t\t\t\t// first vertex\n\n\t\t\t\tlet v = ( j / divisions ) * ( Math.PI * 2 );\n\n\t\t\t\tlet x = Math.sin( v ) * r;\n\t\t\t\tlet z = Math.cos( v ) * r;\n\n\t\t\t\tvertices.push( x, 0, z );\n\t\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\t\t// second vertex\n\n\t\t\t\tv = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );\n\n\t\t\t\tx = Math.sin( v ) * r;\n\t\t\t\tz = Math.cos( v ) * r;\n\n\t\t\t\tvertices.push( x, 0, z );\n\t\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'PolarGridHelper';\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nconst _v1 = /*@__PURE__*/ new Vector3();\nconst _v2 = /*@__PURE__*/ new Vector3();\nconst _v3 = /*@__PURE__*/ new Vector3();\n\nclass DirectionalLightHelper extends Object3D {\n\n\tconstructor( light, size, color ) {\n\n\t\tsuper();\n\n\t\tthis.light = light;\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.color = color;\n\n\t\tthis.type = 'DirectionalLightHelper';\n\n\t\tif ( size === undefined ) size = 1;\n\n\t\tlet geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( [\n\t\t\t- size, size, 0,\n\t\t\tsize, size, 0,\n\t\t\tsize, - size, 0,\n\t\t\t- size, - size, 0,\n\t\t\t- size, size, 0\n\t\t], 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { fog: false, toneMapped: false } );\n\n\t\tthis.lightPlane = new Line( geometry, material );\n\t\tthis.add( this.lightPlane );\n\n\t\tgeometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\n\n\t\tthis.targetLine = new Line( geometry, material );\n\t\tthis.add( this.targetLine );\n\n\t\tthis.update();\n\n\t}\n\n\tdispose() {\n\n\t\tthis.lightPlane.geometry.dispose();\n\t\tthis.lightPlane.material.dispose();\n\t\tthis.targetLine.geometry.dispose();\n\t\tthis.targetLine.material.dispose();\n\n\t}\n\n\tupdate() {\n\n\t\tthis.light.updateWorldMatrix( true, false );\n\t\tthis.light.target.updateWorldMatrix( true, false );\n\n\t\t_v1.setFromMatrixPosition( this.light.matrixWorld );\n\t\t_v2.setFromMatrixPosition( this.light.target.matrixWorld );\n\t\t_v3.subVectors( _v2, _v1 );\n\n\t\tthis.lightPlane.lookAt( _v2 );\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.lightPlane.material.color.set( this.color );\n\t\t\tthis.targetLine.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tthis.lightPlane.material.color.copy( this.light.color );\n\t\t\tthis.targetLine.material.color.copy( this.light.color );\n\n\t\t}\n\n\t\tthis.targetLine.lookAt( _v2 );\n\t\tthis.targetLine.scale.z = _v3.length();\n\n\t}\n\n}\n\nconst _vector = /*@__PURE__*/ new Vector3();\nconst _camera = /*@__PURE__*/ new Camera();\n\n/**\n *\t- shows frustum, line of sight and up of the camera\n *\t- suitable for fast updates\n * \t- based on frustum visualization in lightgl.js shadowmap example\n *\t\thttps://github.com/evanw/lightgl.js/blob/master/tests/shadowmap.html\n */\n\nclass CameraHelper extends LineSegments {\n\n\tconstructor( camera ) {\n\n\t\tconst geometry = new BufferGeometry();\n\t\tconst material = new LineBasicMaterial( { color: 0xffffff, vertexColors: true, toneMapped: false } );\n\n\t\tconst vertices = [];\n\t\tconst colors = [];\n\n\t\tconst pointMap = {};\n\n\t\t// near\n\n\t\taddLine( 'n1', 'n2' );\n\t\taddLine( 'n2', 'n4' );\n\t\taddLine( 'n4', 'n3' );\n\t\taddLine( 'n3', 'n1' );\n\n\t\t// far\n\n\t\taddLine( 'f1', 'f2' );\n\t\taddLine( 'f2', 'f4' );\n\t\taddLine( 'f4', 'f3' );\n\t\taddLine( 'f3', 'f1' );\n\n\t\t// sides\n\n\t\taddLine( 'n1', 'f1' );\n\t\taddLine( 'n2', 'f2' );\n\t\taddLine( 'n3', 'f3' );\n\t\taddLine( 'n4', 'f4' );\n\n\t\t// cone\n\n\t\taddLine( 'p', 'n1' );\n\t\taddLine( 'p', 'n2' );\n\t\taddLine( 'p', 'n3' );\n\t\taddLine( 'p', 'n4' );\n\n\t\t// up\n\n\t\taddLine( 'u1', 'u2' );\n\t\taddLine( 'u2', 'u3' );\n\t\taddLine( 'u3', 'u1' );\n\n\t\t// target\n\n\t\taddLine( 'c', 't' );\n\t\taddLine( 'p', 'c' );\n\n\t\t// cross\n\n\t\taddLine( 'cn1', 'cn2' );\n\t\taddLine( 'cn3', 'cn4' );\n\n\t\taddLine( 'cf1', 'cf2' );\n\t\taddLine( 'cf3', 'cf4' );\n\n\t\tfunction addLine( a, b ) {\n\n\t\t\taddPoint( a );\n\t\t\taddPoint( b );\n\n\t\t}\n\n\t\tfunction addPoint( id ) {\n\n\t\t\tvertices.push( 0, 0, 0 );\n\t\t\tcolors.push( 0, 0, 0 );\n\n\t\t\tif ( pointMap[ id ] === undefined ) {\n\n\t\t\t\tpointMap[ id ] = [];\n\n\t\t\t}\n\n\t\t\tpointMap[ id ].push( ( vertices.length / 3 ) - 1 );\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'CameraHelper';\n\n\t\tthis.camera = camera;\n\t\tif ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();\n\n\t\tthis.matrix = camera.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.pointMap = pointMap;\n\n\t\tthis.update();\n\n\t\t// colors\n\n\t\tconst colorFrustum = new Color( 0xffaa00 );\n\t\tconst colorCone = new Color( 0xff0000 );\n\t\tconst colorUp = new Color( 0x00aaff );\n\t\tconst colorTarget = new Color( 0xffffff );\n\t\tconst colorCross = new Color( 0x333333 );\n\n\t\tthis.setColors( colorFrustum, colorCone, colorUp, colorTarget, colorCross );\n\n\t}\n\n\tsetColors( frustum, cone, up, target, cross ) {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst colorAttribute = geometry.getAttribute( 'color' );\n\n\t\t// near\n\n\t\tcolorAttribute.setXYZ( 0, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 1, frustum.r, frustum.g, frustum.b ); // n1, n2\n\t\tcolorAttribute.setXYZ( 2, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 3, frustum.r, frustum.g, frustum.b ); // n2, n4\n\t\tcolorAttribute.setXYZ( 4, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 5, frustum.r, frustum.g, frustum.b ); // n4, n3\n\t\tcolorAttribute.setXYZ( 6, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 7, frustum.r, frustum.g, frustum.b ); // n3, n1\n\n\t\t// far\n\n\t\tcolorAttribute.setXYZ( 8, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 9, frustum.r, frustum.g, frustum.b ); // f1, f2\n\t\tcolorAttribute.setXYZ( 10, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 11, frustum.r, frustum.g, frustum.b ); // f2, f4\n\t\tcolorAttribute.setXYZ( 12, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 13, frustum.r, frustum.g, frustum.b ); // f4, f3\n\t\tcolorAttribute.setXYZ( 14, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 15, frustum.r, frustum.g, frustum.b ); // f3, f1\n\n\t\t// sides\n\n\t\tcolorAttribute.setXYZ( 16, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 17, frustum.r, frustum.g, frustum.b ); // n1, f1\n\t\tcolorAttribute.setXYZ( 18, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 19, frustum.r, frustum.g, frustum.b ); // n2, f2\n\t\tcolorAttribute.setXYZ( 20, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 21, frustum.r, frustum.g, frustum.b ); // n3, f3\n\t\tcolorAttribute.setXYZ( 22, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 23, frustum.r, frustum.g, frustum.b ); // n4, f4\n\n\t\t// cone\n\n\t\tcolorAttribute.setXYZ( 24, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 25, cone.r, cone.g, cone.b ); // p, n1\n\t\tcolorAttribute.setXYZ( 26, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 27, cone.r, cone.g, cone.b ); // p, n2\n\t\tcolorAttribute.setXYZ( 28, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 29, cone.r, cone.g, cone.b ); // p, n3\n\t\tcolorAttribute.setXYZ( 30, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 31, cone.r, cone.g, cone.b ); // p, n4\n\n\t\t// up\n\n\t\tcolorAttribute.setXYZ( 32, up.r, up.g, up.b ); colorAttribute.setXYZ( 33, up.r, up.g, up.b ); // u1, u2\n\t\tcolorAttribute.setXYZ( 34, up.r, up.g, up.b ); colorAttribute.setXYZ( 35, up.r, up.g, up.b ); // u2, u3\n\t\tcolorAttribute.setXYZ( 36, up.r, up.g, up.b ); colorAttribute.setXYZ( 37, up.r, up.g, up.b ); // u3, u1\n\n\t\t// target\n\n\t\tcolorAttribute.setXYZ( 38, target.r, target.g, target.b ); colorAttribute.setXYZ( 39, target.r, target.g, target.b ); // c, t\n\t\tcolorAttribute.setXYZ( 40, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 41, cross.r, cross.g, cross.b ); // p, c\n\n\t\t// cross\n\n\t\tcolorAttribute.setXYZ( 42, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 43, cross.r, cross.g, cross.b ); // cn1, cn2\n\t\tcolorAttribute.setXYZ( 44, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 45, cross.r, cross.g, cross.b ); // cn3, cn4\n\n\t\tcolorAttribute.setXYZ( 46, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 47, cross.r, cross.g, cross.b ); // cf1, cf2\n\t\tcolorAttribute.setXYZ( 48, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 49, cross.r, cross.g, cross.b ); // cf3, cf4\n\n\t\tcolorAttribute.needsUpdate = true;\n\n\t}\n\n\tupdate() {\n\n\t\tconst geometry = this.geometry;\n\t\tconst pointMap = this.pointMap;\n\n\t\tconst w = 1, h = 1;\n\n\t\t// we need just camera projection matrix inverse\n\t\t// world matrix must be identity\n\n\t\t_camera.projectionMatrixInverse.copy( this.camera.projectionMatrixInverse );\n\n\t\t// center / target\n\n\t\tsetPoint( 'c', pointMap, geometry, _camera, 0, 0, - 1 );\n\t\tsetPoint( 't', pointMap, geometry, _camera, 0, 0, 1 );\n\n\t\t// near\n\n\t\tsetPoint( 'n1', pointMap, geometry, _camera, - w, - h, - 1 );\n\t\tsetPoint( 'n2', pointMap, geometry, _camera, w, - h, - 1 );\n\t\tsetPoint( 'n3', pointMap, geometry, _camera, - w, h, - 1 );\n\t\tsetPoint( 'n4', pointMap, geometry, _camera, w, h, - 1 );\n\n\t\t// far\n\n\t\tsetPoint( 'f1', pointMap, geometry, _camera, - w, - h, 1 );\n\t\tsetPoint( 'f2', pointMap, geometry, _camera, w, - h, 1 );\n\t\tsetPoint( 'f3', pointMap, geometry, _camera, - w, h, 1 );\n\t\tsetPoint( 'f4', pointMap, geometry, _camera, w, h, 1 );\n\n\t\t// up\n\n\t\tsetPoint( 'u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, - 1 );\n\t\tsetPoint( 'u2', pointMap, geometry, _camera, - w * 0.7, h * 1.1, - 1 );\n\t\tsetPoint( 'u3', pointMap, geometry, _camera, 0, h * 2, - 1 );\n\n\t\t// cross\n\n\t\tsetPoint( 'cf1', pointMap, geometry, _camera, - w, 0, 1 );\n\t\tsetPoint( 'cf2', pointMap, geometry, _camera, w, 0, 1 );\n\t\tsetPoint( 'cf3', pointMap, geometry, _camera, 0, - h, 1 );\n\t\tsetPoint( 'cf4', pointMap, geometry, _camera, 0, h, 1 );\n\n\t\tsetPoint( 'cn1', pointMap, geometry, _camera, - w, 0, - 1 );\n\t\tsetPoint( 'cn2', pointMap, geometry, _camera, w, 0, - 1 );\n\t\tsetPoint( 'cn3', pointMap, geometry, _camera, 0, - h, - 1 );\n\t\tsetPoint( 'cn4', pointMap, geometry, _camera, 0, h, - 1 );\n\n\t\tgeometry.getAttribute( 'position' ).needsUpdate = true;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\n\nfunction setPoint( point, pointMap, geometry, camera, x, y, z ) {\n\n\t_vector.set( x, y, z ).unproject( camera );\n\n\tconst points = pointMap[ point ];\n\n\tif ( points !== undefined ) {\n\n\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tposition.setXYZ( points[ i ], _vector.x, _vector.y, _vector.z );\n\n\t\t}\n\n\t}\n\n}\n\nconst _box = /*@__PURE__*/ new Box3();\n\nclass BoxHelper extends LineSegments {\n\n\tconstructor( object, color = 0xffff00 ) {\n\n\t\tconst indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\t\tconst positions = new Float32Array( 8 * 3 );\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\n\t\tgeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\n\t\tsuper( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\n\n\t\tthis.object = object;\n\t\tthis.type = 'BoxHelper';\n\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.update();\n\n\t}\n\n\tupdate( object ) {\n\n\t\tif ( object !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );\n\n\t\t}\n\n\t\tif ( this.object !== undefined ) {\n\n\t\t\t_box.setFromObject( this.object );\n\n\t\t}\n\n\t\tif ( _box.isEmpty() ) return;\n\n\t\tconst min = _box.min;\n\t\tconst max = _box.max;\n\n\t\t/*\n\t\t\t5____4\n\t\t1/___0/|\n\t\t| 6__|_7\n\t\t2/___3/\n\n\t\t0: max.x, max.y, max.z\n\t\t1: min.x, max.y, max.z\n\t\t2: min.x, min.y, max.z\n\t\t3: max.x, min.y, max.z\n\t\t4: max.x, max.y, min.z\n\t\t5: min.x, max.y, min.z\n\t\t6: min.x, min.y, min.z\n\t\t7: max.x, min.y, min.z\n\t\t*/\n\n\t\tconst position = this.geometry.attributes.position;\n\t\tconst array = position.array;\n\n\t\tarray[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;\n\t\tarray[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;\n\t\tarray[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;\n\t\tarray[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\n\t\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\n\t\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\n\t\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\n\t\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\n\n\t\tposition.needsUpdate = true;\n\n\t\tthis.geometry.computeBoundingSphere();\n\n\t}\n\n\tsetFromObject( object ) {\n\n\t\tthis.object = object;\n\t\tthis.update();\n\n\t\treturn this;\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.object = source.object;\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nclass Box3Helper extends LineSegments {\n\n\tconstructor( box, color = 0xffff00 ) {\n\n\t\tconst indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\n\t\tconst positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\n\t\tsuper( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\n\n\t\tthis.box = box;\n\n\t\tthis.type = 'Box3Helper';\n\n\t\tthis.geometry.computeBoundingSphere();\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tconst box = this.box;\n\n\t\tif ( box.isEmpty() ) return;\n\n\t\tbox.getCenter( this.position );\n\n\t\tbox.getSize( this.scale );\n\n\t\tthis.scale.multiplyScalar( 0.5 );\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nclass PlaneHelper extends Line {\n\n\tconstructor( plane, size = 1, hex = 0xffff00 ) {\n\n\t\tconst color = hex;\n\n\t\tconst positions = [ 1, - 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, - 1, 0, 1, 1, 0 ];\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\t\tgeometry.computeBoundingSphere();\n\n\t\tsuper( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\n\n\t\tthis.type = 'PlaneHelper';\n\n\t\tthis.plane = plane;\n\n\t\tthis.size = size;\n\n\t\tconst positions2 = [ 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, 1, 0, - 1, - 1, 0, 1, - 1, 0 ];\n\n\t\tconst geometry2 = new BufferGeometry();\n\t\tgeometry2.setAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );\n\t\tgeometry2.computeBoundingSphere();\n\n\t\tthis.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false } ) ) );\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tthis.position.set( 0, 0, 0 );\n\n\t\tthis.scale.set( 0.5 * this.size, 0.5 * this.size, 1 );\n\n\t\tthis.lookAt( this.plane.normal );\n\n\t\tthis.translateZ( - this.plane.constant );\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\t\tthis.children[ 0 ].geometry.dispose();\n\t\tthis.children[ 0 ].material.dispose();\n\n\t}\n\n}\n\nconst _axis = /*@__PURE__*/ new Vector3();\nlet _lineGeometry, _coneGeometry;\n\nclass ArrowHelper extends Object3D {\n\n\t// dir is assumed to be normalized\n\n\tconstructor( dir = new Vector3( 0, 0, 1 ), origin = new Vector3( 0, 0, 0 ), length = 1, color = 0xffff00, headLength = length * 0.2, headWidth = headLength * 0.2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'ArrowHelper';\n\n\t\tif ( _lineGeometry === undefined ) {\n\n\t\t\t_lineGeometry = new BufferGeometry();\n\t\t\t_lineGeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );\n\n\t\t\t_coneGeometry = new CylinderGeometry( 0, 0.5, 1, 5, 1 );\n\t\t\t_coneGeometry.translate( 0, - 0.5, 0 );\n\n\t\t}\n\n\t\tthis.position.copy( origin );\n\n\t\tthis.line = new Line( _lineGeometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\n\t\tthis.line.matrixAutoUpdate = false;\n\t\tthis.add( this.line );\n\n\t\tthis.cone = new Mesh( _coneGeometry, new MeshBasicMaterial( { color: color, toneMapped: false } ) );\n\t\tthis.cone.matrixAutoUpdate = false;\n\t\tthis.add( this.cone );\n\n\t\tthis.setDirection( dir );\n\t\tthis.setLength( length, headLength, headWidth );\n\n\t}\n\n\tsetDirection( dir ) {\n\n\t\t// dir is assumed to be normalized\n\n\t\tif ( dir.y > 0.99999 ) {\n\n\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\n\n\t\t} else if ( dir.y < - 0.99999 ) {\n\n\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\n\n\t\t} else {\n\n\t\t\t_axis.set( dir.z, 0, - dir.x ).normalize();\n\n\t\t\tconst radians = Math.acos( dir.y );\n\n\t\t\tthis.quaternion.setFromAxisAngle( _axis, radians );\n\n\t\t}\n\n\t}\n\n\tsetLength( length, headLength = length * 0.2, headWidth = headLength * 0.2 ) {\n\n\t\tthis.line.scale.set( 1, Math.max( 0.0001, length - headLength ), 1 ); // see #17458\n\t\tthis.line.updateMatrix();\n\n\t\tthis.cone.scale.set( headWidth, headLength, headWidth );\n\t\tthis.cone.position.y = length;\n\t\tthis.cone.updateMatrix();\n\n\t}\n\n\tsetColor( color ) {\n\n\t\tthis.line.material.color.set( color );\n\t\tthis.cone.material.color.set( color );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source, false );\n\n\t\tthis.line.copy( source.line );\n\t\tthis.cone.copy( source.cone );\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.line.geometry.dispose();\n\t\tthis.line.material.dispose();\n\t\tthis.cone.geometry.dispose();\n\t\tthis.cone.material.dispose();\n\n\t}\n\n}\n\nclass AxesHelper extends LineSegments {\n\n\tconstructor( size = 1 ) {\n\n\t\tconst vertices = [\n\t\t\t0, 0, 0,\tsize, 0, 0,\n\t\t\t0, 0, 0,\t0, size, 0,\n\t\t\t0, 0, 0,\t0, 0, size\n\t\t];\n\n\t\tconst colors = [\n\t\t\t1, 0, 0,\t1, 0.6, 0,\n\t\t\t0, 1, 0,\t0.6, 1, 0,\n\t\t\t0, 0, 1,\t0, 0.6, 1\n\t\t];\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'AxesHelper';\n\n\t}\n\n\tsetColors( xAxisColor, yAxisColor, zAxisColor ) {\n\n\t\tconst color = new Color();\n\t\tconst array = this.geometry.attributes.color.array;\n\n\t\tcolor.set( xAxisColor );\n\t\tcolor.toArray( array, 0 );\n\t\tcolor.toArray( array, 3 );\n\n\t\tcolor.set( yAxisColor );\n\t\tcolor.toArray( array, 6 );\n\t\tcolor.toArray( array, 9 );\n\n\t\tcolor.set( zAxisColor );\n\t\tcolor.toArray( array, 12 );\n\t\tcolor.toArray( array, 15 );\n\n\t\tthis.geometry.attributes.color.needsUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nclass ShapePath {\n\n\tconstructor() {\n\n\t\tthis.type = 'ShapePath';\n\n\t\tthis.color = new Color();\n\n\t\tthis.subPaths = [];\n\t\tthis.currentPath = null;\n\n\t}\n\n\tmoveTo( x, y ) {\n\n\t\tthis.currentPath = new Path();\n\t\tthis.subPaths.push( this.currentPath );\n\t\tthis.currentPath.moveTo( x, y );\n\n\t\treturn this;\n\n\t}\n\n\tlineTo( x, y ) {\n\n\t\tthis.currentPath.lineTo( x, y );\n\n\t\treturn this;\n\n\t}\n\n\tquadraticCurveTo( aCPx, aCPy, aX, aY ) {\n\n\t\tthis.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\tbezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\tthis.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\tsplineThru( pts ) {\n\n\t\tthis.currentPath.splineThru( pts );\n\n\t\treturn this;\n\n\t}\n\n\ttoShapes( isCCW ) {\n\n\t\tfunction toShapesNoHoles( inSubpaths ) {\n\n\t\t\tconst shapes = [];\n\n\t\t\tfor ( let i = 0, l = inSubpaths.length; i < l; i ++ ) {\n\n\t\t\t\tconst tmpPath = inSubpaths[ i ];\n\n\t\t\t\tconst tmpShape = new Shape();\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\n\t\t\t\tshapes.push( tmpShape );\n\n\t\t\t}\n\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\n\n\t\t\tconst polyLen = inPolygon.length;\n\n\t\t\t// inPt on polygon contour => immediate success    or\n\t\t\t// toggling of inside/outside at every single! intersection point of an edge\n\t\t\t//  with the horizontal line through inPt, left of inPt\n\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\n\t\t\tlet inside = false;\n\t\t\tfor ( let p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\n\n\t\t\t\tlet edgeLowPt = inPolygon[ p ];\n\t\t\t\tlet edgeHighPt = inPolygon[ q ];\n\n\t\t\t\tlet edgeDx = edgeHighPt.x - edgeLowPt.x;\n\t\t\t\tlet edgeDy = edgeHighPt.y - edgeLowPt.y;\n\n\t\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\n\n\t\t\t\t\t// not parallel\n\t\t\t\t\tif ( edgeDy < 0 ) {\n\n\t\t\t\t\t\tedgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;\n\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\n\n\t\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\n\n\t\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\n\t\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\n\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// parallel or collinear\n\t\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\n\t\t\t\t\t// edge lies on the same horizontal line as inPt\n\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\n\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\n\t\t\t\t\t// continue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn\tinside;\n\n\t\t}\n\n\t\tconst isClockWise = ShapeUtils.isClockWise;\n\n\t\tconst subPaths = this.subPaths;\n\t\tif ( subPaths.length === 0 ) return [];\n\n\t\tlet solid, tmpPath, tmpShape;\n\t\tconst shapes = [];\n\n\t\tif ( subPaths.length === 1 ) {\n\n\t\t\ttmpPath = subPaths[ 0 ];\n\t\t\ttmpShape = new Shape();\n\t\t\ttmpShape.curves = tmpPath.curves;\n\t\t\tshapes.push( tmpShape );\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tlet holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\n\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\n\n\t\t// console.log(\"Holes first\", holesFirst);\n\n\t\tconst betterShapeHoles = [];\n\t\tconst newShapes = [];\n\t\tlet newShapeHoles = [];\n\t\tlet mainIdx = 0;\n\t\tlet tmpPoints;\n\n\t\tnewShapes[ mainIdx ] = undefined;\n\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\tfor ( let i = 0, l = subPaths.length; i < l; i ++ ) {\n\n\t\t\ttmpPath = subPaths[ i ];\n\t\t\ttmpPoints = tmpPath.getPoints();\n\t\t\tsolid = isClockWise( tmpPoints );\n\t\t\tsolid = isCCW ? ! solid : solid;\n\n\t\t\tif ( solid ) {\n\n\t\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\n\n\t\t\t\tnewShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };\n\t\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\n\n\t\t\t\tif ( holesFirst )\tmainIdx ++;\n\t\t\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\t\t\t//console.log('cw', i);\n\n\t\t\t} else {\n\n\t\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\n\n\t\t\t\t//console.log('ccw', i);\n\n\t\t\t}\n\n\t\t}\n\n\t\t// only Holes? -> probably all Shapes with wrong orientation\n\t\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\tif ( newShapes.length > 1 ) {\n\n\t\t\tlet ambiguous = false;\n\t\t\tlet toChange = 0;\n\n\t\t\tfor ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tbetterShapeHoles[ sIdx ] = [];\n\n\t\t\t}\n\n\t\t\tfor ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tconst sho = newShapeHoles[ sIdx ];\n\n\t\t\t\tfor ( let hIdx = 0; hIdx < sho.length; hIdx ++ ) {\n\n\t\t\t\t\tconst ho = sho[ hIdx ];\n\t\t\t\t\tlet hole_unassigned = true;\n\n\t\t\t\t\tfor ( let s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\n\n\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\n\n\t\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange ++;\n\n\t\t\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\t\t\thole_unassigned = false;\n\t\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tambiguous = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( toChange > 0 && ambiguous === false ) {\n\n\t\t\t\tnewShapeHoles = betterShapeHoles;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet tmpHoles;\n\n\t\tfor ( let i = 0, il = newShapes.length; i < il; i ++ ) {\n\n\t\t\ttmpShape = newShapes[ i ].s;\n\t\t\tshapes.push( tmpShape );\n\t\t\ttmpHoles = newShapeHoles[ i ];\n\n\t\t\tfor ( let j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\n\n\t\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//console.log(\"shape\", shapes);\n\n\t\treturn shapes;\n\n\t}\n\n}\n\nclass Controls extends EventDispatcher {\n\n\tconstructor( object, domElement = null ) {\n\n\t\tsuper();\n\n\t\tthis.object = object;\n\t\tthis.domElement = domElement;\n\n\t\tthis.enabled = true;\n\n\t\tthis.state = - 1;\n\n\t\tthis.keys = {};\n\t\tthis.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null };\n\t\tthis.touches = { ONE: null, TWO: null };\n\n\t}\n\n\tconnect() {}\n\n\tdisconnect() {}\n\n\tdispose() {}\n\n\tupdate( /* delta */ ) {}\n\n}\n\nfunction contain( texture, aspect ) {\n\n\tconst imageAspect = ( texture.image && texture.image.width ) ? texture.image.width / texture.image.height : 1;\n\n\tif ( imageAspect > aspect ) {\n\n\t\ttexture.repeat.x = 1;\n\t\ttexture.repeat.y = imageAspect / aspect;\n\n\t\ttexture.offset.x = 0;\n\t\ttexture.offset.y = ( 1 - texture.repeat.y ) / 2;\n\n\t} else {\n\n\t\ttexture.repeat.x = aspect / imageAspect;\n\t\ttexture.repeat.y = 1;\n\n\t\ttexture.offset.x = ( 1 - texture.repeat.x ) / 2;\n\t\ttexture.offset.y = 0;\n\n\t}\n\n\treturn texture;\n\n}\n\nfunction cover( texture, aspect ) {\n\n\tconst imageAspect = ( texture.image && texture.image.width ) ? texture.image.width / texture.image.height : 1;\n\n\tif ( imageAspect > aspect ) {\n\n\t\ttexture.repeat.x = aspect / imageAspect;\n\t\ttexture.repeat.y = 1;\n\n\t\ttexture.offset.x = ( 1 - texture.repeat.x ) / 2;\n\t\ttexture.offset.y = 0;\n\n\t} else {\n\n\t\ttexture.repeat.x = 1;\n\t\ttexture.repeat.y = imageAspect / aspect;\n\n\t\ttexture.offset.x = 0;\n\t\ttexture.offset.y = ( 1 - texture.repeat.y ) / 2;\n\n\t}\n\n\treturn texture;\n\n}\n\nfunction fill( texture ) {\n\n\ttexture.repeat.x = 1;\n\ttexture.repeat.y = 1;\n\n\ttexture.offset.x = 0;\n\ttexture.offset.y = 0;\n\n\treturn texture;\n\n}\n\n\n\n/**\n * Given the width, height, format, and type of a texture. Determines how many\n * bytes must be used to represent the texture.\n */\nfunction getByteLength( width, height, format, type ) {\n\n\tconst typeByteLength = getTextureTypeByteLength( type );\n\n\tswitch ( format ) {\n\n\t\t// https://registry.khronos.org/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml\n\t\tcase AlphaFormat:\n\t\t\treturn width * height;\n\t\tcase LuminanceFormat:\n\t\t\treturn width * height;\n\t\tcase LuminanceAlphaFormat:\n\t\t\treturn width * height * 2;\n\t\tcase RedFormat:\n\t\t\treturn ( ( width * height ) / typeByteLength.components ) * typeByteLength.byteLength;\n\t\tcase RedIntegerFormat:\n\t\t\treturn ( ( width * height ) / typeByteLength.components ) * typeByteLength.byteLength;\n\t\tcase RGFormat:\n\t\t\treturn ( ( width * height * 2 ) / typeByteLength.components ) * typeByteLength.byteLength;\n\t\tcase RGIntegerFormat:\n\t\t\treturn ( ( width * height * 2 ) / typeByteLength.components ) * typeByteLength.byteLength;\n\t\tcase RGBFormat:\n\t\t\treturn ( ( width * height * 3 ) / typeByteLength.components ) * typeByteLength.byteLength;\n\t\tcase RGBAFormat:\n\t\t\treturn ( ( width * height * 4 ) / typeByteLength.components ) * typeByteLength.byteLength;\n\t\tcase RGBAIntegerFormat:\n\t\t\treturn ( ( width * height * 4 ) / typeByteLength.components ) * typeByteLength.byteLength;\n\n\t\t// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_s3tc_srgb/\n\t\tcase RGB_S3TC_DXT1_Format:\n\t\tcase RGBA_S3TC_DXT1_Format:\n\t\t\treturn Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 8;\n\t\tcase RGBA_S3TC_DXT3_Format:\n\t\tcase RGBA_S3TC_DXT5_Format:\n\t\t\treturn Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 16;\n\n\t\t// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_pvrtc/\n\t\tcase RGB_PVRTC_2BPPV1_Format:\n\t\tcase RGBA_PVRTC_2BPPV1_Format:\n\t\t\treturn ( Math.max( width, 16 ) * Math.max( height, 8 ) ) / 4;\n\t\tcase RGB_PVRTC_4BPPV1_Format:\n\t\tcase RGBA_PVRTC_4BPPV1_Format:\n\t\t\treturn ( Math.max( width, 8 ) * Math.max( height, 8 ) ) / 2;\n\n\t\t// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_etc/\n\t\tcase RGB_ETC1_Format:\n\t\tcase RGB_ETC2_Format:\n\t\t\treturn Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 8;\n\t\tcase RGBA_ETC2_EAC_Format:\n\t\t\treturn Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 16;\n\n\t\t// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/\n\t\tcase RGBA_ASTC_4x4_Format:\n\t\t\treturn Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 16;\n\t\tcase RGBA_ASTC_5x4_Format:\n\t\t\treturn Math.floor( ( width + 4 ) / 5 ) * Math.floor( ( height + 3 ) / 4 ) * 16;\n\t\tcase RGBA_ASTC_5x5_Format:\n\t\t\treturn Math.floor( ( width + 4 ) / 5 ) * Math.floor( ( height + 4 ) / 5 ) * 16;\n\t\tcase RGBA_ASTC_6x5_Format:\n\t\t\treturn Math.floor( ( width + 5 ) / 6 ) * Math.floor( ( height + 4 ) / 5 ) * 16;\n\t\tcase RGBA_ASTC_6x6_Format:\n\t\t\treturn Math.floor( ( width + 5 ) / 6 ) * Math.floor( ( height + 5 ) / 6 ) * 16;\n\t\tcase RGBA_ASTC_8x5_Format:\n\t\t\treturn Math.floor( ( width + 7 ) / 8 ) * Math.floor( ( height + 4 ) / 5 ) * 16;\n\t\tcase RGBA_ASTC_8x6_Format:\n\t\t\treturn Math.floor( ( width + 7 ) / 8 ) * Math.floor( ( height + 5 ) / 6 ) * 16;\n\t\tcase RGBA_ASTC_8x8_Format:\n\t\t\treturn Math.floor( ( width + 7 ) / 8 ) * Math.floor( ( height + 7 ) / 8 ) * 16;\n\t\tcase RGBA_ASTC_10x5_Format:\n\t\t\treturn Math.floor( ( width + 9 ) / 10 ) * Math.floor( ( height + 4 ) / 5 ) * 16;\n\t\tcase RGBA_ASTC_10x6_Format:\n\t\t\treturn Math.floor( ( width + 9 ) / 10 ) * Math.floor( ( height + 5 ) / 6 ) * 16;\n\t\tcase RGBA_ASTC_10x8_Format:\n\t\t\treturn Math.floor( ( width + 9 ) / 10 ) * Math.floor( ( height + 7 ) / 8 ) * 16;\n\t\tcase RGBA_ASTC_10x10_Format:\n\t\t\treturn Math.floor( ( width + 9 ) / 10 ) * Math.floor( ( height + 9 ) / 10 ) * 16;\n\t\tcase RGBA_ASTC_12x10_Format:\n\t\t\treturn Math.floor( ( width + 11 ) / 12 ) * Math.floor( ( height + 9 ) / 10 ) * 16;\n\t\tcase RGBA_ASTC_12x12_Format:\n\t\t\treturn Math.floor( ( width + 11 ) / 12 ) * Math.floor( ( height + 11 ) / 12 ) * 16;\n\n\t\t// https://registry.khronos.org/webgl/extensions/EXT_texture_compression_bptc/\n\t\tcase RGBA_BPTC_Format:\n\t\tcase RGB_BPTC_SIGNED_Format:\n\t\tcase RGB_BPTC_UNSIGNED_Format:\n\t\t\treturn Math.ceil( width / 4 ) * Math.ceil( height / 4 ) * 16;\n\n\t\t// https://registry.khronos.org/webgl/extensions/EXT_texture_compression_rgtc/\n\t\tcase RED_RGTC1_Format:\n\t\tcase SIGNED_RED_RGTC1_Format:\n\t\t\treturn Math.ceil( width / 4 ) * Math.ceil( height / 4 ) * 8;\n\t\tcase RED_GREEN_RGTC2_Format:\n\t\tcase SIGNED_RED_GREEN_RGTC2_Format:\n\t\t\treturn Math.ceil( width / 4 ) * Math.ceil( height / 4 ) * 16;\n\n\t}\n\n\tthrow new Error(\n\t\t`Unable to determine texture byte length for ${format} format.`,\n\t);\n\n}\n\nfunction getTextureTypeByteLength( type ) {\n\n\tswitch ( type ) {\n\n\t\tcase UnsignedByteType:\n\t\tcase ByteType:\n\t\t\treturn { byteLength: 1, components: 1 };\n\t\tcase UnsignedShortType:\n\t\tcase ShortType:\n\t\tcase HalfFloatType:\n\t\t\treturn { byteLength: 2, components: 1 };\n\t\tcase UnsignedShort4444Type:\n\t\tcase UnsignedShort5551Type:\n\t\t\treturn { byteLength: 2, components: 4 };\n\t\tcase UnsignedIntType:\n\t\tcase IntType:\n\t\tcase FloatType:\n\t\t\treturn { byteLength: 4, components: 1 };\n\t\tcase UnsignedInt5999Type:\n\t\t\treturn { byteLength: 4, components: 3 };\n\n\t}\n\n\tthrow new Error( `Unknown texture type ${type}.` );\n\n}\n\nconst TextureUtils = {\n\tcontain,\n\tcover,\n\tfill,\n\tgetByteLength\n};\n\nclass WebGLMultipleRenderTargets extends WebGLRenderTarget { // @deprecated, r162\n\n\tconstructor( width = 1, height = 1, count = 1, options = {} ) {\n\n\t\tconsole.warn( 'THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the \"count\" parameter to enable MRT.' );\n\n\t\tsuper( width, height, { ...options, count } );\n\n\t\tthis.isWebGLMultipleRenderTargets = true;\n\n\t}\n\n\tget texture() {\n\n\t\treturn this.textures;\n\n\t}\n\n}\n\nif ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {\n\n\t__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {\n\t\trevision: REVISION,\n\t} } ) );\n\n}\n\nif ( typeof window !== 'undefined' ) {\n\n\tif ( window.__THREE__ ) {\n\n\t\tconsole.warn( 'WARNING: Multiple instances of Three.js being imported.' );\n\n\t} else {\n\n\t\twindow.__THREE__ = REVISION;\n\n\t}\n\n}\n\nexport { ACESFilmicToneMapping, AddEquation, AddOperation, AdditiveAnimationBlendMode, AdditiveBlending, AgXToneMapping, AlphaFormat, AlwaysCompare, AlwaysDepth, AlwaysStencilFunc, AmbientLight, AnimationAction, AnimationClip, AnimationLoader, AnimationMixer, AnimationObjectGroup, AnimationUtils, ArcCurve, ArrayCamera, ArrowHelper, AttachedBindMode, Audio, AudioAnalyser, AudioContext, AudioListener, AudioLoader, AxesHelper, BackSide, BasicDepthPacking, BasicShadowMap, BatchedMesh, Bone, BooleanKeyframeTrack, Box2, Box3, Box3Helper, BoxGeometry, BoxHelper, BufferAttribute, BufferGeometry, BufferGeometryLoader, ByteType, Cache, Camera, CameraHelper, CanvasTexture, CapsuleGeometry, CatmullRomCurve3, CineonToneMapping, CircleGeometry, ClampToEdgeWrapping, Clock, Color, ColorKeyframeTrack, ColorManagement, CompressedArrayTexture, CompressedCubeTexture, CompressedTexture, CompressedTextureLoader, ConeGeometry, ConstantAlphaFactor, ConstantColorFactor, Controls, CubeCamera, CubeReflectionMapping, CubeRefractionMapping, CubeTexture, CubeTextureLoader, CubeUVReflectionMapping, CubicBezierCurve, CubicBezierCurve3, CubicInterpolant, CullFaceBack, CullFaceFront, CullFaceFrontBack, CullFaceNone, Curve, CurvePath, CustomBlending, CustomToneMapping, CylinderGeometry, Cylindrical, Data3DTexture, DataArrayTexture, DataTexture, DataTextureLoader, DataUtils, DecrementStencilOp, DecrementWrapStencilOp, DefaultLoadingManager, DepthFormat, DepthStencilFormat, DepthTexture, DetachedBindMode, DirectionalLight, DirectionalLightHelper, DiscreteInterpolant, DodecahedronGeometry, DoubleSide, DstAlphaFactor, DstColorFactor, DynamicCopyUsage, DynamicDrawUsage, DynamicReadUsage, EdgesGeometry, EllipseCurve, EqualCompare, EqualDepth, EqualStencilFunc, EquirectangularReflectionMapping, EquirectangularRefractionMapping, Euler, EventDispatcher, ExtrudeGeometry, FileLoader, Float16BufferAttribute, Float32BufferAttribute, FloatType, Fog, FogExp2, FramebufferTexture, FrontSide, Frustum, GLBufferAttribute, GLSL1, GLSL3, GreaterCompare, GreaterDepth, GreaterEqualCompare, GreaterEqualDepth, GreaterEqualStencilFunc, GreaterStencilFunc, GridHelper, Group, HalfFloatType, HemisphereLight, HemisphereLightHelper, IcosahedronGeometry, ImageBitmapLoader, ImageLoader, ImageUtils, IncrementStencilOp, IncrementWrapStencilOp, InstancedBufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InstancedMesh, Int16BufferAttribute, Int32BufferAttribute, Int8BufferAttribute, IntType, InterleavedBuffer, InterleavedBufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, InvertStencilOp, KeepStencilOp, KeyframeTrack, LOD, LatheGeometry, Layers, LessCompare, LessDepth, LessEqualCompare, LessEqualDepth, LessEqualStencilFunc, LessStencilFunc, Light, LightProbe, Line, Line3, LineBasicMaterial, LineCurve, LineCurve3, LineDashedMaterial, LineLoop, LineSegments, LinearFilter, LinearInterpolant, LinearMipMapLinearFilter, LinearMipMapNearestFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, LinearSRGBColorSpace, LinearToneMapping, LinearTransfer, Loader, LoaderUtils, LoadingManager, LoopOnce, LoopPingPong, LoopRepeat, LuminanceAlphaFormat, LuminanceFormat, MOUSE, Material, MaterialLoader, MathUtils, Matrix2, Matrix3, Matrix4, MaxEquation, Mesh, MeshBasicMaterial, MeshDepthMaterial, MeshDistanceMaterial, MeshLambertMaterial, MeshMatcapMaterial, MeshNormalMaterial, MeshPhongMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MeshToonMaterial, MinEquation, MirroredRepeatWrapping, MixOperation, MultiplyBlending, MultiplyOperation, NearestFilter, NearestMipMapLinearFilter, NearestMipMapNearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, NeutralToneMapping, NeverCompare, NeverDepth, NeverStencilFunc, NoBlending, NoColorSpace, NoToneMapping, NormalAnimationBlendMode, NormalBlending, NotEqualCompare, NotEqualDepth, NotEqualStencilFunc, NumberKeyframeTrack, Object3D, ObjectLoader, ObjectSpaceNormalMap, OctahedronGeometry, OneFactor, OneMinusConstantAlphaFactor, OneMinusConstantColorFactor, OneMinusDstAlphaFactor, OneMinusDstColorFactor, OneMinusSrcAlphaFactor, OneMinusSrcColorFactor, OrthographicCamera, PCFShadowMap, PCFSoftShadowMap, Path, PerspectiveCamera, Plane, PlaneGeometry, PlaneHelper, PointLight, PointLightHelper, Points, PointsMaterial, PolarGridHelper, PolyhedronGeometry, PositionalAudio, PropertyBinding, PropertyMixer, QuadraticBezierCurve, QuadraticBezierCurve3, Quaternion, QuaternionKeyframeTrack, QuaternionLinearInterpolant, RAD2DEG, RED_GREEN_RGTC2_Format, RED_RGTC1_Format, REVISION, RGBADepthPacking, RGBAFormat, RGBAIntegerFormat, RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGBDepthPacking, RGBFormat, RGBIntegerFormat, RGB_BPTC_SIGNED_Format, RGB_BPTC_UNSIGNED_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, RGDepthPacking, RGFormat, RGIntegerFormat, RawShaderMaterial, Ray, Raycaster, RectAreaLight, RedFormat, RedIntegerFormat, ReinhardToneMapping, RenderTarget, RepeatWrapping, ReplaceStencilOp, ReverseSubtractEquation, RingGeometry, SIGNED_RED_GREEN_RGTC2_Format, SIGNED_RED_RGTC1_Format, SRGBColorSpace, SRGBTransfer, Scene, ShaderMaterial, ShadowMaterial, Shape, ShapeGeometry, ShapePath, ShapeUtils, ShortType, Skeleton, SkeletonHelper, SkinnedMesh, Source, Sphere, SphereGeometry, Spherical, SphericalHarmonics3, SplineCurve, SpotLight, SpotLightHelper, Sprite, SpriteMaterial, SrcAlphaFactor, SrcAlphaSaturateFactor, SrcColorFactor, StaticCopyUsage, StaticDrawUsage, StaticReadUsage, StereoCamera, StreamCopyUsage, StreamDrawUsage, StreamReadUsage, StringKeyframeTrack, SubtractEquation, SubtractiveBlending, TOUCH, TangentSpaceNormalMap, TetrahedronGeometry, Texture, TextureLoader, TextureUtils, TorusGeometry, TorusKnotGeometry, Triangle, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, TubeGeometry, UVMapping, Uint16BufferAttribute, Uint32BufferAttribute, Uint8BufferAttribute, Uint8ClampedBufferAttribute, Uniform, UniformsGroup, UniformsUtils, UnsignedByteType, UnsignedInt248Type, UnsignedInt5999Type, UnsignedIntType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShortType, VSMShadowMap, Vector2, Vector3, Vector4, VectorKeyframeTrack, VideoTexture, WebGL3DRenderTarget, WebGLArrayRenderTarget, WebGLCoordinateSystem, WebGLCubeRenderTarget, WebGLMultipleRenderTargets, WebGLRenderTarget, WebGPUCoordinateSystem, WireframeGeometry, WrapAroundEnding, ZeroCurvatureEnding, ZeroFactor, ZeroSlopeEnding, ZeroStencilOp, arrayNeedsUint32, cloneUniforms, createCanvasElement, createElementNS, getByteLength, getUnlitUniformColorSpace, mergeUniforms, probeAsync, toNormalizedProjectionMatrix, toReversedProjectionMatrix, warnOnce };\n","export class BoolArray {\n\t/** @type {Uint8Array} */\n\t#bytes;\n\n\t/**\n\t * @constructor\n\t * @overload\n\t * @param {number} size\n\t *\n\t * @constructor\n\t * @overload\n\t * @param {ArrayBuffer} buffer\n\t * @param {number=} byteOffset\n\t * @param {number=} length\n\t *\n\t * @constructor\n\t * @overload\n\t * @param {Iterable<boolean>} arr\n\t *\n\t * @constructor\n\t * @param {number | Iterable<boolean> | ArrayBuffer} x\n\t * @param {number} [byteOffset]\n\t * @param {number} [length]\n\t */\n\tconstructor(x, byteOffset, length) {\n\t\tif (typeof x === \"number\") {\n\t\t\tthis.#bytes = new Uint8Array(x);\n\t\t} else if (x instanceof ArrayBuffer) {\n\t\t\tthis.#bytes = new Uint8Array(x, byteOffset, length);\n\t\t} else {\n\t\t\tthis.#bytes = new Uint8Array(Array.from(x, (v) => (v ? 1 : 0)));\n\t\t}\n\t}\n\n\tget BYTES_PER_ELEMENT() {\n\t\treturn 1;\n\t}\n\n\tget byteOffset() {\n\t\treturn this.#bytes.byteOffset;\n\t}\n\n\tget byteLength() {\n\t\treturn this.#bytes.byteLength;\n\t}\n\n\t/** @type {ArrayBuffer} */\n\tget buffer() {\n\t\treturn this.#bytes.buffer;\n\t}\n\n\t/** @type {number} */\n\tget length() {\n\t\treturn this.#bytes.length;\n\t}\n\n\t/**\n\t * @param {number} idx\n\t * @returns {boolean}\n\t */\n\tget(idx) {\n\t\tlet value = this.#bytes[idx];\n\t\treturn typeof value === \"number\" ? value !== 0 : value;\n\t}\n\n\t/**\n\t * @param {number} idx\n\t * @param {boolean} value\n\t * @returns {void}\n\t */\n\tset(idx, value) {\n\t\tthis.#bytes[idx] = value ? 1 : 0;\n\t}\n\n\t/**\n\t * @param {boolean} value\n\t * @returns {void}\n\t */\n\tfill(value) {\n\t\tthis.#bytes.fill(value ? 1 : 0);\n\t}\n\n\t/**\n\t * @returns {IterableIterator<boolean>}\n\t */\n\t*[Symbol.iterator]() {\n\t\tfor (let i = 0; i < this.length; i++) {\n\t\t\tyield this.get(i);\n\t\t}\n\t}\n}\n\nexport class ByteStringArray {\n\t/** @type {Uint8Array} */\n\t_data;\n\n\t/**\n\t * @constructor\n\t * @overload\n\t * @param {number} chars\n\t * @param {number} size\n\t *\n\t * @constructor\n\t * @overload\n\t * @param {number} chars\n\t * @param {ArrayBuffer} buffer\n\t * @param {number=} byteOffset\n\t * @param {number=} length\n\t *\n\t * @constructor\n\t * @overload\n\t * @param {number} chars\n\t * @param {Iterable<string>} arr\n\t *\n\t * @constructor\n\t * @param {number} chars\n\t * @param {number | ArrayBuffer | Iterable<string>} x\n\t * @param {number=} byteOffset\n\t * @param {number=} length\n\t */\n\tconstructor(chars, x, byteOffset, length) {\n\t\tthis.chars = chars;\n\t\tif (typeof x === \"number\") {\n\t\t\tthis._data = new Uint8Array(x * chars);\n\t\t} else if (x instanceof ArrayBuffer) {\n\t\t\tif (length) length = length * chars;\n\t\t\tthis._data = new Uint8Array(x, byteOffset, length);\n\t\t} else {\n\t\t\tlet values = Array.from(x);\n\t\t\tthis._data = new Uint8Array(values.length * chars);\n\t\t\tfor (let i = 0; i < values.length; i++) {\n\t\t\t\tthis.set(i, values[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tget BYTES_PER_ELEMENT() {\n\t\treturn this.chars;\n\t}\n\n\tget byteOffset() {\n\t\treturn this._data.byteOffset;\n\t}\n\n\tget byteLength() {\n\t\treturn this._data.byteLength;\n\t}\n\n\t/** @type {ArrayBuffer} */\n\tget buffer() {\n\t\treturn this._data.buffer;\n\t}\n\n\t/** @type {number} */\n\tget length() {\n\t\treturn this.byteLength / this.BYTES_PER_ELEMENT;\n\t}\n\n\t/**\n\t * @param {number} idx\n\t * @returns {string}\n\t */\n\tget(idx) {\n\t\tconst view = new Uint8Array(\n\t\t\tthis.buffer,\n\t\t\tthis.byteOffset + this.chars * idx,\n\t\t\tthis.chars,\n\t\t);\n\t\treturn new TextDecoder().decode(view).replace(/\\x00/g, \"\");\n\t}\n\n\t/**\n\t * @private\n\t *\n\t * @param {string} s\n\t * @returns {Uint8Array}\n\t */\n\t_encode(s) {\n\t\treturn new TextEncoder().encode(s);\n\t}\n\n\t/**\n\t * @param {number} idx\n\t * @param {string} value\n\t * @returns {void}\n\t */\n\tset(idx, value) {\n\t\tconst view = new Uint8Array(\n\t\t\tthis.buffer,\n\t\t\tthis.byteOffset + this.chars * idx,\n\t\t\tthis.chars,\n\t\t);\n\t\tview.fill(0); // clear current\n\t\tview.set(this._encode(value));\n\t}\n\n\t/**\n\t * @param {string} value\n\t * @returns {void}\n\t */\n\tfill(value) {\n\t\tconst encoded = this._encode(value);\n\t\tfor (let i = 0; i < this.length; i++) {\n\t\t\tthis._data.set(encoded, i * this.chars);\n\t\t}\n\t}\n\n\t/** @returns {IterableIterator<string>} */\n\t*[Symbol.iterator]() {\n\t\tfor (let i = 0; i < this.length; i++) {\n\t\t\tyield this.get(i);\n\t\t}\n\t}\n}\n\nexport class UnicodeStringArray {\n\t/** @type {Int32Array} */\n\t_data;\n\n\t/**\n\t * @constructor\n\t * @overload\n\t * @param {number} chars\n\t * @param {number} size\n\t *\n\t * @constructor\n\t * @overload\n\t * @param {number} chars\n\t * @param {ArrayBuffer} buffer\n\t * @param {number=} byteOffset\n\t * @param {number=} length\n\t *\n\t * @constructor\n\t * @overload\n\t * @param {number} chars\n\t * @param {Iterable<string>} arr\n\t *\n\t * @constructor\n\t * @param {number} chars\n\t * @param {number | ArrayBuffer | Iterable<string>} x\n\t * @param {number} [byteOffset]\n\t * @param {number} [length]\n\t */\n\tconstructor(chars, x, byteOffset, length) {\n\t\tthis.chars = chars;\n\t\tif (typeof x === \"number\") {\n\t\t\tthis._data = new Int32Array(x * chars);\n\t\t} else if (x instanceof ArrayBuffer) {\n\t\t\tif (length) length *= chars;\n\t\t\tthis._data = new Int32Array(x, byteOffset, length);\n\t\t} else {\n\t\t\tconst values = x;\n\t\t\tconst encode = this._encode.bind(this);\n\t\t\tthis._data = new Int32Array((function* () {\n\t\t\t\tfor (let str of values) {\n\t\t\t\t\tlet int32 = encode(str);\n\t\t\t\t\tyield* int32;\n\t\t\t\t}\n\t\t\t})());\n\t\t}\n\t}\n\n\tget BYTES_PER_ELEMENT() {\n\t\treturn this._data.BYTES_PER_ELEMENT * this.chars;\n\t}\n\n\tget byteLength() {\n\t\treturn this._data.byteLength;\n\t}\n\n\tget byteOffset() {\n\t\treturn this._data.byteOffset;\n\t}\n\n\t/** @type {ArrayBuffer} */\n\tget buffer() {\n\t\treturn this._data.buffer;\n\t}\n\n\t/** @type {number} */\n\tget length() {\n\t\treturn this._data.length / this.chars;\n\t}\n\n\t/**\n\t * @private\n\t *\n\t * @param {string} s\n\t * @returns {Int32Array}\n\t */\n\t_encode(s) {\n\t\tlet out = new Int32Array(this.chars);\n\t\tfor (let i = 0; i < this.chars; i++) {\n\t\t\tout[i] = s.codePointAt(i) ?? 0;\n\t\t}\n\t\treturn out;\n\t}\n\n\t/**\n\t * @param {number} idx\n\t * @returns {string}\n\t */\n\tget(idx) {\n\t\tconst offset = this.chars * idx;\n\t\tlet result = \"\";\n\t\tfor (let i = 0; i < this.chars; i++) {\n\t\t\tresult += String.fromCodePoint(this._data[offset + i]);\n\t\t}\n\t\treturn result.replace(/\\u0000/g, \"\");\n\t}\n\n\t/**\n\t * @param {number} idx\n\t * @param {string} value\n\t * @returns {void}\n\t */\n\tset(idx, value) {\n\t\tconst offset = this.chars * idx;\n\t\tconst view = this._data.subarray(offset, offset + this.chars);\n\t\tview.fill(0); // clear current\n\t\tview.set(this._encode(value));\n\t}\n\n\t/**\n\t * @param {string} value\n\t * @returns {void}\n\t */\n\tfill(value) {\n\t\tconst encoded = this._encode(value);\n\t\tfor (let i = 0; i < this.length; i++) {\n\t\t\tthis._data.set(encoded, i * this.chars);\n\t\t}\n\t}\n\n\t/** @returns {IterableIterator<string>} */\n\t*[Symbol.iterator]() {\n\t\tfor (let i = 0; i < this.length; i++) {\n\t\t\tyield this.get(i);\n\t\t}\n\t}\n}\n","import { BoolArray, ByteStringArray, UnicodeStringArray, } from \"@zarrita/typedarray\";\nexport function json_encode_object(o) {\n    const str = JSON.stringify(o, null, 2);\n    return new TextEncoder().encode(str);\n}\nexport function json_decode_object(bytes) {\n    const str = new TextDecoder().decode(bytes);\n    return JSON.parse(str);\n}\nexport function byteswap_inplace(view, bytes_per_element) {\n    const numFlips = bytes_per_element / 2;\n    const endByteIndex = bytes_per_element - 1;\n    let t = 0;\n    for (let i = 0; i < view.length; i += bytes_per_element) {\n        for (let j = 0; j < numFlips; j += 1) {\n            t = view[i + j];\n            view[i + j] = view[i + endByteIndex - j];\n            view[i + endByteIndex - j] = t;\n        }\n    }\n}\nconst CONSTRUCTORS = {\n    int8: Int8Array,\n    int16: Int16Array,\n    int32: Int32Array,\n    int64: globalThis.BigInt64Array,\n    uint8: Uint8Array,\n    uint16: Uint16Array,\n    uint32: Uint32Array,\n    uint64: globalThis.BigUint64Array,\n    float32: Float32Array,\n    float64: Float64Array,\n    bool: BoolArray,\n};\nconst V2_STRING_REGEX = /v2:([US])(\\d+)/;\nexport function get_ctr(data_type) {\n    if (data_type === \"v2:object\") {\n        return globalThis.Array;\n    }\n    let match = data_type.match(V2_STRING_REGEX);\n    if (match) {\n        let [, kind, chars] = match;\n        // @ts-expect-error\n        return (kind === \"U\" ? UnicodeStringArray : ByteStringArray).bind(null, Number(chars));\n    }\n    let ctr = CONSTRUCTORS[data_type];\n    if (!ctr) {\n        throw new Error(`Unknown or unsupported data_type: ${data_type}`);\n    }\n    return ctr;\n}\n/** Compute strides for 'C' or 'F' ordered array from shape */\nexport function get_strides(shape, order) {\n    return (order === \"C\" ? row_major_stride : col_major_stride)(shape);\n}\nfunction row_major_stride(shape) {\n    const ndim = shape.length;\n    const stride = globalThis.Array(ndim);\n    for (let i = ndim - 1, step = 1; i >= 0; i--) {\n        stride[i] = step;\n        step *= shape[i];\n    }\n    return stride;\n}\nfunction col_major_stride(shape) {\n    const ndim = shape.length;\n    const stride = globalThis.Array(ndim);\n    for (let i = 0, step = 1; i < ndim; i++) {\n        stride[i] = step;\n        step *= shape[i];\n    }\n    return stride;\n}\nexport function create_chunk_key_encoder({ name, configuration }) {\n    if (name === \"default\") {\n        return (chunk_coords) => [\"c\", ...chunk_coords].join(configuration.separator);\n    }\n    if (name === \"v2\") {\n        return (chunk_coords) => chunk_coords.join(configuration.separator) || \"0\";\n    }\n    throw new Error(`Unknown chunk key encoding: ${name}`);\n}\nexport function get_array_order(codecs) {\n    const maybe_transpose_codec = codecs.find((c) => c.name === \"transpose\");\n    return maybe_transpose_codec?.configuration?.order === \"F\" ? \"F\" : \"C\";\n}\nconst endian_regex = /^([<|>])(.*)$/;\nfunction coerce_dtype(dtype) {\n    if (dtype === \"|O\") {\n        return { data_type: \"v2:object\" };\n    }\n    let match = dtype.match(endian_regex);\n    if (!match) {\n        throw new Error(`Invalid dtype: ${dtype}`);\n    }\n    let [, endian, rest] = match;\n    let data_type = {\n        \"b1\": \"bool\",\n        \"i1\": \"int8\",\n        \"u1\": \"uint8\",\n        \"i2\": \"int16\",\n        \"u2\": \"uint16\",\n        \"i4\": \"int32\",\n        \"u4\": \"uint32\",\n        \"i8\": \"int64\",\n        \"u8\": \"uint64\",\n        \"f4\": \"float32\",\n        \"f8\": \"float64\",\n    }[rest] ??\n        (rest.startsWith(\"S\") || rest.startsWith(\"U\") ? `v2:${rest}` : undefined);\n    if (!data_type) {\n        throw new Error(`Unsupported or unknown dtype: ${dtype}`);\n    }\n    if (endian === \"|\") {\n        return { data_type };\n    }\n    return { data_type, endian: endian === \"<\" ? \"little\" : \"big\" };\n}\nexport const v2_marker = Symbol(\"v2\");\nexport function v2_to_v3_array_metadata(meta, attributes = {}) {\n    let codecs = [];\n    let dtype = coerce_dtype(meta.dtype);\n    if (meta.order === \"F\") {\n        codecs.push({ name: \"transpose\", configuration: { order: \"F\" } });\n    }\n    if (\"endian\" in dtype && dtype.endian === \"big\") {\n        codecs.push({ name: \"endian\", configuration: { endian: \"big\" } });\n    }\n    for (let { id, ...configuration } of meta.filters ?? []) {\n        codecs.push({ name: id, configuration });\n    }\n    if (meta.compressor) {\n        let { id, ...configuration } = meta.compressor;\n        codecs.push({ name: id, configuration });\n    }\n    return {\n        zarr_format: 3,\n        node_type: \"array\",\n        shape: meta.shape,\n        data_type: dtype.data_type,\n        chunk_grid: {\n            name: \"regular\",\n            configuration: {\n                chunk_shape: meta.chunks,\n            },\n        },\n        chunk_key_encoding: {\n            name: \"v2\",\n            configuration: {\n                separator: meta.dimension_separator ?? \".\",\n            },\n        },\n        codecs,\n        fill_value: meta.fill_value,\n        attributes,\n    };\n}\nexport function v2_to_v3_group_metadata(_meta, attributes = {}) {\n    return {\n        zarr_format: 3,\n        node_type: \"group\",\n        attributes,\n    };\n}\nexport function is_dtype(dtype, query) {\n    if (query !== \"number\" &&\n        query !== \"bigint\" &&\n        query !== \"boolean\" &&\n        query !== \"object\" &&\n        query !== \"string\") {\n        return dtype === query;\n    }\n    let is_boolean = dtype === \"bool\";\n    if (query === \"boolean\")\n        return is_boolean;\n    let is_string = dtype.startsWith(\"v2:U\") || dtype.startsWith(\"v2:S\");\n    if (query === \"string\")\n        return is_string;\n    let is_bigint = dtype === \"int64\" || dtype === \"uint64\";\n    if (query === \"bigint\")\n        return is_bigint;\n    let is_object = dtype === \"v2:object\";\n    if (query === \"object\")\n        return is_object;\n    return !is_string && !is_bigint && !is_boolean && !is_object;\n}\nexport function is_sharding_codec(codec) {\n    return codec?.name === \"sharding_indexed\";\n}\nexport function ensure_correct_scalar(metadata) {\n    if ((metadata.data_type === \"uint64\" || metadata.data_type === \"int64\") &&\n        metadata.fill_value != undefined) {\n        return BigInt(metadata.fill_value);\n    }\n    return metadata.fill_value;\n}\n","import { BoolArray, ByteStringArray, UnicodeStringArray, } from \"@zarrita/typedarray\";\nimport { get_strides } from \"../util.js\";\nfunction proxy(arr) {\n    if (arr instanceof BoolArray ||\n        arr instanceof ByteStringArray ||\n        arr instanceof UnicodeStringArray) {\n        return new Proxy(arr, {\n            get(target, prop) {\n                return target.get(Number(prop));\n            },\n            set(target, prop, value) {\n                target.set(Number(prop), value);\n                return true;\n            },\n        });\n    }\n    return arr;\n}\nfunction empty_like(chunk, order) {\n    let data;\n    if (chunk.data instanceof ByteStringArray ||\n        chunk.data instanceof UnicodeStringArray) {\n        data = new chunk.constructor(\n        // @ts-expect-error\n        chunk.data.length, chunk.data.chars);\n    }\n    else {\n        data = new chunk.constructor(chunk.data.length);\n    }\n    return {\n        data,\n        shape: chunk.shape,\n        stride: get_strides(chunk.shape, order),\n    };\n}\nfunction convert_array_order(src, target) {\n    let out = empty_like(src, target);\n    let n_dims = src.shape.length;\n    let size = src.data.length;\n    let index = Array(n_dims).fill(0);\n    let src_data = proxy(src.data);\n    let out_data = proxy(out.data);\n    for (let src_idx = 0; src_idx < size; src_idx++) {\n        let out_idx = 0;\n        for (let dim = 0; dim < n_dims; dim++) {\n            out_idx += index[dim] * out.stride[dim];\n        }\n        out_data[out_idx] = src_data[src_idx];\n        index[0] += 1;\n        for (let dim = 0; dim < n_dims; dim++) {\n            if (index[dim] === src.shape[dim]) {\n                if (dim + 1 === n_dims) {\n                    break;\n                }\n                index[dim] = 0;\n                index[dim + 1] += 1;\n            }\n        }\n    }\n    return out;\n}\nfunction get_order(arr) {\n    // Assume C order if no stride is given\n    if (!arr.stride)\n        return \"C\";\n    let row_major_strides = get_strides(arr.shape, \"C\");\n    return arr.stride.every((s, i) => s === row_major_strides[i]) ? \"C\" : \"F\";\n}\nexport class TransposeCodec {\n    configuration;\n    kind = \"array_to_array\";\n    constructor(configuration) {\n        this.configuration = configuration;\n    }\n    static fromConfig(configuration) {\n        return new TransposeCodec(configuration);\n    }\n    encode(arr) {\n        if (get_order(arr) === this.configuration.order) {\n            return arr;\n        }\n        return convert_array_order(arr, this.configuration.order);\n    }\n    decode(arr) {\n        return arr;\n    }\n}\n","import { byteswap_inplace, get_array_order, get_ctr, get_strides, } from \"../util.js\";\nconst LITTLE_ENDIAN_OS = system_is_little_endian();\nfunction system_is_little_endian() {\n    const a = new Uint32Array([0x12345678]);\n    const b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n    return !(b[0] === 0x12);\n}\nfunction bytes_per_element(TypedArray) {\n    if (\"BYTES_PER_ELEMENT\" in TypedArray) {\n        return TypedArray.BYTES_PER_ELEMENT;\n    }\n    // Unicode string array is backed by a Int32Array.\n    return 4;\n}\nexport class EndianCodec {\n    configuration;\n    kind = \"array_to_bytes\";\n    #strides;\n    #TypedArray;\n    #BYTES_PER_ELEMENT;\n    #shape;\n    constructor(configuration, meta) {\n        this.configuration = configuration;\n        this.#TypedArray = get_ctr(meta.data_type);\n        this.#shape = meta.shape;\n        this.#strides = get_strides(meta.shape, get_array_order(meta.codecs));\n        // TODO: fix me.\n        // hack to get bytes per element since it's dynamic for string types.\n        this.#BYTES_PER_ELEMENT = new this.#TypedArray(0).BYTES_PER_ELEMENT;\n    }\n    static fromConfig(configuration, meta) {\n        return new EndianCodec(configuration, meta);\n    }\n    encode(arr) {\n        let bytes = new Uint8Array(arr.data.buffer);\n        if (LITTLE_ENDIAN_OS && this.configuration.endian === \"big\") {\n            byteswap_inplace(bytes, bytes_per_element(this.#TypedArray));\n        }\n        return bytes;\n    }\n    decode(bytes) {\n        if (LITTLE_ENDIAN_OS && this.configuration.endian === \"big\") {\n            byteswap_inplace(bytes, bytes_per_element(this.#TypedArray));\n        }\n        return {\n            data: new this.#TypedArray(bytes.buffer, bytes.byteOffset, bytes.byteLength / this.#BYTES_PER_ELEMENT),\n            shape: this.#shape,\n            stride: this.#strides,\n        };\n    }\n}\n","export class Crc32cCodec {\n    kind = \"bytes_to_bytes\";\n    constructor() { }\n    static fromConfig() {\n        return new Crc32cCodec();\n    }\n    encode(_) {\n        throw new Error(\"Not implemented\");\n    }\n    decode(arr) {\n        return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength - 4);\n    }\n}\n","import { get_strides } from \"../util.js\";\nexport class VLenUTF8 {\n    kind = \"array_to_bytes\";\n    #shape;\n    #strides;\n    constructor(shape) {\n        this.#shape = shape;\n        this.#strides = get_strides(shape, \"C\");\n    }\n    static fromConfig(_, meta) {\n        return new VLenUTF8(meta.shape);\n    }\n    encode(_chunk) {\n        throw new Error(\"Method not implemented.\");\n    }\n    decode(bytes) {\n        let decoder = new TextDecoder();\n        let view = new DataView(bytes.buffer);\n        let data = Array(view.getUint32(0, true));\n        let pos = 4;\n        for (let i = 0; i < data.length; i++) {\n            let item_length = view.getUint32(pos, true);\n            pos += 4;\n            data[i] = decoder.decode(bytes.buffer.slice(pos, pos + item_length));\n            pos += item_length;\n        }\n        return { data, shape: this.#shape, stride: this.#strides };\n    }\n}\n","import { TransposeCodec } from \"./codecs/transpose.js\";\nimport { EndianCodec } from \"./codecs/endian.js\";\nimport { Crc32cCodec } from \"./codecs/crc32c.js\";\nimport { VLenUTF8 } from \"./codecs/vlen-utf8.js\";\nfunction create_default_registry() {\n    return new Map()\n        .set(\"blosc\", () => import(\"numcodecs/blosc\").then((m) => m.default))\n        .set(\"gzip\", () => import(\"numcodecs/gzip\").then((m) => m.default))\n        .set(\"lz4\", () => import(\"numcodecs/lz4\").then((m) => m.default))\n        .set(\"zlib\", () => import(\"numcodecs/zlib\").then((m) => m.default))\n        .set(\"zstd\", () => import(\"numcodecs/zstd\").then((m) => m.default))\n        .set(\"transpose\", () => TransposeCodec)\n        .set(\"endian\", () => EndianCodec)\n        .set(\"crc32c\", () => Crc32cCodec)\n        .set(\"vlen-utf8\", () => VLenUTF8);\n}\nexport const registry = create_default_registry();\nexport function create_codec_pipeline(chunk_metadata) {\n    let codecs;\n    return {\n        async encode(chunk) {\n            if (!codecs)\n                codecs = await load_codecs(chunk_metadata);\n            for (const codec of codecs.array_to_array) {\n                chunk = await codec.encode(chunk);\n            }\n            let bytes = await codecs.array_to_bytes.encode(chunk);\n            for (const codec of codecs.bytes_to_bytes) {\n                bytes = await codec.encode(bytes);\n            }\n            return bytes;\n        },\n        async decode(bytes) {\n            if (!codecs)\n                codecs = await load_codecs(chunk_metadata);\n            for (let i = codecs.bytes_to_bytes.length - 1; i >= 0; i--) {\n                bytes = await codecs.bytes_to_bytes[i].decode(bytes);\n            }\n            let chunk = await codecs.array_to_bytes.decode(bytes);\n            for (let i = codecs.array_to_array.length - 1; i >= 0; i--) {\n                chunk = await codecs.array_to_array[i].decode(chunk);\n            }\n            return chunk;\n        },\n    };\n}\nasync function load_codecs(chunk_meta) {\n    let promises = chunk_meta.codecs.map(async (meta) => {\n        let Codec = await registry.get(meta.name)?.();\n        if (!Codec) {\n            throw new Error(`Unknown codec: ${meta.name}`);\n        }\n        return { Codec, meta };\n    });\n    let array_to_array = [];\n    let array_to_bytes = EndianCodec.fromConfig({\n        endian: \"little\",\n    }, chunk_meta);\n    let bytes_to_bytes = [];\n    for await (let { Codec, meta } of promises) {\n        let codec = Codec.fromConfig(meta.configuration, chunk_meta);\n        switch (codec.kind) {\n            case \"array_to_array\":\n                array_to_array.push(codec);\n                break;\n            case \"array_to_bytes\":\n                array_to_bytes = codec;\n                break;\n            default:\n                bytes_to_bytes.push(codec);\n        }\n    }\n    if (!array_to_bytes) {\n    }\n    return { array_to_array, array_to_bytes, bytes_to_bytes };\n}\n","import { create_codec_pipeline } from \"../codecs.js\";\nconst MAX_BIG_UINT = 18446744073709551615n;\nexport function create_sharded_chunk_getter(location, shard_shape, encode_shard_key, sharding_config) {\n    if (location.store.getRange === undefined) {\n        throw new Error(\"Store does not support range requests\");\n    }\n    let get_range = location.store.getRange.bind(location.store);\n    let index_shape = shard_shape.map((d, i) => d / sharding_config.chunk_shape[i]);\n    let index_codec = create_codec_pipeline({\n        data_type: \"uint64\",\n        shape: [...index_shape, 2],\n        codecs: sharding_config.index_codecs,\n    });\n    let cache = {};\n    return async (chunk_coord) => {\n        let shard_coord = chunk_coord.map((d, i) => Math.floor(d / index_shape[i]));\n        let shard_path = location.resolve(encode_shard_key(shard_coord)).path;\n        let index;\n        if (shard_path in cache) {\n            index = cache[shard_path];\n        }\n        else {\n            let checksum_size = 4;\n            let index_size = 16 * index_shape.reduce((a, b) => a * b, 1);\n            let bytes = await get_range(shard_path, {\n                suffixLength: index_size + checksum_size,\n            });\n            index = cache[shard_path] = bytes\n                ? await index_codec.decode(bytes)\n                : null;\n        }\n        if (index === null) {\n            return undefined;\n        }\n        let { data, shape, stride } = index;\n        let linear_offset = chunk_coord\n            .map((d, i) => d % shape[i])\n            .reduce((acc, sel, idx) => acc + sel * stride[idx], 0);\n        let offset = data[linear_offset];\n        let length = data[linear_offset + 1];\n        // write null chunk when 2^64-1 indicates fill value\n        if (offset === MAX_BIG_UINT && length === MAX_BIG_UINT) {\n            return undefined;\n        }\n        return get_range(shard_path, {\n            offset: Number(offset),\n            length: Number(length),\n        });\n    };\n}\n","import { is_dtype, is_sharding_codec, } from \"./util.js\";\nimport { create_codec_pipeline } from \"./codecs.js\";\nimport { create_chunk_key_encoder, ensure_correct_scalar, get_array_order, get_ctr, get_strides, } from \"./util.js\";\nimport { create_sharded_chunk_getter } from \"./codecs/sharding.js\";\nexport class Location {\n    store;\n    path;\n    constructor(store, path = \"/\") {\n        this.store = store;\n        this.path = path;\n    }\n    resolve(path) {\n        // reuse URL resolution logic built into the browser\n        // handles relative paths, absolute paths, etc.\n        let root = new URL(`file://${this.path.endsWith(\"/\") ? this.path : `${this.path}/`}`);\n        return new Location(this.store, new URL(path, root).pathname);\n    }\n}\nexport function root(store) {\n    return new Location(store ?? new Map());\n}\nexport class Group extends Location {\n    kind = \"group\";\n    #metadata;\n    constructor(store, path, metadata) {\n        super(store, path);\n        this.#metadata = metadata;\n    }\n    get attrs() {\n        return this.#metadata.attributes;\n    }\n}\nconst CONTEXT_MARKER = Symbol(\"zarrita.context\");\nexport function get_context(obj) {\n    return obj[CONTEXT_MARKER];\n}\nfunction create_context(location, metadata) {\n    let { configuration } = metadata.codecs.find(is_sharding_codec) ?? {};\n    let shared_context = {\n        encode_chunk_key: create_chunk_key_encoder(metadata.chunk_key_encoding),\n        TypedArray: get_ctr(metadata.data_type),\n        fill_value: metadata.fill_value,\n    };\n    if (configuration) {\n        let native_order = get_array_order(configuration.codecs);\n        return {\n            ...shared_context,\n            kind: \"sharded\",\n            chunk_shape: configuration.chunk_shape,\n            codec: create_codec_pipeline({\n                data_type: metadata.data_type,\n                shape: configuration.chunk_shape,\n                codecs: configuration.codecs,\n            }),\n            get_strides(shape, order) {\n                return get_strides(shape, order ?? native_order);\n            },\n            get_chunk_bytes: create_sharded_chunk_getter(location, metadata.chunk_grid.configuration.chunk_shape, shared_context.encode_chunk_key, configuration),\n        };\n    }\n    let native_order = get_array_order(metadata.codecs);\n    return {\n        ...shared_context,\n        kind: \"regular\",\n        chunk_shape: metadata.chunk_grid.configuration.chunk_shape,\n        codec: create_codec_pipeline({\n            data_type: metadata.data_type,\n            shape: metadata.chunk_grid.configuration.chunk_shape,\n            codecs: metadata.codecs,\n        }),\n        get_strides(shape, order) {\n            return get_strides(shape, order ?? native_order);\n        },\n        async get_chunk_bytes(chunk_coords, options) {\n            let chunk_key = shared_context.encode_chunk_key(chunk_coords);\n            let chunk_path = location.resolve(chunk_key).path;\n            return location.store.get(chunk_path, options);\n        },\n    };\n}\nexport class Array extends Location {\n    kind = \"array\";\n    #metadata;\n    [CONTEXT_MARKER];\n    constructor(store, path, metadata) {\n        super(store, path);\n        this.#metadata = {\n            ...metadata,\n            fill_value: ensure_correct_scalar(metadata),\n        };\n        this[CONTEXT_MARKER] = create_context(this, metadata);\n    }\n    get attrs() {\n        return this.#metadata.attributes;\n    }\n    get shape() {\n        return this.#metadata.shape;\n    }\n    get chunks() {\n        return this[CONTEXT_MARKER].chunk_shape;\n    }\n    get dtype() {\n        return this.#metadata.data_type;\n    }\n    async getChunk(chunk_coords, options) {\n        let context = this[CONTEXT_MARKER];\n        let maybe_bytes = await context.get_chunk_bytes(chunk_coords, options);\n        if (!maybe_bytes) {\n            let size = context.chunk_shape.reduce((a, b) => a * b, 1);\n            let data = new context.TypedArray(size);\n            data.fill(context.fill_value);\n            return {\n                data,\n                shape: context.chunk_shape,\n                stride: context.get_strides(context.chunk_shape),\n            };\n        }\n        return context.codec.decode(maybe_bytes);\n    }\n    /**\n     * A helper method to narrow `zarr.Array` Dtype.\n     *\n     * ```typescript\n     * let arr: zarr.Array<DataType, FetchStore> = zarr.open(store, { kind: \"array\" });\n     *\n     * // Option 1: narrow by scalar type (e.g. \"bool\", \"raw\", \"bigint\", \"number\")\n     * if (arr.is(\"bigint\")) {\n     *   // zarr.Array<\"int64\" | \"uint64\", FetchStore>\n     * }\n     *\n     * // Option 3: exact match\n     * if (arr.is(\"float32\")) {\n     *   // zarr.Array<\"float32\", FetchStore, \"/\">\n     * }\n     * ```\n     */\n    is(query) {\n        return is_dtype(this.dtype, query);\n    }\n}\n","import { Array, Group, Location } from \"./hierarchy.js\";\nimport { NodeNotFoundError } from \"./errors.js\";\nimport { json_decode_object, v2_to_v3_array_metadata, v2_to_v3_group_metadata, } from \"./util.js\";\nasync function load_attrs(location) {\n    let meta_bytes = await location.store.get(location.resolve(\".zattrs\").path);\n    if (!meta_bytes)\n        return {};\n    return json_decode_object(meta_bytes);\n}\nasync function open_v2(location, options = {}) {\n    let loc = \"store\" in location ? location : new Location(location);\n    let attrs = {};\n    if (options.attrs ?? true)\n        attrs = await load_attrs(loc);\n    if (options.kind === \"array\")\n        return open_array_v2(loc, attrs);\n    if (options.kind === \"group\")\n        return open_group_v2(loc, attrs);\n    return open_array_v2(loc, attrs).catch((err) => {\n        if (err instanceof NodeNotFoundError)\n            return open_group_v2(loc, attrs);\n        throw err;\n    });\n}\nasync function open_array_v2(location, attrs) {\n    let { path } = location.resolve(\".zarray\");\n    let meta = await location.store.get(path);\n    if (!meta) {\n        throw new NodeNotFoundError(path);\n    }\n    return new Array(location.store, location.path, v2_to_v3_array_metadata(json_decode_object(meta), attrs));\n}\nasync function open_group_v2(location, attrs) {\n    let { path } = location.resolve(\".zgroup\");\n    let meta = await location.store.get(path);\n    if (!meta) {\n        throw new NodeNotFoundError(path);\n    }\n    return new Group(location.store, location.path, v2_to_v3_group_metadata(json_decode_object(meta), attrs));\n}\nasync function _open_v3(location) {\n    let { store, path } = location.resolve(\"zarr.json\");\n    let meta = await location.store.get(path);\n    if (!meta) {\n        throw new NodeNotFoundError(path);\n    }\n    let meta_doc = json_decode_object(meta);\n    if (meta_doc.node_type === \"array\" &&\n        (meta_doc.data_type === \"uint64\" || meta_doc.data_type === \"int64\") &&\n        meta_doc.fill_value != undefined) {\n        meta_doc.fill_value = BigInt(meta_doc.fill_value);\n    }\n    return meta_doc.node_type === \"array\"\n        ? new Array(store, location.path, meta_doc)\n        : new Group(store, location.path, meta_doc);\n}\nasync function open_v3(location, options = {}) {\n    let loc = \"store\" in location ? location : new Location(location);\n    let node = await _open_v3(loc);\n    if (options.kind === undefined)\n        return node;\n    if (options.kind === \"array\" && node instanceof Array)\n        return node;\n    if (options.kind === \"group\" && node instanceof Group)\n        return node;\n    let kind = node instanceof Array ? \"array\" : \"group\";\n    throw new Error(`Expected node of kind ${options.kind}, found ${kind}.`);\n}\nexport async function open(location, options = {}) {\n    return open_v3(location, options).catch((err) => {\n        if (err instanceof NodeNotFoundError) {\n            return open_v2(location, options);\n        }\n        throw err;\n    });\n}\nopen.v2 = open_v2;\nopen.v3 = open_v3;\n","/** Similar to python's `range` function. Supports positive ranges only. */\nexport function* range(start, stop, step = 1) {\n    if (stop === undefined) {\n        stop = start;\n        start = 0;\n    }\n    for (let i = start; i < stop; i += step) {\n        yield i;\n    }\n}\n/**\n * python-like itertools.product generator\n * https://gist.github.com/cybercase/db7dde901d7070c98c48\n */\nexport function* product(...iterables) {\n    if (iterables.length === 0) {\n        return;\n    }\n    // make a list of iterators from the iterables\n    const iterators = iterables.map((it) => it[Symbol.iterator]());\n    const results = iterators.map((it) => it.next());\n    if (results.some((r) => r.done)) {\n        throw new Error(\"Input contains an empty iterator.\");\n    }\n    for (let i = 0;;) {\n        if (results[i].done) {\n            // reset the current iterator\n            iterators[i] = iterables[i][Symbol.iterator]();\n            results[i] = iterators[i].next();\n            // advance, and exit if we've reached the end\n            if (++i >= iterators.length) {\n                return;\n            }\n        }\n        else {\n            yield results.map(({ value }) => value);\n            i = 0;\n        }\n        results[i] = iterators[i].next();\n    }\n}\n// https://github.com/python/cpython/blob/263c0dd16017613c5ea2fbfc270be4de2b41b5ad/Objects/sliceobject.c#L376-L519\nfunction slice_indices(start, stop, step, length) {\n    if (step === 0) {\n        throw new Error(\"slice step cannot be zero\");\n    }\n    step = step ?? 1;\n    const step_is_negative = step < 0;\n    /* Find lower and upper bounds for start and stop. */\n    const [lower, upper] = step_is_negative ? [-1, length - 1] : [0, length];\n    /* Compute start. */\n    if (start === null) {\n        start = step_is_negative ? upper : lower;\n    }\n    else {\n        if (start < 0) {\n            start += length;\n            if (start < lower) {\n                start = lower;\n            }\n        }\n        else if (start > upper) {\n            start = upper;\n        }\n    }\n    /* Compute stop. */\n    if (stop === null) {\n        stop = step_is_negative ? lower : upper;\n    }\n    else {\n        if (stop < 0) {\n            stop += length;\n            if (stop < lower) {\n                stop = lower;\n            }\n        }\n        else if (stop > upper) {\n            stop = upper;\n        }\n    }\n    return [start, stop, step];\n}\nexport function slice(start, stop, step = null) {\n    if (stop === undefined) {\n        stop = start;\n        start = null;\n    }\n    return {\n        start,\n        stop,\n        step,\n        indices(length) {\n            return slice_indices(this.start, this.stop, this.step, length);\n        },\n    };\n}\n/** Built-in \"queue\" for awaiting promises. */\nexport function create_queue() {\n    const promises = [];\n    return {\n        add: (fn) => promises.push(fn()),\n        onIdle: () => Promise.all(promises),\n    };\n}\n","import { product, range, slice } from \"./util.js\";\nexport class IndexError extends Error {\n    constructor(msg) {\n        super(msg);\n        this.name = \"IndexError\";\n    }\n}\nfunction err_too_many_indices(selection, shape) {\n    throw new IndexError(`too many indicies for array; expected ${shape.length}, got ${selection.length}`);\n}\nfunction err_boundscheck(dim_len) {\n    throw new IndexError(`index out of bounds for dimension with length ${dim_len}`);\n}\nfunction err_negative_step() {\n    throw new IndexError(\"only slices with step >= 1 are supported\");\n}\nfunction check_selection_length(selection, shape) {\n    if (selection.length > shape.length) {\n        err_too_many_indices(selection, shape);\n    }\n}\nexport function normalize_integer_selection(dim_sel, dim_len) {\n    // normalize type to int\n    dim_sel = Math.trunc(dim_sel);\n    // handle wraparound\n    if (dim_sel < 0) {\n        dim_sel = dim_len + dim_sel;\n    }\n    // handle out of bounds\n    if (dim_sel >= dim_len || dim_sel < 0) {\n        err_boundscheck(dim_len);\n    }\n    return dim_sel;\n}\nclass IntDimIndexer {\n    dim_sel;\n    dim_len;\n    dim_chunk_len;\n    nitems;\n    constructor({ dim_sel, dim_len, dim_chunk_len }) {\n        // normalize\n        dim_sel = normalize_integer_selection(dim_sel, dim_len);\n        // store properties\n        this.dim_sel = dim_sel;\n        this.dim_len = dim_len;\n        this.dim_chunk_len = dim_chunk_len;\n        this.nitems = 1;\n    }\n    *[Symbol.iterator]() {\n        const dim_chunk_ix = Math.floor(this.dim_sel / this.dim_chunk_len);\n        const dim_offset = dim_chunk_ix * this.dim_chunk_len;\n        const dim_chunk_sel = this.dim_sel - dim_offset;\n        yield { dim_chunk_ix, dim_chunk_sel };\n    }\n}\nclass SliceDimIndexer {\n    start;\n    stop;\n    step;\n    dim_len;\n    dim_chunk_len;\n    nitems;\n    nchunks;\n    constructor({ dim_sel, dim_len, dim_chunk_len }) {\n        // normalize\n        const [start, stop, step] = dim_sel.indices(dim_len);\n        this.start = start;\n        this.stop = stop;\n        this.step = step;\n        if (this.step < 1)\n            err_negative_step();\n        // store properties\n        this.dim_len = dim_len;\n        this.dim_chunk_len = dim_chunk_len;\n        this.nitems = Math.max(0, Math.ceil((this.stop - this.start) / this.step));\n        this.nchunks = Math.ceil(this.dim_len / this.dim_chunk_len);\n    }\n    *[Symbol.iterator]() {\n        // figure out the range of chunks we need to visit\n        const dim_chunk_ix_from = Math.floor(this.start / this.dim_chunk_len);\n        const dim_chunk_ix_to = Math.ceil(this.stop / this.dim_chunk_len);\n        for (const dim_chunk_ix of range(dim_chunk_ix_from, dim_chunk_ix_to)) {\n            // compute offsets for chunk within overall array\n            const dim_offset = dim_chunk_ix * this.dim_chunk_len;\n            const dim_limit = Math.min(this.dim_len, (dim_chunk_ix + 1) * this.dim_chunk_len);\n            // determine chunk length, accounting for trailing chunk\n            const dim_chunk_len = dim_limit - dim_offset;\n            let dim_out_offset = 0;\n            let dim_chunk_sel_start = 0;\n            if (this.start < dim_offset) {\n                // selection start before current chunk\n                const remainder = (dim_offset - this.start) % this.step;\n                if (remainder)\n                    dim_chunk_sel_start += this.step - remainder;\n                // compute number of previous items, provides offset into output array\n                dim_out_offset = Math.ceil((dim_offset - this.start) / this.step);\n            }\n            else {\n                // selection starts within current chunk\n                dim_chunk_sel_start = this.start - dim_offset;\n            }\n            // selection starts within current chunk if true,\n            // otherwise selection ends after current chunk.\n            const dim_chunk_sel_stop = this.stop > dim_limit\n                ? dim_chunk_len\n                : this.stop - dim_offset;\n            const dim_chunk_sel = [\n                dim_chunk_sel_start,\n                dim_chunk_sel_stop,\n                this.step,\n            ];\n            const dim_chunk_nitems = Math.ceil((dim_chunk_sel_stop - dim_chunk_sel_start) / this.step);\n            const dim_out_sel = [\n                dim_out_offset,\n                dim_out_offset + dim_chunk_nitems,\n                1,\n            ];\n            yield { dim_chunk_ix, dim_chunk_sel, dim_out_sel };\n        }\n    }\n}\nexport function normalize_selection(selection, shape) {\n    let normalized = [];\n    if (selection === null) {\n        normalized = shape.map((_) => slice(null));\n    }\n    else if (Array.isArray(selection)) {\n        normalized = selection.map((s) => s ?? slice(null));\n    }\n    check_selection_length(normalized, shape);\n    return normalized;\n}\nexport class BasicIndexer {\n    dim_indexers;\n    shape;\n    constructor({ selection, shape, chunk_shape }) {\n        // setup per-dimension indexers\n        this.dim_indexers = normalize_selection(selection, shape).map((dim_sel, i) => {\n            return new (typeof dim_sel === \"number\"\n                ? IntDimIndexer\n                : SliceDimIndexer)({\n                // @ts-expect-error ts inference not strong enough to know correct chunk\n                dim_sel: dim_sel,\n                dim_len: shape[i],\n                dim_chunk_len: chunk_shape[i],\n            });\n        });\n        this.shape = this.dim_indexers\n            .filter((ixr) => ixr instanceof SliceDimIndexer)\n            .map((sixr) => sixr.nitems);\n    }\n    *[Symbol.iterator]() {\n        for (const dim_projections of product(...this.dim_indexers)) {\n            const chunk_coords = dim_projections.map((p) => p.dim_chunk_ix);\n            const mapping = dim_projections.map((p) => {\n                if (\"dim_out_sel\" in p) {\n                    return { from: p.dim_chunk_sel, to: p.dim_out_sel };\n                }\n                return { from: p.dim_chunk_sel, to: null };\n            });\n            yield { chunk_coords, mapping };\n        }\n    }\n}\n","import { BoolArray, ByteStringArray, UnicodeStringArray, } from \"@zarrita/typedarray\";\nimport { get as get_with_setter } from \"./get.js\";\nimport { set as set_with_setter } from \"./set.js\";\nfunction object_array_proxy(arr, offset = 0, lengthArg) {\n    let length = lengthArg ?? arr.length - offset;\n    return new Proxy(arr, {\n        get(target, prop) {\n            let idx = +prop;\n            if (!Number.isNaN(idx)) {\n                return target[offset + idx];\n            }\n            if (prop === \"subarray\") {\n                return (from, to = length) => {\n                    return object_array_proxy(target, offset + from, to - from);\n                };\n            }\n            if (prop === \"set\") {\n                return (source, start) => {\n                    for (let i = 0; i < source.length; i++) {\n                        target[offset + start + i] = source[i];\n                    }\n                };\n            }\n            return Reflect.get(target, prop);\n        },\n        set(target, idx, value) {\n            target[offset + Number(idx)] = value;\n            return true;\n        },\n    });\n}\nfunction string_array_proxy(arr) {\n    const StringArrayConstructor = arr.constructor.bind(null, arr.chars);\n    return new Proxy(arr, {\n        get(target, prop) {\n            let idx = +prop;\n            if (!Number.isNaN(idx)) {\n                return target.get(idx);\n            }\n            if (prop === \"subarray\") {\n                return (from, to = arr.length) => {\n                    return string_array_proxy(new StringArrayConstructor(target.buffer, target.byteOffset + arr.BYTES_PER_ELEMENT * from, to - from));\n                };\n            }\n            if (prop === \"set\") {\n                return (source, offset) => {\n                    for (let i = 0; i < source.length; i++) {\n                        target.set(offset + i, source.get(i));\n                    }\n                };\n            }\n            if (prop === \"fill\") {\n                return (value, start, end) => {\n                    for (let i = start; i < end; i++) {\n                        target.set(i, value);\n                    }\n                };\n            }\n            return Reflect.get(target, prop);\n        },\n        set(target, idx, value) {\n            target.set(Number(idx), value);\n            return true;\n        },\n    });\n}\nfunction compat(arr) {\n    let data = arr.data;\n    if (arr.data instanceof BoolArray) {\n        data = new Uint8Array(arr.data.buffer);\n    }\n    else if (arr.data instanceof ByteStringArray ||\n        arr.data instanceof UnicodeStringArray) {\n        data = string_array_proxy(arr.data);\n    }\n    else if (arr.data instanceof globalThis.Array) {\n        data = object_array_proxy(arr.data);\n    }\n    return {\n        data,\n        stride: arr.stride,\n    };\n}\nfunction cast_scalar(arr, value) {\n    if (arr.data instanceof BoolArray) {\n        return (value ? 1 : 0);\n    }\n    return value;\n}\nexport const setter = {\n    prepare(data, shape, stride) {\n        return { data, shape, stride };\n    },\n    set_scalar(dest, sel, value) {\n        set_scalar(compat(dest), sel, cast_scalar(dest, value));\n    },\n    set_from_chunk(dest, src, mapping) {\n        set_from_chunk(compat(dest), compat(src), mapping);\n    },\n};\n/** @category Utility */\nexport async function get(arr, selection = null, opts = {}) {\n    return get_with_setter(arr, selection, opts, setter);\n}\n/** @category Utility */\nexport async function set(arr, selection, value, opts = {}) {\n    return set_with_setter(arr, selection, value, opts, setter);\n}\nfunction indices_len(start, stop, step) {\n    if (step < 0 && stop < start) {\n        return Math.floor((start - stop - 1) / -step) + 1;\n    }\n    if (start < stop)\n        return Math.floor((stop - start - 1) / step) + 1;\n    return 0;\n}\nfunction set_scalar(out, out_selection, value) {\n    if (out_selection.length === 0) {\n        out.data[0] = value;\n        return;\n    }\n    const [slice, ...slices] = out_selection;\n    const [curr_stride, ...stride] = out.stride;\n    if (typeof slice === \"number\") {\n        const data = out.data.subarray(curr_stride * slice);\n        set_scalar({ data, stride }, slices, value);\n        return;\n    }\n    const [from, to, step] = slice;\n    const len = indices_len(from, to, step);\n    if (slices.length === 0) {\n        if (step === 1 && curr_stride === 1) {\n            out.data.fill(value, from, from + len);\n        }\n        else {\n            for (let i = 0; i < len; i++) {\n                out.data[curr_stride * (from + step * i)] = value;\n            }\n        }\n        return;\n    }\n    for (let i = 0; i < len; i++) {\n        const data = out.data.subarray(curr_stride * (from + step * i));\n        set_scalar({ data, stride }, slices, value);\n    }\n}\nfunction set_from_chunk(dest, src, projections) {\n    const [proj, ...projs] = projections;\n    const [dstride, ...dstrides] = dest.stride;\n    const [sstride, ...sstrides] = src.stride;\n    if (proj.from === null) {\n        if (projs.length === 0) {\n            dest.data[proj.to] = src.data[0];\n            return;\n        }\n        set_from_chunk({\n            data: dest.data.subarray(dstride * proj.to),\n            stride: dstrides,\n        }, src, projs);\n        return;\n    }\n    if (proj.to === null) {\n        if (projs.length === 0) {\n            dest.data[0] = src.data[proj.from];\n            return;\n        }\n        let view = {\n            data: src.data.subarray(sstride * proj.from),\n            stride: sstrides,\n        };\n        set_from_chunk(dest, view, projs);\n        return;\n    }\n    const [from, to, step] = proj.to;\n    const [sfrom, _, sstep] = proj.from;\n    const len = indices_len(from, to, step);\n    if (projs.length === 0) {\n        if (step === 1 && sstep === 1 && dstride === 1 && sstride === 1) {\n            dest.data.set(src.data.subarray(sfrom, sfrom + len), from);\n        }\n        else {\n            for (let i = 0; i < len; i++) {\n                dest.data[dstride * (from + step * i)] =\n                    src.data[sstride * (sfrom + sstep * i)];\n            }\n        }\n        return;\n    }\n    for (let i = 0; i < len; i++) {\n        set_from_chunk({\n            data: dest.data.subarray(dstride * (from + i * step)),\n            stride: dstrides,\n        }, {\n            data: src.data.subarray(sstride * (sfrom + i * sstep)),\n            stride: sstrides,\n        }, projs);\n    }\n}\n","export function strip_prefix(path) {\n    return path.slice(1);\n}\nexport function uri2href(url) {\n    let [protocol, rest] = (typeof url === \"string\" ? url : url.href).split(\"://\");\n    if (protocol === \"https\" || protocol === \"http\") {\n        return url;\n    }\n    if (protocol === \"gc\") {\n        return `https://storage.googleapis.com/${rest}`;\n    }\n    if (protocol === \"s3\") {\n        return `https://s3.amazonaws.com/${rest}`;\n    }\n    throw Error(\"Protocol not supported, got: \" + JSON.stringify(protocol));\n}\nexport function fetch_range(url, offset, length, opts = {}) {\n    if (offset !== undefined && length !== undefined) {\n        // merge request opts\n        opts = {\n            ...opts,\n            headers: {\n                ...opts.headers,\n                Range: `bytes=${offset}-${offset + length - 1}`,\n            },\n        };\n    }\n    return fetch(url, opts);\n}\n","import { fetch_range } from \"./util.js\";\nfunction resolve(root, path) {\n    const base = typeof root === \"string\" ? new URL(root) : root;\n    if (!base.pathname.endsWith(\"/\")) {\n        // ensure trailing slash so that base is resolved as _directory_\n        base.pathname += \"/\";\n    }\n    const resolved = new URL(path.slice(1), base);\n    // copy search params to new URL\n    resolved.search = base.search;\n    return resolved;\n}\nasync function handle_response(response) {\n    if (response.status === 404 || response.status === 403) {\n        return undefined;\n    }\n    if (response.status == 200 || response.status == 206) {\n        return new Uint8Array(await response.arrayBuffer());\n    }\n    throw new Error(`Unexpected response status ${response.status} ${response.statusText}`);\n}\nasync function fetch_suffix(url, suffix_length, init, use_suffix_request) {\n    if (use_suffix_request) {\n        return fetch(url, {\n            ...init,\n            headers: { ...init.headers, Range: `bytes=-${suffix_length}` },\n        });\n    }\n    let response = await fetch(url, { ...init, method: \"HEAD\" });\n    if (!response.ok) {\n        // will be picked up by handle_response\n        return response;\n    }\n    let content_length = response.headers.get(\"Content-Length\");\n    let length = Number(content_length);\n    return fetch_range(url, length - suffix_length, length, init);\n}\n/**\n * Readonly store based in the [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).\n * Must polyfill `fetch` for use in Node.js.\n *\n * ```typescript\n * import * as zarr from \"@zarrita/core\";\n * const store = new FetchStore(\"http://localhost:8080/data.zarr\");\n * const arr = await zarr.get(store, { kind: \"array\" });\n * ```\n */\nclass FetchStore {\n    url;\n    #overrides;\n    #use_suffix_request;\n    constructor(url, options = {}) {\n        this.url = url;\n        this.#overrides = options.overrides ?? {};\n        this.#use_suffix_request = options.useSuffixRequest ?? false;\n    }\n    #merge_init(overrides) {\n        return {\n            ...this.#overrides,\n            ...overrides,\n            headers: {\n                ...this.#overrides.headers,\n                ...overrides.headers,\n            },\n        };\n    }\n    async get(key, options = {}) {\n        let href = resolve(this.url, key).href;\n        let response = await fetch(href, this.#merge_init(options));\n        return handle_response(response);\n    }\n    async getRange(key, range, options = {}) {\n        let url = resolve(this.url, key);\n        let init = this.#merge_init(options);\n        let response;\n        if (\"suffixLength\" in range) {\n            response = await fetch_suffix(url, range.suffixLength, init, this.#use_suffix_request);\n        }\n        else {\n            response = await fetch_range(url, range.offset, range.length, init);\n        }\n        return handle_response(response);\n    }\n}\nexport default FetchStore;\n","/** Object format used when passing multiple requests to RequestQueue at once. */\n\nexport const DEFAULT_REQUEST_CANCEL_REASON = \"request cancelled\";\n\n/**\n * Internal object interface used by RequestQueue to store request metadata and callbacks.\n */\n\n/**\n * Manages a queue of asynchronous requests with unique string keys, which can be added to or cancelled.\n * If redundant requests with the same key are issued, the request action will only be run once per key\n * while the original request is still in the queue.\n */\nexport default class RequestQueue {\n  /**\n   * The maximum number of requests that can be handled concurrently.\n   * Once reached, additional requests will be queued up to run once a running request completes.\n   */\n\n  /**\n   * The maximum number of requests that can be handled concurrently if only low-priority requests are waiting. Set\n   * lower than `concurrencyLimit` to always leave space for high-priority requests. Cannot be set higher than\n   * `concurrencyLimit`.\n   */\n\n  /** A queue of requests that are ready to be executed, in order of request time. */\n\n  /** A queue of low-priority tasks that are ready to be executed. `queue` must be empty before any of these tasks run. */\n\n  /** Stores all requests, even those that are currently active. */\n\n  /** Stores requests whose actions are currently being run. */\n\n  /**\n   * Creates a new RequestQueue.\n   * @param maxActiveRequests The maximum number of requests that will be handled concurrently. This is 10 by default.\n   * @param maxLowPriorityRequests The maximum number of low-priority requests that will be handled concurrently. Equal\n   *    to `maxActiveRequests` by default, but may be set lower to always leave space for new high-priority requests.\n   */\n  constructor(maxActiveRequests = 10, maxLowPriorityRequests = 5) {\n    this.allRequests = new Map();\n    this.activeRequests = new Set();\n    this.queue = [];\n    this.queueLowPriority = [];\n    this.maxActiveRequests = maxActiveRequests;\n    this.maxLowPriorityRequests = Math.min(maxActiveRequests, maxLowPriorityRequests);\n  }\n\n  /**\n   * Stores request metadata to the internal map of all pending requests.\n   * @param key string identifier of the request.\n   * @param requestAction callable function action of the request.\n   * @returns a reference to the new, registered RequestItem.\n   */\n  registerRequest(key, requestAction) {\n    // Create a new promise and store the resolve and reject callbacks for later.\n    // This lets us perform the actual action at a later point, when the request is at the\n    // front of the processing queue.\n    let promiseResolve, promiseReject;\n    const promise = new Promise((resolve, reject) => {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n    // Store the request data.\n    const requestItem = {\n      key: key,\n      action: requestAction,\n      resolve: promiseResolve,\n      reject: promiseReject,\n      promise\n    };\n    this.allRequests.set(key, requestItem);\n    return requestItem;\n  }\n\n  /**\n   * Moves a registered request into the processing queue, clearing any timeouts on the request.\n   * @param key string identifier of the request.\n   * @param lowPriority Whether this request should be added with low priority. False by default.\n   */\n  addRequestToQueue(key, lowPriority) {\n    // Check that this request is not cancelled.\n    if (this.allRequests.has(key)) {\n      // Clear the request timeout, if it has one, since it is being added to the queue.\n      const requestItem = this.allRequests.get(key);\n      if (requestItem && requestItem.timeoutId) {\n        clearTimeout(requestItem.timeoutId);\n        requestItem.timeoutId = undefined;\n      }\n      if (!this.queue.includes(key) && !this.queueLowPriority.includes(key)) {\n        // Add to queue and check if the request can be processed right away.\n        if (lowPriority) {\n          this.queueLowPriority.push(key);\n        } else {\n          this.queue.push(key);\n        }\n        this.dequeue();\n      }\n    }\n  }\n\n  /**\n   * Adds a request with a unique key to the queue, if it doesn't already exist.\n   * @param key The key used to track the request.\n   * @param requestAction Function that will be called to complete the request. The function\n   *  will be run only once per unique key while the request exists, and may be deferred by the\n   *  queue at any time.\n   * @param lowPriority Whether this request should be added with low priority. False by default.\n   * @param delayMs Minimum delay, in milliseconds, before this request should be executed.\n   *\n   * NOTE: Cancelling a request while the action is running WILL NOT stop the action. If this behavior is desired,\n   * actions must be responsible for checking the RequestQueue, determining if the request is still valid (e.g.\n   * using `.hasRequest()`), and stopping or returning early.\n   *\n   * @returns A promise that will resolve on completion of the request, or reject if the request is cancelled.\n   *  If multiple requests are issued with the same key, a promise for the first request will be returned\n   *  until the request is resolved or cancelled.\n   *  Note that the return type of the promise will match that of the first request's instance.\n   */\n  addRequest(key, requestAction, lowPriority = false, delayMs = 0) {\n    if (!this.allRequests.has(key)) {\n      // New request!\n      const requestItem = this.registerRequest(key, requestAction);\n      // If a delay is set, wait to add this to the queue.\n      if (delayMs > 0) {\n        const timeoutId = setTimeout(() => this.addRequestToQueue(key, lowPriority), delayMs);\n        // Save timeout information to request metadata\n        requestItem.timeoutId = timeoutId;\n      } else {\n        // No delay, add immediately\n        this.addRequestToQueue(key, lowPriority);\n      }\n    } else {\n      const lowPriorityIndex = this.queueLowPriority.indexOf(key);\n      if (lowPriorityIndex > -1 && !lowPriority) {\n        // This request is registered and queued, but is now being requested with high priority.\n        // Promote it to high priority.\n        this.queueLowPriority.splice(lowPriorityIndex, 1);\n        this.addRequestToQueue(key);\n      } else if (delayMs <= 0) {\n        // This request is registered, but is now being requested without a delay.\n        // Move into queue immediately if it's not already added, and clear any timeouts it may have.\n        this.addRequestToQueue(key, lowPriority);\n      }\n    }\n    const promise = this.allRequests.get(key)?.promise;\n    if (!promise) {\n      throw new Error(\"Found no promise to return when getting stored request data.\");\n    }\n    return promise;\n  }\n\n  /**\n   * Adds multiple requests to the queue, with an optional delay between each.\n   * @param requests An array of RequestItems, which include a key and a request action.\n   * @param lowPriority Whether these requests should be added with low priority. False by default.\n   * @param delayMs An optional minimum delay in milliseconds to be added between each request.\n   *  For example, a delay of 10 ms will cause the second request to be added to the processing queue\n   *  after 10 ms, the third to added after 20 ms, and so on. Set to 10 ms by default.\n   * @returns An array of promises corresponding to the provided requests. (i.e., the `i`th value\n   * of the returned array will be a Promise for the resolution of `requests[i]`). If a request\n   *  with a matching key is already pending, returns the promise for the initial request.\n   */\n  addRequests(requests, lowPriority = false, delayMs = 10) {\n    const promises = [];\n    for (let i = 0; i < requests.length; i++) {\n      const item = requests[i];\n      const promise = this.addRequest(item.key, item.requestAction, lowPriority, delayMs * i);\n      promises.push(promise);\n    }\n    return promises;\n  }\n\n  /**\n   * Attempts to remove and run the next queued request item, if resources are available.\n   * @returns true if a request was started, or false if there are too many\n   * requests already active.\n   */\n  async dequeue() {\n    const numRequests = this.activeRequests.size;\n    if (numRequests >= this.maxActiveRequests || this.queue.length === 0 && (numRequests >= this.maxLowPriorityRequests || this.queueLowPriority.length === 0)) {\n      return;\n    }\n    const requestKey = this.queue.shift() ?? this.queueLowPriority.shift();\n    if (!requestKey) {\n      return;\n    }\n    if (this.activeRequests.has(requestKey)) {\n      // This request is already active, try the next one instead. (this shouldn't happen)\n      this.dequeue();\n      return;\n    }\n    const requestItem = this.allRequests.get(requestKey);\n    if (!requestItem) {\n      return;\n    }\n    const key = requestItem.key;\n    // Mark that this request is active\n    this.activeRequests.add(key);\n    await requestItem.action().then(requestItem.resolve, requestItem.reject);\n    this.activeRequests.delete(key);\n    this.allRequests.delete(key);\n    this.dequeue();\n  }\n\n  /**\n   * Removes any request matching the provided key from the queue and rejects its promise.\n   * @param key The key that should be matched against.\n   * @param cancelReason A message or object that will be used as the promise rejection.\n   */\n  cancelRequest(key, cancelReason = DEFAULT_REQUEST_CANCEL_REASON) {\n    if (!this.allRequests.has(key)) {\n      return;\n    }\n    const requestItem = this.allRequests.get(key);\n    if (requestItem) {\n      if (requestItem.timeoutId) {\n        // Cancel requests that have not been queued yet.\n        clearTimeout(requestItem.timeoutId);\n      }\n      // Reject the request, then clear from the queue and known requests.\n      requestItem.reject(cancelReason);\n    }\n    const queueIndex = this.queue.indexOf(key);\n    if (queueIndex > -1) {\n      this.queue.splice(queueIndex, 1);\n    } else {\n      const lowPriorityIndex = this.queueLowPriority.indexOf(key);\n      if (lowPriorityIndex > -1) {\n        this.queueLowPriority.splice(lowPriorityIndex, 1);\n      }\n    }\n    this.allRequests.delete(key);\n    this.activeRequests.delete(key);\n  }\n\n  /**\n   * Rejects all request promises and clears the queue.\n   * @param cancelReason A message or object that will be used as the promise rejection.\n   */\n  cancelAllRequests(cancelReason = DEFAULT_REQUEST_CANCEL_REASON) {\n    // Clear the queue so we don't do extra work while filtering it\n    this.queue = [];\n    this.queueLowPriority = [];\n    for (const key of this.allRequests.keys()) {\n      this.cancelRequest(key, cancelReason);\n    }\n  }\n\n  /**\n   * Returns whether a request with the given key exists in the RequestQueue and is not cancelled.\n   * @param key the key to search for.\n   * @returns true if the request is in the RequestQueue.\n   */\n  hasRequest(key) {\n    return this.allRequests.has(key);\n  }\n\n  /**\n   * Returns whether the request with the given key is currently running (not waiting in the queue).\n   * @param key the key to search for.\n   * @returns true if the request is actively running.\n   */\n  requestRunning(key) {\n    return this.activeRequests.has(key);\n  }\n}","import RequestQueue from \"./RequestQueue.js\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * An extension of `RequestQueue` that adds a concept of \"subscribers,\" which may share references to a single request\n * or cancel their subscription without disrupting the request for other subscribers.\n */\nexport default class SubscribableRequestQueue {\n  /** The next unused subscriber ID. Increments whenever a subscriber is added. */\n\n  /**\n   * Map of subscribers keyed by ID. Subscribers store a map to all their subscriptions by request key.\n   * Subscribers are only useful as handles to cancel subscriptions early, so we only need to store rejecters here.\n   */\n\n  /** Map from \"inner\" request (managed by `queue`) to \"outer\" promises generated per-subscriber. */\n\n  /**\n   * Since `SubscribableRequestQueue` wraps `RequestQueue`, its constructor may either take the same arguments as the\n   * `RequestQueue` constructor and create a new `RequestQueue`, or it may take an existing `RequestQueue` to wrap.\n   */\n\n  constructor(maxActiveRequests, maxLowPriorityRequests) {\n    if (typeof maxActiveRequests === \"number\" || maxActiveRequests === undefined) {\n      this.queue = new RequestQueue(maxActiveRequests, maxLowPriorityRequests);\n    } else {\n      this.queue = maxActiveRequests;\n    }\n    this.nextSubscriberId = 0;\n    this.subscribers = new Map();\n    this.requests = new Map();\n  }\n\n  /** Resolves all subscriptions to request `key` with `value` */\n  resolveAll(key, value) {\n    const requests = this.requests.get(key);\n    if (requests) {\n      for (const {\n        resolve,\n        subscriberId\n      } of requests) {\n        resolve(value);\n        this.subscribers.get(subscriberId)?.delete(key);\n      }\n      this.requests.delete(key);\n    }\n  }\n\n  /** Rejects all subscriptions to request `key` with `reason` */\n  rejectAll(key, reason) {\n    const requests = this.requests.get(key);\n    if (requests) {\n      for (const {\n        reject,\n        subscriberId\n      } of requests) {\n        reject(reason);\n        this.subscribers.get(subscriberId)?.delete(key);\n      }\n      this.requests.delete(key);\n    }\n  }\n\n  /** Adds a new request subscriber. Returns a unique ID to identify this subscriber. */\n  addSubscriber() {\n    const subscriberId = this.nextSubscriberId;\n    this.nextSubscriberId++;\n    this.subscribers.set(subscriberId, new Map());\n    return subscriberId;\n  }\n\n  /**\n   * Queues a new request, or adds a subscription if the request is already queued/running.\n   *\n   * If `subscriberId` is already subscribed to the request, this rejects the existing promise and returns a new one.\n   */\n  addRequest(key, subscriberId, requestAction, lowPriority, delayMs) {\n    // Create single underlying request if it does not yet exist\n    this.queue.addRequest(key, requestAction, lowPriority, delayMs).then(value => this.resolveAll(key, value)).catch(reason => this.rejectAll(key, reason));\n    if (!this.requests.has(key)) {\n      this.requests.set(key, []);\n    }\n\n    // Validate subscriber\n    if (subscriberId >= this.nextSubscriberId || subscriberId < 0) {\n      throw new Error(`SubscribableRequestQueue: subscriber id ${subscriberId} has not been registered`);\n    }\n    const subscriber = this.subscribers.get(subscriberId);\n    if (!subscriber) {\n      throw new Error(`SubscribableRequestQueue: subscriber id ${subscriberId} has been removed`);\n    }\n\n    // Create promise and add to list of requests\n    return new Promise((resolve, reject) => {\n      this.requests.get(key)?.push({\n        resolve,\n        reject,\n        subscriberId\n      });\n      const subscriber = this.subscribers.get(subscriberId);\n      const existingRequest = subscriber?.get(key);\n      if (existingRequest) {\n        existingRequest.push(reject);\n      } else {\n        subscriber?.set(key, [reject]);\n      }\n    });\n  }\n\n  /**\n   * Rejects a subscription and removes it from the list of subscriptions for a request, then cancels the underlying\n   * request if it is no longer subscribed and is not running already.\n   */\n  rejectSubscription(key, reject, cancelReason) {\n    // Reject the outer \"subscription\" promise\n    reject(cancelReason);\n\n    // Get the list of subscriptions for this request\n    const subscriptions = this.requests.get(key);\n    if (!subscriptions) {\n      // This should never happen\n      return;\n    }\n    // Remove this request subscription by ref equality to `reject`\n    const idx = subscriptions.findIndex(sub => sub.reject === reject);\n    if (idx >= 0) {\n      subscriptions.splice(idx, 1);\n    }\n\n    // Remove the underlying request if there are no more subscribers and the request is not already running\n    if (subscriptions.length < 1 && !this.queue.requestRunning(key)) {\n      this.queue.cancelRequest(key, cancelReason);\n      this.requests.delete(key);\n    }\n  }\n\n  /** Cancels a request subscription, and cancels the underlying request if it is no longer subscribed or running. */\n  cancelRequest(key, subscriberId, cancelReason) {\n    const subscriber = this.subscribers.get(subscriberId);\n    if (!subscriber) {\n      return false;\n    }\n    const rejecters = subscriber.get(key);\n    if (!rejecters || !rejecters.length) {\n      return false;\n    }\n    for (const reject of rejecters) {\n      this.rejectSubscription(key, reject, cancelReason);\n    }\n    subscriber.delete(key);\n    return true;\n  }\n\n  /** Removes a subscriber and cancels its remaining subscriptions. */\n  removeSubscriber(subscriberId, cancelReason) {\n    const subscriptions = this.subscribers.get(subscriberId);\n    if (subscriptions) {\n      for (const [key, rejecters] of subscriptions.entries()) {\n        for (const reject of rejecters) {\n          this.rejectSubscription(key, reject, cancelReason);\n        }\n      }\n      this.subscribers.delete(subscriberId);\n    }\n  }\n\n  /** Returns whether a request with the given `key` is running or waiting in the queue */\n  hasRequest(key) {\n    return this.queue.hasRequest(key);\n  }\n\n  /** Returns whether a request with the given `key` is running */\n  requestRunning(key) {\n    return this.queue.requestRunning(key);\n  }\n\n  /** Returns whether a subscriber with the given `subscriberId` exists */\n  hasSubscriber(subscriberId) {\n    return this.subscribers.has(subscriberId);\n  }\n\n  /** Returns whether a subscriber with the given `subscriberId` is subscribed to the request with the given `key` */\n  isSubscribed(subscriberId, key) {\n    return this.subscribers.get(subscriberId)?.has(key) ?? false;\n  }\n}","const NBINS = 256;\n/**\n * Builds a histogram with 256 bins from a data array. Assume data is 8 bit single channel grayscale.\n * @class\n * @param {Array.<number>} data\n */\nexport default class Histogram {\n  // no more than 2^32 pixels of any one intensity in the data!?!?!\n\n  /** Min value in the original raw data. */\n\n  /** Max value in the original raw data. */\n\n  /** Size of each histogram bin in the scale of the original data. */\n\n  /** Index of the first bin (other than 0) with at least 1 value. */\n\n  /** Index of the last bin (other than 0) with at least 1 value. */\n\n  constructor(data) {\n    this.dataMinBin = 0;\n    this.dataMaxBin = 0;\n    this.maxBin = 0;\n    this.bins = new Uint32Array();\n    this.min = 0;\n    this.max = 0;\n    this.binSize = 0;\n\n    // build up the histogram\n    const hinfo = Histogram.calculateHistogram(data, NBINS);\n    this.bins = hinfo.bins;\n    this.min = hinfo.min;\n    this.max = hinfo.max;\n    this.binSize = hinfo.binSize;\n\n    // TODO: These should always return 0 and NBINS - 1, respectively. Test if these\n    // can be removed.\n    for (let i = 0; i < this.bins.length; i++) {\n      if (this.bins[i] > 0) {\n        this.dataMinBin = i;\n        break;\n      }\n    }\n    for (let i = this.bins.length - 1; i >= 0; i--) {\n      if (this.bins[i] > 0) {\n        this.dataMaxBin = i;\n        break;\n      }\n    }\n    this.pixelCount = data.length;\n\n    // get the bin with the most frequently occurring NONZERO value\n    this.maxBin = 1;\n    let max = this.bins[1];\n    for (let i = 1; i < this.bins.length; i++) {\n      if (this.bins[i] > max) {\n        this.maxBin = i;\n        max = this.bins[i];\n      }\n    }\n  }\n\n  // return the bin index of the given data value\n  static findBin(dataValue, dataMin, binSize, numBins) {\n    let binIndex = Math.floor((dataValue - dataMin) / binSize);\n    // for values that lie exactly on last bin we need to subtract one\n    if (binIndex === numBins) {\n      binIndex--;\n    }\n    return binIndex;\n  }\n\n  // return the bin index of the given data value\n  findBinOfValue(value) {\n    return Histogram.findBin(value, this.min, this.binSize, NBINS);\n  }\n\n  /**\n   * Return the min data value\n   * @return {number}\n   */\n  getDataMin() {\n    return this.min;\n  }\n\n  /**\n   * Return the max data value\n   * @return {number}\n   */\n  getDataMax() {\n    return this.max;\n  }\n\n  /**\n   * Returns the first bin index with at least 1 value, other than the 0th bin.\n   * @return {number}\n   */\n  getMin() {\n    return this.dataMinBin;\n  }\n\n  /**\n   * Returns the last bin index with at least 1 value, other than the 0th bin.\n   * @return {number}\n   */\n  getMax() {\n    // Note that this will always return `NBINS - 1`.\n    return this.dataMaxBin;\n  }\n  getNumBins() {\n    return this.bins.length;\n  }\n  getBin(i) {\n    return this.bins[i];\n  }\n  getBinRange(i) {\n    return [this.min + i * this.binSize, this.min + (i + 1) * this.binSize];\n  }\n\n  /**\n   * Find the bin that contains the percentage of pixels below it\n   * @return {number}\n   * @param {number} pct\n   */\n  findBinOfPercentile(pct) {\n    const limit = this.pixelCount * pct;\n    let i = 0;\n    let count = 0;\n    for (i = 0; i < this.bins.length; ++i) {\n      count += this.bins[i];\n      if (count > limit) {\n        break;\n      }\n    }\n    return i;\n  }\n\n  // Find bins at 10th / 90th percentile\n  findBestFitBins() {\n    const pixcount = this.pixelCount;\n    //const pixcount = this.imgData.data.length;\n    const limit = pixcount / 10;\n    let i = 0;\n    let count = 0;\n    for (i = 1; i < this.bins.length; ++i) {\n      count += this.bins[i];\n      if (count > limit) {\n        break;\n      }\n    }\n    const hmin = i;\n    count = 0;\n    for (i = this.bins.length - 1; i >= 1; --i) {\n      count += this.bins[i];\n      if (count > limit) {\n        break;\n      }\n    }\n    const hmax = i;\n    return [hmin, hmax];\n  }\n\n  // Find min and max bins attempting to replicate ImageJ's \"Auto\" button\n  findAutoIJBins() {\n    // note that consecutive applications of this should modify the auto threshold. see:\n    // https://github.com/imagej/ImageJ/blob/7746fcb0f5744a7a7758244c5dcd2193459e6e0e/ij/plugin/frame/ContrastAdjuster.java#L816\n    const AUTO_THRESHOLD = 5000;\n    const pixcount = this.pixelCount;\n    //  const pixcount = this.imgData.data.length;\n    const limit = pixcount / 10;\n    const threshold = pixcount / AUTO_THRESHOLD;\n\n    // this will skip the \"zero\" bin which contains pixels of zero intensity.\n    let hmin = this.bins.length - 1;\n    let hmax = 1;\n    for (let i = 1; i < this.bins.length; ++i) {\n      if (this.bins[i] > threshold && this.bins[i] <= limit) {\n        hmin = i;\n        break;\n      }\n    }\n    for (let i = this.bins.length - 1; i >= 1; --i) {\n      if (this.bins[i] > threshold && this.bins[i] <= limit) {\n        hmax = i;\n        break;\n      }\n    }\n    if (hmax < hmin) {\n      hmin = 0;\n      hmax = 255;\n    }\n    return [hmin, hmax];\n  }\n\n  // Find min and max bins using a percentile of the most commonly occurring value\n  findAutoMinMax() {\n    // simple linear mapping cutting elements with small appearence\n    // get 10% threshold\n    const PERCENTAGE = 0.1;\n    const th = Math.floor(this.bins[this.maxBin] * PERCENTAGE);\n    let b = 0;\n    let e = this.bins.length - 1;\n    for (let x = 1; x < this.bins.length; ++x) {\n      if (this.bins[x] > th) {\n        b = x;\n        break;\n      }\n    }\n    for (let x = this.bins.length - 1; x >= 1; --x) {\n      if (this.bins[x] > th) {\n        e = x;\n        break;\n      }\n    }\n    return [b, e];\n  }\n  static calculateHistogram(arr, numBins = 1) {\n    if (numBins < 1) {\n      numBins = 1;\n    }\n\n    // calculate min and max of arr\n    // TODO See convertChannel, which will also compute min and max!\n    // We could save a whole extra loop over the data, or have convertChannel compute the whole histogram.\n    // need to be careful about computing over chunks or whole ready-to-display volume\n\n    let min = arr[0];\n    let max = arr[0];\n    for (let i = 1; i < arr.length; i++) {\n      if (arr[i] < min) {\n        min = arr[i];\n      } else if (arr[i] > max) {\n        max = arr[i];\n      }\n    }\n    const bins = new Uint32Array(numBins).fill(0);\n    const binSize = (max - min) / numBins === 0 ? 1 : (max - min) / numBins;\n    for (let i = 0; i < arr.length; i++) {\n      const item = arr[i];\n      const binIndex = Histogram.findBin(item, min, binSize, numBins);\n      bins[binIndex]++;\n    }\n    return {\n      bins,\n      min,\n      max,\n      binSize\n    };\n  }\n}","export const defaultColors = [[255, 0, 255], [255, 255, 255], [0, 255, 255]];\n// 0 <= (h, s, v) <= 1\n// returns 0 <= (r, g, b) <= 255 rounded to nearest integer\n// you can also pass in just one arg as an object of {h, s, v} props.\nfunction HSVtoRGB(h, s, v) {\n  let r, g, b;\n  let hh = 0;\n  if (arguments.length === 1) {\n    const hsv = h;\n    s = hsv.s, v = hsv.v, hh = hsv.h;\n  } else {\n    hh = h;\n  }\n  const i = Math.floor(hh * 6);\n  const f = hh * 6 - i;\n  const p = v * (1 - s);\n  const q = v * (1 - f * s);\n  const t = v * (1 - (1 - f) * s);\n  switch (i % 6) {\n    case 0:\n      r = v, g = t, b = p;\n      break;\n    case 1:\n      r = q, g = v, b = p;\n      break;\n    case 2:\n      r = p, g = v, b = t;\n      break;\n    case 3:\n      r = p, g = q, b = v;\n      break;\n    case 4:\n      r = t, g = p, b = v;\n      break;\n    case 5:\n      r = v, g = p, b = q;\n      break;\n  }\n  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];\n}\n\n// 1993 Park-Miller LCG\nfunction LCG(s) {\n  return function () {\n    s = Math.imul(48271, s) | 0 % 2147483647;\n    return (s & 2147483647) / 2147483648;\n  };\n}\n// Use it like so:\nconst myrand = LCG(123);\n\n// if index exceeds defaultColors start choosing random ones\n// returns [r,g,b] 0-255 range\nexport const getColorByChannelIndex = index => {\n  if (!defaultColors[index]) {\n    defaultColors[index] = HSVtoRGB(myrand(), myrand() * 0.5 + 0.5, myrand() * 0.5 + 0.5);\n  }\n  return defaultColors[index];\n};","import { getColorByChannelIndex } from \"./constants/colors.js\";\nfunction clamp(val, cmin, cmax) {\n  return Math.min(Math.max(cmin, val), cmax);\n}\nfunction lerp(xmin, xmax, a) {\n  return a * (xmax - xmin) + xmin;\n}\n\n// We have an intensity value that is in the range of valueMin to valueMax.\n// This domain is assumed to have been remapped from oldMin to oldMax.\n// We now wish to find the intensity value that corresponds to the same relative position in the new domain of newMin to newMax.\n// For our Luts valueMin will always be 0, and valueMax will always be 255.\n// oldMin and oldMax will be the domain of the original raw data intensities.\n// newMin and newMax will be the domain of the new raw data intensities.\nfunction remapDomain(value, valueMin, valueMax, oldMin, oldMax, newMin, newMax) {\n  const pctOfRange = (value - valueMin) / (valueMax - valueMin);\n  const newValue = (newMax - newMin) * pctOfRange + newMin;\n  // now locate this value as a relative index in the old range\n  const pctOfOldRange = (newValue - oldMin) / (oldMax - oldMin);\n  const remapped = valueMin + pctOfOldRange * (valueMax - valueMin);\n  return remapped;\n}\n\n// We have an intensity value that is in the range of valueMin to valueMax.\n// The input value range is assumed to represent absolute intensity range oldMin to oldMax.\n// We now wish to find the new position of this intensity value\n// when the valueMin-valueMax represents absolute range newMin to newMax\n// After the remapping, the intensity value will be in the range of valueMin to valueMax.\n// For our Luts valueMin will always be 0, and valueMax will always be 255.\n// oldMin and oldMax will be the domain of the original raw data intensities.\n// newMin and newMax will be the domain of the new raw data intensities.\nfunction remapDomainForCP(value, valueMin, valueMax, oldMin, oldMax, newMin, newMax) {\n  const pctOfRange = (value - valueMin) / (valueMax - valueMin);\n  // find abs intensity from old range\n  const iOld = (oldMax - oldMin) * pctOfRange + oldMin;\n  // now locate this value as a relative index in the new range\n  const pctOfNewRange = (iOld - newMin) / (newMax - newMin);\n  const remapped = valueMin + pctOfNewRange * (valueMax - valueMin);\n  return remapped;\n}\nexport const LUT_ENTRIES = 256;\nexport const LUT_ARRAY_LENGTH = LUT_ENTRIES * 4;\n\n// @param {ControlPoint[]} controlPoints - array of {x:number 0..255, opacity:number 0..1, color:array of 3 numbers 0..255}\n// @return {Uint8Array} array of length len*4 representing the rgba values of the gradient\nfunction arrayFromControlPoints(controlPoints) {\n  // current assumption is that control point X values are in the range 0-255\n  // and they will be used directly as indices into the LUT.\n  // therefore the lut must have 256 entries.  Anything else and we have to remap the control points.\n  // TODO allow luts that have more or less entries.\n  const len = LUT_ENTRIES;\n  const lut = new Uint8Array(len * 4).fill(0);\n  if (controlPoints.length === 0) {\n    return lut;\n  }\n\n  // ensure they are sorted in ascending order of x\n  controlPoints.sort((a, b) => a.x - b.x);\n\n  // special case only one control point.\n  if (controlPoints.length === 1) {\n    const rgba = controlPointToRGBA(controlPoints[0]);\n    // lut was already filled with zeros\n    // copy val from x to 255.\n    const startx = clamp(controlPoints[0].x, 0, 255);\n    for (let x = startx; x < len; ++x) {\n      lut[x * 4 + 0] = rgba[0];\n      lut[x * 4 + 1] = rgba[1];\n      lut[x * 4 + 2] = rgba[2];\n      lut[x * 4 + 3] = rgba[3];\n    }\n    return lut;\n  }\n  let c0 = controlPoints[0];\n  let c1 = controlPoints[1];\n  let color0 = controlPointToRGBA(c0);\n  let color1 = controlPointToRGBA(c1);\n  let lastIndex = 1;\n  let a = 0;\n  for (let i = 0; i < len; ++i) {\n    // find the two control points that i is between\n    while (i > c1.x) {\n      // advance control points\n      c0 = c1;\n      color0 = color1;\n      lastIndex++;\n      if (lastIndex >= controlPoints.length) {\n        // if the last control point is before 255, then we want to continue its value all the way to 255.\n        c1 = {\n          x: 255,\n          color: c1.color,\n          opacity: c1.opacity\n        };\n      } else {\n        c1 = controlPoints[lastIndex];\n      }\n      color1 = controlPointToRGBA(c1);\n    }\n    // find the lerp amount between the two control points\n    if (c1.x === c0.x) {\n      // use c1\n      a = 1.0;\n    } else {\n      a = (i - c0.x) / (c1.x - c0.x);\n    }\n    lut[i * 4 + 0] = clamp(lerp(color0[0], color1[0], a), 0, 255);\n    lut[i * 4 + 1] = clamp(lerp(color0[1], color1[1], a), 0, 255);\n    lut[i * 4 + 2] = clamp(lerp(color0[2], color1[2], a), 0, 255);\n    lut[i * 4 + 3] = clamp(lerp(color0[3], color1[3], a), 0, 255);\n  }\n  return lut;\n}\n\n/**\n * @typedef {Object} ControlPoint Used for the TF (transfer function) editor GUI.\n * Need to be converted to LUT for rendering.\n * @property {number} x The X Coordinate: an intensity value, normalized to the 0-255 range\n * @property {number} opacity The Opacity, from 0 to 1\n * @property {Array.<number>} color The Color, 3 numbers from 0-255 for r,g,b\n */\n\nfunction controlPointToRGBA(controlPoint) {\n  return [controlPoint.color[0], controlPoint.color[1], controlPoint.color[2], Math.floor(controlPoint.opacity * 255)];\n}\n\n// the intensity range will be 0-255,\n// which currently represents the range of the raw data. (not the dtype range)\nconst createFullRangeControlPoints = (opacityMin = 0, opacityMax = 1) => [{\n  x: 0,\n  opacity: opacityMin,\n  color: [255, 255, 255]\n}, {\n  x: 255,\n  opacity: opacityMax,\n  color: [255, 255, 255]\n}];\n\n/**\n * @typedef {Object} Lut Used for rendering. The start and end of the Lut represent the min and max of the data.\n * @property {Array.<number>} lut LUT_ARRAY_LENGTH element lookup table as array\n * (maps scalar intensity to a rgb color plus alpha, with each value from 0-255)\n * @property {Array.<ControlPoint>} controlPoints\n */\nexport class Lut {\n  constructor() {\n    this.lut = new Uint8Array(LUT_ARRAY_LENGTH);\n    this.controlPoints = [];\n    this.createFullRange();\n  }\n\n  /**\n   * Generate a piecewise linear lookup table that ramps up from 0 to 1 over the b to e domain.\n   * If e === b, then we use a step function with f(b) = 0 and f(b + 1) = 1\n   *  |\n   * 1|               +---------+-----\n   *  |              /\n   *  |             /\n   *  |            /\n   *  |           /\n   *  |          /\n   * 0+=========+---------------+-----\n   *  0         b    e         255\n   * @return {Lut}\n   * @param {number} b\n   * @param {number} e\n   */\n  createFromMinMax(b, e) {\n    if (e < b) {\n      // swap\n      const tmp = e;\n      e = b;\n      b = tmp;\n    }\n\n    // Edge case: b and e are both out of bounds\n    if (b < 0 && e < 0) {\n      this.controlPoints = createFullRangeControlPoints(1, 1);\n      return this.createFromControlPoints(this.controlPoints);\n    }\n    if (b >= 255 && e >= 255) {\n      this.controlPoints = createFullRangeControlPoints(0, 0);\n      return this.createFromControlPoints(this.controlPoints);\n    }\n\n    // Generate 2 to 4 control points for a minMax LUT, from left to right\n    const controlPoints = [];\n\n    // Add starting point at x = 0\n    let startVal = 0;\n    if (b < 0) {\n      startVal = -b / (e - b);\n    }\n    controlPoints.push({\n      x: 0,\n      opacity: startVal,\n      color: [255, 255, 255]\n    });\n\n    // If b > 0, add another point at (b, 0)\n    if (b > 0) {\n      controlPoints.push({\n        x: b,\n        opacity: 0,\n        color: [255, 255, 255]\n      });\n    }\n\n    // If e < 255, Add another point at (e, 1)\n    if (e < 255) {\n      if (e === b) {\n        // Use b + 0.5 as x value instead of e to create a near-vertical ramp\n        controlPoints.push({\n          x: b + 0.5,\n          opacity: 1,\n          color: [255, 255, 255]\n        });\n      } else {\n        controlPoints.push({\n          x: e,\n          opacity: 1,\n          color: [255, 255, 255]\n        });\n      }\n    }\n\n    // Add ending point at x = 255\n    let endVal = 1;\n    if (e > 255) {\n      endVal = (255 - b) / (e - b);\n    }\n    controlPoints.push({\n      x: 255,\n      opacity: endVal,\n      color: [255, 255, 255]\n    });\n    return this.createFromControlPoints(controlPoints);\n  }\n\n  // basically, the identity LUT with respect to opacity\n  createFullRange() {\n    this.controlPoints = createFullRangeControlPoints();\n    return this.createFromControlPoints(this.controlPoints);\n  }\n\n  /**\n   * Generate a Window/level lookup table\n   * @return {Lut}\n   * @param {number} wnd in 0..1 range\n   * @param {number} lvl in 0..1 range\n   */\n  createFromWindowLevel(wnd, lvl) {\n    // simple linear mapping for actual range\n    const b = lvl - wnd * 0.5;\n    const e = lvl + wnd * 0.5;\n    return this.createFromMinMax(b * 255, e * 255);\n  }\n\n  // @param {Object[]} controlPoints - array of {x:number 0..255, opacity:number 0..1, color:array of 3 numbers 0..255}\n  // @return {Uint8Array} array of length 256*4 representing the rgba values of the gradient\n  createFromControlPoints(controlPoints) {\n    this.lut = arrayFromControlPoints(controlPoints);\n    this.controlPoints = controlPoints;\n    return this;\n  }\n\n  /**\n   * Generate an \"equalized\" lookup table\n   * @return {Lut}\n   */\n  createFromEqHistogram(histogram) {\n    // TODO need to reconcile this if number of histogram bins is not equal to LUT_ENTRIES?\n\n    const map = [];\n    for (let i = 0; i < histogram.getNumBins(); ++i) {\n      map[i] = 0;\n    }\n\n    // summed area table?\n    map[0] = histogram.getBin(0);\n    for (let i = 1; i < histogram.getNumBins(); ++i) {\n      map[i] = map[i - 1] + histogram.getBin(i);\n    }\n    const div = map[map.length - 1] - map[0];\n    if (div > 0) {\n      // compute lut and track control points for the piecewise linear sections\n      const lutControlPoints = [{\n        x: 0,\n        opacity: 0,\n        color: [255, 255, 255]\n      }];\n      let slope = 0;\n      let lastSlope = 0;\n      let opacity = 0;\n      let lastOpacity = 0;\n      for (let i = 1; i < LUT_ENTRIES; ++i) {\n        lastOpacity = opacity;\n        opacity = clamp(Math.round(255 * (map[i] - map[0])), 0, 255);\n        slope = opacity - lastOpacity;\n        // if map[i]-map[i-1] is the same as map[i+1]-map[i] then we are in a linear segment and do not need a new control point\n        if (slope != lastSlope) {\n          lutControlPoints.push({\n            x: i - 1,\n            opacity: lastOpacity / 255.0,\n            color: [255, 255, 255]\n          });\n          lastSlope = slope;\n        }\n      }\n      lutControlPoints.push({\n        x: 255,\n        opacity: 1,\n        color: [255, 255, 255]\n      });\n      return this.createFromControlPoints(lutControlPoints);\n    } else {\n      // just reset to whole range in this case...?\n      return this.createFullRange();\n    }\n  }\n\n  /**\n   * Generate a lookup table with a different color per intensity value.\n   * This translates to a unique color per histogram bin with more than zero pixels.\n   * TODO THIS IS NOT THE EFFECT WE WANT.  Colorize should operate on actual data values, not histogram bins.\n   * @return {Lut}\n   */\n  createLabelColors(histogram) {\n    const lut = new Uint8Array(LUT_ARRAY_LENGTH).fill(0);\n    const controlPoints = [];\n    // assume zero is No Label\n    controlPoints.push({\n      x: 0,\n      opacity: 0,\n      color: [0, 0, 0]\n    });\n    let lastr = 0;\n    let lastg = 0;\n    let lastb = 0;\n    let lasta = 0;\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    let a = 0;\n\n    // assumes exactly one color per bin\n    for (let i = 1; i < LUT_ENTRIES; ++i) {\n      const ibin = Math.floor(i / (LUT_ENTRIES - 1) * (histogram.getNumBins() - 1));\n      if (histogram.getBin(ibin) > 0) {\n        const rgb = getColorByChannelIndex(ibin);\n        lut[i * 4 + 0] = rgb[0];\n        lut[i * 4 + 1] = rgb[1];\n        lut[i * 4 + 2] = rgb[2];\n        lut[i * 4 + 3] = 255;\n        r = rgb[0];\n        g = rgb[1];\n        b = rgb[2];\n        a = 1;\n      } else {\n        // add a zero control point?\n        r = 0;\n        g = 0;\n        b = 0;\n        a = 0;\n        // lut was initialized to 0 so no need to set it here.\n      }\n      // if current control point is same as last one don't add it\n      if (r !== lastr || g !== lastg || b !== lastb || a !== lasta) {\n        if (lasta === 0) {\n          controlPoints.push({\n            x: i - 0.5,\n            opacity: lasta,\n            color: [lastr, lastg, lastb]\n          });\n        }\n        controlPoints.push({\n          x: i,\n          opacity: a,\n          color: [r, g, b]\n        });\n        lastr = r;\n        lastg = g;\n        lastb = b;\n        lasta = a;\n      }\n    }\n    this.lut = lut;\n    this.controlPoints = controlPoints;\n    return this;\n  }\n\n  // since this is not a \"create\" function, it doesn't need to return the object.\n  remapDomains(oldMin, oldMax, newMin, newMax) {\n    // no attempt is made here to ensure that lut and controlPoints are internally consistent.\n    // if they start out consistent, they should end up consistent. And vice versa.\n    this.lut = remapLut(this.lut, oldMin, oldMax, newMin, newMax);\n    this.controlPoints = remapControlPoints(this.controlPoints, oldMin, oldMax, newMin, newMax);\n  }\n}\n\n// If the new max is greater than the old max, then\n// the lut's max end will move inward to the left.\n// This is another way of saying that the new max's index is greater than 255 in the old lut\n// If the new min is less than the old min, then\n// the lut's min end will move inward to the right.\n// This is another way of saying that the new min's index is less than 0 in the old lut\nexport function remapLut(lut, oldMin, oldMax, newMin, newMax) {\n  const newLut = new Uint8Array(LUT_ARRAY_LENGTH);\n\n  // we will find what intensity is at each index in the new range,\n  // and then try to sample the pre-existing lut as if it spans the old range.\n  // Build new lut by sampling from old lut.\n  for (let i = 0; i < LUT_ENTRIES; ++i) {\n    let iOld = remapDomain(i, 0, LUT_ENTRIES - 1, oldMin, oldMax, newMin, newMax);\n    if (iOld < 0) {\n      iOld = 0;\n    }\n    if (iOld > LUT_ENTRIES - 1) {\n      iOld = LUT_ENTRIES - 1;\n    }\n    // find the indices above and below for interpolation\n    const i0 = Math.floor(iOld);\n    const i1 = Math.ceil(iOld);\n    const pct = iOld - i0;\n\n    //console.log(`interpolating ${iOld}: ${lut[i0 * 4 + 3]}, ${lut[i1 * 4 + 3]}, ${pct}`);\n    newLut[i * 4 + 0] = Math.round(lerp(lut[i0 * 4 + 0], lut[i1 * 4 + 0], pct));\n    newLut[i * 4 + 1] = Math.round(lerp(lut[i0 * 4 + 1], lut[i1 * 4 + 1], pct));\n    newLut[i * 4 + 2] = Math.round(lerp(lut[i0 * 4 + 2], lut[i1 * 4 + 2], pct));\n    newLut[i * 4 + 3] = Math.round(lerp(lut[i0 * 4 + 3], lut[i1 * 4 + 3], pct));\n  }\n  return newLut;\n}\nexport function remapControlPoints(controlPoints, oldMin, oldMax, newMin, newMax, nudgeEndPoints = true) {\n  if (controlPoints.length === 0) {\n    return controlPoints;\n  }\n  const newControlPoints = [];\n\n  // Save the current position of control points at the ends of the list\n  const oldFirstX = controlPoints[0].x;\n  const oldLastX = controlPoints[controlPoints.length - 1].x;\n\n  // assume control point x domain 0-255 is mapped to oldMin-oldMax\n\n  // remap all cp x values.\n  // interpolate all new colors and opacities\n  // Do not clip values outside of 0-255. This is important to\n  // preserve information for remapping many consecutive times.\n  for (let i = 0; i < controlPoints.length; ++i) {\n    const cp = controlPoints[i];\n    const iOld = remapDomainForCP(cp.x, 0, LUT_ENTRIES - 1, oldMin, oldMax, newMin, newMax);\n    const newCP = {\n      x: iOld,\n      opacity: cp.opacity,\n      color: [cp.color[0], cp.color[1], cp.color[2]]\n    };\n    newControlPoints.push(newCP);\n  }\n  return nudgeEndPoints ? nudgeRemappedEndControlPoints(newControlPoints, oldFirstX, oldLastX) : newControlPoints;\n}\n\n/**\n * Attempts to keep the first and last control points in a remapped list in a sensible place if they were previously on\n * or outside the edge of the range.\n *\n * Commonly (e.g. in the output of nearly all the factory methods in `Lut`), the very first and last control points\n * just define a line of constant opacity out to the upper/lower edge of the range. Remapping these points naively\n * means that the range of the transfer function no longer matches the actual range of intensities. This isn't a\n * problem for producing a lut, but it does make things look weird. If it is possible to do so without losing\n * information, we should try to keep these points in place.\n *\n * In addition to a list of control points, this function requires the x coordinate of the end points _before_\n * remapping, to determine whether the points used to be at or outside the edges of the range.\n */\nfunction nudgeRemappedEndControlPoints(controlPoints, oldFirstX, oldLastX) {\n  const EPSILON = 0.0001;\n  const first = controlPoints[0];\n  const second = controlPoints[1];\n  const secondLast = controlPoints[controlPoints.length - 2];\n  const last = controlPoints[controlPoints.length - 1];\n  if (Math.abs(first.opacity - (second?.opacity ?? Infinity)) < EPSILON) {\n    if (first.x < 0) {\n      // control point is now out of bounds - clamp it to 0 (or as close as we can get without losing information)\n      first.x = Math.min(0, second.x - 1);\n    } else if (oldFirstX < EPSILON) {\n      // control point was at or below 0 and has moved inward - snap it to 0 to cover the full range\n      first.x = 0;\n    }\n  }\n  if (Math.abs(last.opacity - (secondLast?.opacity ?? Infinity)) < EPSILON) {\n    if (last.x > 255) {\n      // control point is now out of bounds - clamp it to 255 (or as close as we can get without losing information)\n      last.x = Math.max(255, secondLast.x + 1);\n    } else if (oldLastX > 255 - EPSILON) {\n      // control point was at or above 255 and has moved inward - snap it to 255 to cover the full range\n      last.x = 255;\n    }\n  }\n  return controlPoints;\n}","// numeric types compatible with zarrita.js.\n// see https://github.com/manzt/zarrita.js/blob/main/packages/core/src/metadata.ts\n\nexport const ARRAY_CONSTRUCTORS = {\n  int8: Int8Array,\n  int16: Int16Array,\n  int32: Int32Array,\n  int64: globalThis.BigInt64Array,\n  uint8: Uint8Array,\n  uint16: Uint16Array,\n  uint32: Uint32Array,\n  uint64: globalThis.BigUint64Array,\n  float32: Float32Array,\n  float64: Float64Array\n};\n/** If `FuseChannel.rgbColor` is this value, it is disabled from fusion. */\nexport const FUSE_DISABLED_RGB_COLOR = 0;\n\n/**\n * Provide options to control the visual appearance of a Volume\n * @typedef {Object} VolumeChannelDisplayOptions\n * @property {boolean} enabled array of boolean per channel\n * @property {Array.<number>} color array of rgb per channel\n * @property {Array.<number>} specularColor array of rgb per channel\n * @property {Array.<number>} emissiveColor array of rgb per channel\n * @property {number} glossiness array of float per channel\n * @property {boolean} isosurfaceEnabled array of boolean per channel\n * @property {number} isovalue array of number per channel\n * @property {number} isosurfaceOpacity array of number per channel\n * @example let options = {\n   };\n */\n\nexport let RenderMode = /*#__PURE__*/function (RenderMode) {\n  RenderMode[RenderMode[\"RAYMARCH\"] = 0] = \"RAYMARCH\";\n  RenderMode[RenderMode[\"PATHTRACE\"] = 1] = \"PATHTRACE\";\n  RenderMode[RenderMode[\"SLICE\"] = 2] = \"SLICE\";\n  return RenderMode;\n}({});\n\n/**\n * Provide options to control the visual appearance of a Volume\n * @typedef {Object} VolumeDisplayOptions\n * @property {Array.<VolumeChannelDisplayOptions>} channels array of channel display options\n * @property {number} density\n * @property {Array.<number>} translation xyz\n * @property {Array.<number>} rotation xyz angles in radians\n * @property {number} maskChannelIndex\n * @property {number} maskAlpha\n * @property {Array.<number>} clipBounds [xmin, xmax, ymin, ymax, zmin, zmax] all range from 0 to 1 as a percentage of the volume on that axis\n * @property {Array.<number>} scale xyz voxel size scaling\n * @property {boolean} maxProjection true or false (ray marching)\n * @property {number} renderMode 0 for raymarch, 1 for pathtrace\n * @property {number} shadingMethod 0 for phase, 1 for brdf, 2 for hybrid (path tracer)\n * @property {Array.<number>} gamma [min, max, scale]\n * @property {number} primaryRayStepSize in voxels\n * @property {number} secondaryRayStepSize in voxels\n * @property {boolean} showBoundingBox true or false\n * @property {Array.<number>} boundingBoxColor r,g,b for bounding box lines\n * @example let options = {\n   };\n */\n\nexport const isOrthographicCamera = def => def && def.isOrthographicCamera;\nexport const isPerspectiveCamera = def => def && def.isPerspectiveCamera;\nexport let ViewportCorner = /*#__PURE__*/function (ViewportCorner) {\n  ViewportCorner[\"TOP_LEFT\"] = \"top_left\";\n  ViewportCorner[\"TOP_RIGHT\"] = \"top_right\";\n  ViewportCorner[\"BOTTOM_LEFT\"] = \"bottom_left\";\n  ViewportCorner[\"BOTTOM_RIGHT\"] = \"bottom_right\";\n  return ViewportCorner;\n}({});\nexport const isTop = corner => corner === ViewportCorner.TOP_LEFT || corner === ViewportCorner.TOP_RIGHT;\nexport const isRight = corner => corner === ViewportCorner.TOP_RIGHT || corner === ViewportCorner.BOTTOM_RIGHT;\nexport const DATARANGE_UINT8 = [0, 255];","import { DataTexture, LuminanceFormat, RedFormat, RedIntegerFormat, UnsignedByteType, ByteType, FloatType, IntType, UnsignedIntType, ShortType, UnsignedShortType, RGBAFormat, LinearFilter, NearestFilter, UVMapping, ClampToEdgeWrapping } from \"three\";\nimport Histogram from \"./Histogram.js\";\nimport { Lut, LUT_ARRAY_LENGTH } from \"./Lut.js\";\nimport { ARRAY_CONSTRUCTORS } from \"./types.js\";\n// Data and processing for a single channel\nexport default class Channel {\n  constructor(name) {\n    this.loaded = false;\n    this.dtype = \"uint8\";\n    this.imgData = {\n      data: new Uint8Array(),\n      width: 0,\n      height: 0\n    };\n    this.rawMin = 0;\n    this.rawMax = 255;\n\n    // on gpu\n    this.dataTexture = new DataTexture(new Uint8Array(), 0, 0);\n    this.lutTexture = new DataTexture(new Uint8Array(LUT_ARRAY_LENGTH), 256, 1, RGBAFormat, UnsignedByteType);\n    this.lutTexture.minFilter = this.lutTexture.magFilter = LinearFilter;\n    this.lutTexture.generateMipmaps = false;\n    this.volumeData = new Uint8Array();\n    this.name = name;\n    this.histogram = new Histogram(new Uint8Array());\n    this.dims = [0, 0, 0];\n\n    // intensity remapping lookup table\n    this.lut = new Lut().createFromMinMax(0, 255);\n\n    // per-intensity color labeling (disabled initially)\n    this.colorPalette = new Uint8Array(LUT_ARRAY_LENGTH).fill(0);\n    // store in 0..1 range. 1 means fully colorPalette, 0 means fully lut.\n    this.colorPaletteAlpha = 0.0;\n  }\n\n  // rgbColor is [0..255, 0..255, 0..255]\n  combineLuts(rgbColor, out) {\n    const ret = out ? out : new Uint8Array(LUT_ARRAY_LENGTH);\n    if (!rgbColor) {\n      return ret;\n    }\n    const rgb = [rgbColor[0] / 255.0, rgbColor[1] / 255.0, rgbColor[2] / 255.0];\n    // colorPalette*alpha + rgb*lut*(1-alpha)\n    // a tiny bit faster for the edge cases\n    if (this.colorPaletteAlpha === 1.0) {\n      ret.set(this.colorPalette);\n    } else if (this.colorPaletteAlpha === 0.0) {\n      ret.set(this.lut.lut);\n      for (let i = 0; i < LUT_ARRAY_LENGTH / 4; ++i) {\n        ret[i * 4 + 0] *= rgb[0];\n        ret[i * 4 + 1] *= rgb[1];\n        ret[i * 4 + 2] *= rgb[2];\n      }\n    } else {\n      for (let i = 0; i < LUT_ARRAY_LENGTH / 4; ++i) {\n        ret[i * 4 + 0] = this.colorPalette[i * 4 + 0] * this.colorPaletteAlpha + this.lut.lut[i * 4 + 0] * (1.0 - this.colorPaletteAlpha) * rgb[0];\n        ret[i * 4 + 1] = this.colorPalette[i * 4 + 1] * this.colorPaletteAlpha + this.lut.lut[i * 4 + 1] * (1.0 - this.colorPaletteAlpha) * rgb[1];\n        ret[i * 4 + 2] = this.colorPalette[i * 4 + 2] * this.colorPaletteAlpha + this.lut.lut[i * 4 + 2] * (1.0 - this.colorPaletteAlpha) * rgb[2];\n        ret[i * 4 + 3] = this.colorPalette[i * 4 + 3] * this.colorPaletteAlpha + this.lut.lut[i * 4 + 3] * (1.0 - this.colorPaletteAlpha);\n      }\n    }\n    this.lutTexture.image.data.set(ret);\n    this.lutTexture.needsUpdate = true;\n    return ret;\n  }\n  setRawDataRange(min, max) {\n    // remap the lut which was based on rawMin and rawMax to new min and max\n    // If either of the min/max ranges are both zero, then we have undefined behavior and should\n    // not remap the lut.  This situation can happen at first load, for example,\n    // when one channel has arrived but others haven't.\n    if (!(this.rawMin === 0 && this.rawMax === 0) && !(min === 0 && max === 0)) {\n      this.lut.remapDomains(this.rawMin, this.rawMax, min, max);\n      this.rawMin = min;\n      this.rawMax = max;\n    }\n  }\n  getHistogram() {\n    return this.histogram;\n  }\n  getIntensity(x, y, z) {\n    return this.volumeData[x + y * this.dims[0] + z * (this.dims[0] * this.dims[1])];\n  }\n  normalizeRaw(val) {\n    return (val - this.rawMin) / (this.rawMax - this.rawMin);\n  }\n\n  // how to index into tiled texture atlas\n  getIntensityFromAtlas(x, y, z) {\n    const numXtiles = this.imgData.width / this.dims[0];\n    const tilex = z % numXtiles;\n    const tiley = Math.floor(z / numXtiles);\n    const offset = tilex * this.dims[0] + x + (tiley * this.dims[1] + y) * this.imgData.width;\n    return this.imgData.data[offset];\n  }\n  rebuildDataTexture(data, w, h) {\n    if (this.dataTexture) {\n      this.dataTexture.dispose();\n    }\n    let format = LuminanceFormat;\n    let dataType = UnsignedByteType;\n    let internalFormat = \"LUMINANCE\";\n    switch (this.dtype) {\n      case \"uint8\":\n        dataType = UnsignedByteType;\n        format = RedIntegerFormat;\n        internalFormat = \"R8UI\";\n        break;\n      case \"int8\":\n        dataType = ByteType;\n        format = RedIntegerFormat;\n        internalFormat = \"R8I\";\n        break;\n      case \"uint16\":\n        dataType = UnsignedShortType;\n        format = RedIntegerFormat;\n        internalFormat = \"R16UI\";\n        break;\n      case \"int16\":\n        dataType = ShortType;\n        format = RedIntegerFormat;\n        internalFormat = \"R16I\";\n        break;\n      case \"uint32\":\n        dataType = UnsignedIntType;\n        format = RedIntegerFormat;\n        internalFormat = \"R32UI\";\n        break;\n      case \"int32\":\n        dataType = IntType;\n        format = RedIntegerFormat;\n        internalFormat = \"R32I\";\n        break;\n      case \"float32\":\n        dataType = FloatType;\n        format = RedFormat;\n        internalFormat = \"R32F\";\n        break;\n      default:\n        console.warn(\"unsupported dtype for channel data\", this.dtype);\n        break;\n    }\n    this.dataTexture = new DataTexture(data, w, h, format, dataType, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, NearestFilter, NearestFilter);\n    this.dataTexture.internalFormat = internalFormat;\n    this.dataTexture.needsUpdate = true;\n  }\n\n  // give the channel fresh data and initialize from that data\n  // data is formatted as a texture atlas where each tile is a z slice of the volume\n  setFromAtlas(bitsArray, w, h, dtype, rawMin, rawMax, subregionSize) {\n    this.dtype = dtype;\n    this.imgData = {\n      data: bitsArray,\n      width: w,\n      height: h\n    };\n    this.rebuildDataTexture(this.imgData.data, w, h);\n    this.loaded = true;\n    this.histogram = new Histogram(bitsArray);\n\n    // reuse old lut but auto-remap it to new data range\n    this.setRawDataRange(rawMin, rawMax);\n    this.unpackFromAtlas(subregionSize.x, subregionSize.y, subregionSize.z);\n  }\n\n  // let's rearrange this.imgData.data into a 3d array.\n  // it is assumed to be coming in as a flat Uint8Array of size x*y*z\n  // with x*y*z layout (first row of first plane is the first data in the layout,\n  // then second row of first plane, etc)\n  unpackFromAtlas(x, y, z) {\n    const volimgdata = this.imgData.data;\n    this.dims = [x, y, z];\n    const ctor = ARRAY_CONSTRUCTORS[this.dtype];\n    this.volumeData = new ctor(x * y * z);\n    const numXtiles = this.imgData.width / x;\n    const atlasrow = this.imgData.width;\n    let tilex = 0,\n      tiley = 0,\n      tileoffset = 0,\n      tilerowoffset = 0,\n      destOffset = 0;\n    for (let i = 0; i < z; ++i) {\n      // tile offset\n      tilex = i % numXtiles;\n      tiley = Math.floor(i / numXtiles);\n      tileoffset = tilex * x + tiley * y * atlasrow;\n      for (let j = 0; j < y; ++j) {\n        tilerowoffset = j * atlasrow;\n        destOffset = i * (x * y) + j * x;\n        this.volumeData.set(volimgdata.subarray(tileoffset + tilerowoffset, tileoffset + tilerowoffset + x), destOffset);\n      }\n    }\n  }\n\n  // give the channel fresh volume data and initialize from that data\n  setFromVolumeData(bitsArray, vx, vy, vz, ax, ay, rawMin, rawMax, dtype) {\n    this.dims = [vx, vy, vz];\n    this.volumeData = bitsArray;\n    this.dtype = dtype;\n    // TODO FIXME performance hit for shuffling the data and storing 2 versions of it (could do this in worker at least?)\n    this.packToAtlas(vx, vy, vz, ax, ay);\n    this.loaded = true;\n    // update from current histogram?\n    this.setRawDataRange(rawMin, rawMax);\n    this.histogram = new Histogram(this.volumeData);\n  }\n\n  // given this.volumeData, let's unpack it into a flat textureatlas and fill up this.imgData.\n  packToAtlas(vx, vy, vz, ax, ay) {\n    // big assumptions:\n    // atlassize is a perfect multiple of volumesize in both x and y\n    // ax % vx == 0\n    // ay % vy == 0\n    // and num slices <= num possible slices in atlas.\n    // (ax/vx) * (ay/vy) >= vz\n    if (ax % vx !== 0 || ay % vy !== 0 || ax / vx * (ay / vy) < vz) {\n      console.log(\"ERROR - atlas and volume dims are inconsistent\");\n      console.log(ax, ay, vx, vy, vz);\n    }\n    const ctor = ARRAY_CONSTRUCTORS[this.dtype];\n    this.imgData = {\n      width: ax,\n      height: ay,\n      data: new ctor(ax * ay)\n    };\n    this.imgData.data.fill(0);\n\n    // deposit slices one by one into the imgData.data from volData.\n    const volimgdata = this.imgData.data;\n    const x = vx,\n      y = vy,\n      z = vz;\n    const numXtiles = this.imgData.width / x;\n    const atlasrow = this.imgData.width;\n    let tilex = 0,\n      tiley = 0,\n      tileoffset = 0,\n      tilerowoffset = 0,\n      sourceOffset = 0;\n    for (let i = 0; i < z; ++i) {\n      // tile offset\n      tilex = i % numXtiles;\n      tiley = Math.floor(i / numXtiles);\n      tileoffset = tilex * x + tiley * y * atlasrow;\n      for (let j = 0; j < y; ++j) {\n        tilerowoffset = j * atlasrow;\n        sourceOffset = i * (x * y) + j * x;\n        volimgdata.set(this.volumeData.subarray(sourceOffset, sourceOffset + x), tileoffset + tilerowoffset);\n      }\n    }\n    this.rebuildDataTexture(this.imgData.data, ax, ay);\n  }\n  setLut(lut) {\n    this.lut = lut;\n  }\n\n  // palette should be an uint8array of 256*4 elements (256 rgba8 values)\n  setColorPalette(palette) {\n    this.colorPalette = palette;\n  }\n  setColorPaletteAlpha(alpha) {\n    this.colorPaletteAlpha = alpha;\n  }\n}","import { Vector3 } from \"three\";\nexport function defaultVolumeDims() {\n  return {\n    shape: [0, 0, 0, 0, 0],\n    spacing: [1, 1, 1, 1, 1],\n    spaceUnit: \"μm\",\n    timeUnit: \"s\",\n    dataType: \"uint8\"\n  };\n}\nexport function volumeSize(volumeDims) {\n  return new Vector3(volumeDims.shape[4], volumeDims.shape[3], volumeDims.shape[2]);\n}\nexport function physicalPixelSize(volumeDims) {\n  return new Vector3(volumeDims.spacing[4], volumeDims.spacing[3], volumeDims.spacing[2]);\n}","import { volumeSize, physicalPixelSize } from \"./VolumeDims.js\";\nimport { Vector3, Vector2 } from \"three\";\nexport function defaultImageInfo() {\n  return {\n    name: \"\",\n    atlasTileDims: [1, 1],\n    subregionSize: [1, 1, 1],\n    subregionOffset: [0, 0, 0],\n    combinedNumChannels: 1,\n    channelNames: [\"0\"],\n    channelColors: [[255, 255, 255]],\n    multiscaleLevel: 0,\n    multiscaleLevelDims: [{\n      shape: [1, 1, 1, 1, 1],\n      spacing: [1, 1, 1, 1, 1],\n      spaceUnit: \"\",\n      timeUnit: \"\",\n      dataType: \"uint8\"\n    }],\n    transform: {\n      translation: [0, 0, 0],\n      rotation: [0, 0, 0],\n      scale: [1, 1, 1]\n    }\n  };\n}\nexport class CImageInfo {\n  constructor(imageInfo) {\n    this.imageInfo = imageInfo || defaultImageInfo();\n  }\n  get currentLevelDims() {\n    return this.imageInfo.multiscaleLevelDims[this.imageInfo.multiscaleLevel];\n  }\n\n  /** Number of channels in the image */\n  get numChannels() {\n    return this.imageInfo.combinedNumChannels;\n  }\n\n  /** XYZ size of the *original* (not downsampled) volume, in pixels */\n  get originalSize() {\n    return volumeSize(this.imageInfo.multiscaleLevelDims[0]);\n  }\n\n  /** Size of the volume, in pixels */\n  get volumeSize() {\n    return volumeSize(this.currentLevelDims);\n  }\n\n  /** Size of a single *original* (not downsampled) pixel, in spatial units */\n  get physicalPixelSize() {\n    return physicalPixelSize(this.imageInfo.multiscaleLevelDims[0]);\n  }\n\n  /** Symbol of physical spatial unit used by `physicalPixelSize` */\n  get spatialUnit() {\n    return this.imageInfo.multiscaleLevelDims[0].spaceUnit;\n  }\n\n  /** Number of timesteps in the time series, or 1 if the image is not a time series */\n  get times() {\n    // 0 is T\n    return this.currentLevelDims.shape[0];\n  }\n\n  /** Size of each timestep in temporal units */\n  get timeScale() {\n    // 0 is T\n    return this.currentLevelDims.spacing[0];\n  }\n\n  /** Symbol of physical time unit used by `timeScale` */\n  get timeUnit() {\n    return this.currentLevelDims.timeUnit;\n  }\n\n  /** Number of scale levels available for this volume */\n  get numMultiscaleLevels() {\n    return this.imageInfo.multiscaleLevelDims.length;\n  }\n\n  /** The names of each channel */\n  get channelNames() {\n    return this.imageInfo.channelNames;\n  }\n\n  /** Optional overrides to default channel colors, in 0-255 range */\n  get channelColors() {\n    return this.imageInfo.channelColors;\n  }\n\n  /** Size of the currently loaded subregion, in pixels */\n  get subregionSize() {\n    return new Vector3(...this.imageInfo.subregionSize);\n  }\n\n  /** Offset of the loaded subregion into the total volume, in pixels */\n  get subregionOffset() {\n    return new Vector3(...this.imageInfo.subregionOffset);\n  }\n  get multiscaleLevel() {\n    return this.imageInfo.multiscaleLevel;\n  }\n\n  /**\n   * XY dimensions of the texture atlas used by `RayMarchedAtlasVolume` and `Atlas2DSlice`, in number of z-slice\n   * tiles (not pixels). Chosen by the loader to lay out the 3D volume in the squarest possible 2D texture atlas.\n   */\n  get atlasTileDims() {\n    return new Vector2(...this.imageInfo.atlasTileDims);\n  }\n  get transform() {\n    return {\n      translation: new Vector3(...this.imageInfo.transform.translation),\n      rotation: new Vector3(...this.imageInfo.transform.rotation),\n      scale: new Vector3(...this.imageInfo.transform.scale)\n    };\n  }\n}\nexport function computeAtlasSize(imageInfo) {\n  const {\n    atlasTileDims\n  } = imageInfo;\n  const volDims = imageInfo.multiscaleLevelDims[imageInfo.multiscaleLevel];\n  // TCZYX: 4 = x, 3 = y\n  return [atlasTileDims[0] * volDims.shape[4], atlasTileDims[1] * volDims.shape[3]];\n}","import { Box3, Vector2, Vector3 } from \"three\";\nimport { CImageInfo } from \"../ImageInfo.js\";\nexport const MAX_ATLAS_EDGE = 4096;\n\n// Map from units to their symbols\nconst UNIT_SYMBOLS = {\n  angstrom: \"Å\",\n  day: \"d\",\n  foot: \"ft\",\n  hour: \"h\",\n  inch: \"in\",\n  meter: \"m\",\n  micron: \"μm\",\n  mile: \"mi\",\n  minute: \"min\",\n  parsec: \"pc\",\n  second: \"s\",\n  yard: \"yd\"\n};\n\n// Units which may take SI prefixes (e.g. micro-, tera-)\nconst SI_UNITS = [\"meter\", \"second\"];\n\n// SI prefixes which abbreviate in nonstandard ways\nconst SI_PREFIX_ABBVS = {\n  micro: \"μ\",\n  deca: \"da\"\n};\n\n/** Converts a full spatial or temporal unit name supported by OME-Zarr to its unit symbol */\n// (see https://ngff.openmicroscopy.org/latest/#axes-md)\nexport function unitNameToSymbol(unitName) {\n  if (unitName === undefined) {\n    return null;\n  }\n  if (UNIT_SYMBOLS[unitName]) {\n    return UNIT_SYMBOLS[unitName];\n  }\n  const prefixedSIUnit = SI_UNITS.find(siUnit => unitName.endsWith(siUnit));\n  if (prefixedSIUnit) {\n    const prefix = unitName.substring(0, unitName.length - prefixedSIUnit.length);\n    if (SI_PREFIX_ABBVS[prefix]) {\n      // \"special\" SI prefix\n      return SI_PREFIX_ABBVS[prefix] + UNIT_SYMBOLS[prefixedSIUnit];\n    }\n\n    // almost all SI prefixes are abbreviated by first letter, capitalized if prefix ends with \"a\"\n    const capitalize = prefix.endsWith(\"a\");\n    const prefixAbbr = capitalize ? prefix[0].toUpperCase() : prefix[0];\n    return prefixAbbr + UNIT_SYMBOLS[prefixedSIUnit];\n  }\n  return null;\n}\n\n// We want to find the most \"square\" packing of z tw by th tiles.\n// Compute number of rows and columns.\nexport function computePackedAtlasDims(z, tw, th) {\n  let nextrows = 1;\n  let nextcols = z;\n  let ratio = nextcols * tw / (nextrows * th);\n  let nrows = nextrows;\n  let ncols = nextcols;\n  while (ratio > 1) {\n    nrows = nextrows;\n    ncols = nextcols;\n    nextcols -= 1;\n    nextrows = Math.ceil(z / nextcols);\n    ratio = nextcols * tw / (nextrows * th);\n  }\n  return new Vector2(nrows, ncols);\n}\nfunction doesSpatialDimensionFitInAtlas(spatialDimZYX, maxAtlasEdge = MAX_ATLAS_EDGE) {\n  // Estimate atlas size\n  const x = spatialDimZYX[2];\n  const y = spatialDimZYX[1];\n  const z = spatialDimZYX[0];\n  const xtiles = Math.floor(maxAtlasEdge / x);\n  const ytiles = Math.floor(maxAtlasEdge / y);\n  return xtiles * ytiles >= z;\n}\n\n/** Picks the largest scale level that can fit into a texture atlas with edges no longer than `maxAtlasEdge`. */\nexport function estimateLevelForAtlas(spatialDimsZYX, maxAtlasEdge = MAX_ATLAS_EDGE) {\n  if (spatialDimsZYX.length <= 1) {\n    return 0;\n  }\n  for (let i = 0; i < spatialDimsZYX.length; ++i) {\n    // estimate atlas size:\n    if (doesSpatialDimensionFitInAtlas(spatialDimsZYX[i], maxAtlasEdge)) {\n      return i;\n    }\n  }\n  return undefined;\n}\nconst maxCeil = val => Math.max(Math.ceil(val), 1);\nconst scaleDims = (size, [z, y, x]) => [maxCeil(z * size.z), maxCeil(y * size.y), maxCeil(x * size.x)];\nexport function scaleDimsToSubregion(subregion, dims) {\n  const size = subregion.getSize(new Vector3());\n  return scaleDims(size, dims);\n}\nexport function scaleMultipleDimsToSubregion(subregion, dims) {\n  const size = subregion.getSize(new Vector3());\n  return dims.map(dim => scaleDims(size, dim));\n}\n\n/**\n * Picks the best scale level to load based on scale level dimensions and a `LoadSpec`. This calls\n * `estimateLevelForAtlas`, then accounts for `LoadSpec`'s scale level picking properties:\n * - `multiscaleLevel` imposes a minimum scale level (or *maximum* resolution level) to load\n * - `maxAtlasEdge` sets the maximum size of the texture atlas that may be produced by a load\n * - `scaleLevelBias` offsets the scale level index after the optimal level is picked based on `maxAtlasEdge`\n *\n *  This function assumes that `spatialDimsZYX` has already been appropriately scaled to match `loadSpec`'s `subregion`.\n */\nexport function pickLevelToLoadUnscaled(loadSpec, spatialDimsZYX) {\n  if (loadSpec.useExplicitLevel && loadSpec.multiscaleLevel !== undefined) {\n    // clamp to actual allowed level range\n    return Math.max(0, Math.min(spatialDimsZYX.length - 1, loadSpec.multiscaleLevel));\n  }\n  let levelToLoad = estimateLevelForAtlas(spatialDimsZYX, loadSpec.maxAtlasEdge);\n  // Check here for whether levelToLoad is within max atlas size?\n  if (levelToLoad !== undefined) {\n    levelToLoad = Math.max(levelToLoad + (loadSpec.scaleLevelBias ?? 0), loadSpec.multiscaleLevel ?? 0);\n    levelToLoad = Math.max(0, Math.min(spatialDimsZYX.length - 1, levelToLoad));\n    if (doesSpatialDimensionFitInAtlas(spatialDimsZYX[levelToLoad], loadSpec.maxAtlasEdge)) {\n      return levelToLoad;\n    }\n  }\n\n  // Level to load could not be loaded due to atlas size constraints.\n  if (levelToLoad === undefined) {\n    // No optimal level exists so choose the smallest level to report out\n    levelToLoad = spatialDimsZYX.length - 1;\n  }\n  const smallestDims = spatialDimsZYX[levelToLoad];\n  console.error(`Volume is too large; no multiscale level found that fits in preferred memory footprint. Selected level ${levelToLoad}  has dimensions `, smallestDims, `. Max atlas edge allowed is ${loadSpec.maxAtlasEdge}.`);\n  console.log(\"All available levels: \", spatialDimsZYX);\n  return levelToLoad;\n}\n\n/**\n * Picks the best scale level to load based on scale level dimensions and a `LoadSpec`. This calls\n * `estimateLevelForAtlas` and accounts for all properties of `LoadSpec` considered by\n * `pickLevelToLoadUnscaled`, and additionally scales the dimensions of the scale levels to account for the\n * `LoadSpec`'s `subregion` property.\n */\nexport function pickLevelToLoad(loadSpec, spatialDimsZYX) {\n  const scaledDims = scaleMultipleDimsToSubregion(loadSpec.subregion, spatialDimsZYX);\n  return pickLevelToLoadUnscaled(loadSpec, scaledDims);\n}\n\n/** Given the size of a volume in pixels, convert a `Box3` in the 0-1 range to pixels */\nexport function convertSubregionToPixels(region, size) {\n  const min = region.min.clone().multiply(size).floor();\n  const max = region.max.clone().multiply(size).ceil();\n\n  // ensure it's always valid to specify the same number at both ends and get a single slice\n  if (min.x === max.x && min.x < size.x) {\n    max.x += 1;\n  }\n  if (min.y === max.y && min.y < size.y) {\n    max.y += 1;\n  }\n  if (min.z === max.z && min.z < size.z) {\n    max.z += 1;\n  }\n  return new Box3(min, max);\n}\n\n/**\n * Return the subset of `container` specified by `region`, assuming that `region` contains fractional values (between 0\n * and 1). i.e. if `container`'s range on the X axis is 0-4 and `region`'s is 0.25-0.5, the result will have range 1-2.\n */\nexport function composeSubregion(region, container) {\n  const size = container.getSize(new Vector3());\n  const min = region.min.clone().multiply(size).add(container.min);\n  const max = region.max.clone().multiply(size).add(container.min);\n  return new Box3(min, max);\n}\nfunction isEmpty(obj) {\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// currently everything needed can come from the imageInfo\n// but in the future each IVolumeLoader could have a completely separate implementation.\nexport function buildDefaultMetadata(rawImageInfo) {\n  // wrap\n  const imageInfo = new CImageInfo(rawImageInfo);\n  const physicalSize = imageInfo.volumeSize.clone().multiply(imageInfo.physicalPixelSize);\n  const metadata = {};\n  metadata[\"Dimensions\"] = {\n    ...imageInfo.subregionSize\n  };\n  metadata[\"Original dimensions\"] = {\n    ...imageInfo.originalSize\n  };\n  metadata[\"Physical size\"] = {\n    x: physicalSize.x + imageInfo.spatialUnit,\n    y: physicalSize.y + imageInfo.spatialUnit,\n    z: physicalSize.z + imageInfo.spatialUnit\n  };\n  metadata[\"Physical size per pixel\"] = {\n    x: imageInfo.physicalPixelSize.x + imageInfo.spatialUnit,\n    y: imageInfo.physicalPixelSize.y + imageInfo.spatialUnit,\n    z: imageInfo.physicalPixelSize.z + imageInfo.spatialUnit\n  };\n  metadata[\"Multiresolution levels\"] = rawImageInfo.multiscaleLevelDims;\n  // TODO decide???? combined or not?\n  metadata[\"Channels\"] = rawImageInfo.combinedNumChannels; //imageInfo.numChannels;\n  metadata[\"Time series frames\"] = imageInfo.times || 1;\n  // don't add User data if it's empty\n  if (rawImageInfo.userData && !isEmpty(rawImageInfo.userData)) {\n    metadata[\"User data\"] = rawImageInfo.userData;\n  }\n  return metadata;\n}","import { Vector3 } from \"three\";\nimport Channel from \"./Channel.js\";\nimport { getColorByChannelIndex } from \"./constants/colors.js\";\nimport { LoadSpec } from \"./loaders/IVolumeLoader.js\";\nimport { MAX_ATLAS_EDGE, pickLevelToLoadUnscaled } from \"./loaders/VolumeLoaderUtils.js\";\nimport { CImageInfo, defaultImageInfo } from \"./ImageInfo.js\";\n/**\n * A renderable multichannel volume image with 8-bits per channel intensity values.\n * @class\n * @param {ImageInfo} imageInfo\n */\nexport default class Volume {\n  /** `LoadSpec` representing the minimum data required to display what's in the viewer (subregion, channels, etc.).\n   * Used to intelligently issue load requests whenever required by a state change. Modify with `updateRequiredData`.\n   */\n\n  /** The maximum of the measurements of 3 axes in physical units (pixels*physicalSize) */\n\n  /** The physical size of a voxel in the original level 0 volume */\n\n  /** The physical dims of the whole volume (not accounting for subregion) */\n\n  /** Normalized physical size of the whole volume (not accounting for subregion) */\n\n  constructor(imageInfo = defaultImageInfo(), loadSpec = new LoadSpec(), loader) {\n    this.loaded = false;\n    this.imageInfo = new CImageInfo(imageInfo);\n    // TODO: use getter?\n    this.name = imageInfo.name;\n    this.loadSpec = {\n      // Fill in defaults for optional properties\n      multiscaleLevel: 0,\n      scaleLevelBias: 0,\n      maxAtlasEdge: MAX_ATLAS_EDGE,\n      channels: Array.from({\n        length: this.imageInfo.numChannels\n      }, (_val, idx) => idx),\n      ...loadSpec\n    };\n    this.loadSpecRequired = {\n      ...this.loadSpec,\n      channels: this.loadSpec.channels.slice(),\n      subregion: this.loadSpec.subregion.clone()\n    };\n    this.loader = loader;\n    // imageMetadata to be filled in by Volume Loaders\n    this.imageMetadata = {};\n    this.normRegionSize = new Vector3(1, 1, 1);\n    this.normRegionOffset = new Vector3(0, 0, 0);\n    this.physicalSize = new Vector3(1, 1, 1);\n    this.physicalScale = 1;\n    this.normPhysicalSize = new Vector3(1, 1, 1);\n    this.physicalPixelSize = this.imageInfo.physicalPixelSize;\n    this.tickMarkPhysicalLength = 1;\n    this.setVoxelSize(this.physicalPixelSize);\n    this.numChannels = this.imageInfo.numChannels;\n    this.channelNames = this.imageInfo.channelNames.slice();\n    this.channelColorsDefault = this.imageInfo.channelColors ? this.imageInfo.channelColors.slice() : this.channelNames.map((name, index) => getColorByChannelIndex(index));\n    // fill in gaps\n    if (this.channelColorsDefault.length < this.imageInfo.numChannels) {\n      for (let i = this.channelColorsDefault.length - 1; i < this.imageInfo.numChannels; ++i) {\n        this.channelColorsDefault[i] = getColorByChannelIndex(i);\n      }\n    }\n    this.channels = [];\n    for (let i = 0; i < this.imageInfo.numChannels; ++i) {\n      const channel = new Channel(this.channelNames[i]);\n      this.channels.push(channel);\n      // TODO pass in channel constructor...\n      channel.dims = this.imageInfo.subregionSize.toArray();\n    }\n    this.physicalUnitSymbol = this.imageInfo.spatialUnit;\n    this.volumeDataObservers = [];\n  }\n  setUnloaded() {\n    this.loaded = false;\n    this.channels.forEach(channel => {\n      channel.loaded = false;\n    });\n  }\n  isLoaded() {\n    return this.loaded;\n  }\n  updateDimensions() {\n    const {\n      volumeSize,\n      subregionSize,\n      subregionOffset\n    } = this.imageInfo;\n    this.setVoxelSize(this.physicalPixelSize);\n    this.normRegionSize = subregionSize.clone().divide(volumeSize);\n    this.normRegionOffset = subregionOffset.clone().divide(volumeSize);\n  }\n\n  /** Returns `true` iff differences between `loadSpec` and `loadSpecRequired` indicate new data *must* be loaded. */\n  mustLoadNewData() {\n    return this.loadSpec.useExplicitLevel !== this.loadSpecRequired.useExplicitLevel ||\n    // explicit vs automatic level changed\n    this.loadSpec.time !== this.loadSpecRequired.time ||\n    // time point changed\n    !this.loadSpec.subregion.containsBox(this.loadSpecRequired.subregion) ||\n    // new subregion not contained in old\n    this.loadSpecRequired.channels.some(channel => !this.loadSpec.channels.includes(channel)) // new channel(s)\n    ;\n  }\n\n  /**\n   * Returns `true` iff differences between `loadSpec` and `loadSpecRequired` indicate a new load *may* get a\n   * different scale level than is currently loaded.\n   *\n   * This checks for changes in properties that *can*, but do not *always*, change the scale level the loader picks.\n   * For example, a smaller `subregion` *may* mean a higher scale level will fit within memory constraints, or it may\n   * not. A higher `scaleLevelBias` *may* nudge the volume into a higher scale level, or we may already be at the max\n   * imposed by `multiscaleLevel`.\n   */\n  mayLoadNewScaleLevel() {\n    return !this.loadSpec.subregion.equals(this.loadSpecRequired.subregion) || this.loadSpecRequired.maxAtlasEdge !== this.loadSpec.maxAtlasEdge || this.loadSpecRequired.multiscaleLevel !== this.loadSpec.multiscaleLevel || this.loadSpecRequired.scaleLevelBias !== this.loadSpec.scaleLevelBias;\n  }\n\n  /** Call on any state update that may require new data to be loaded (subregion, enabled channels, time, etc.) */\n  async updateRequiredData(required, onChannelLoaded) {\n    this.loadSpecRequired = {\n      ...this.loadSpecRequired,\n      ...required\n    };\n    let shouldReload = this.mustLoadNewData();\n\n    // If we're not reloading due to required data changes, check if we should load a new scale level\n    if (!shouldReload && this.mayLoadNewScaleLevel()) {\n      // Loaders should cache loaded dimensions so that this call blocks no more than once per valid `LoadSpec`.\n      const dims = await this.loadScaleLevelDims();\n      if (dims) {\n        const dimsZYX = dims.map(({\n          shape\n        }) => [shape[2], shape[3], shape[4]]);\n        // Determine which scale level *would* be loaded, and see if it's different than what we have\n        const levelToLoad = pickLevelToLoadUnscaled(this.loadSpecRequired, dimsZYX);\n        shouldReload = this.imageInfo.multiscaleLevel !== levelToLoad;\n      }\n    }\n    if (shouldReload) {\n      this.loadNewData(onChannelLoaded);\n    }\n  }\n  async loadScaleLevelDims() {\n    try {\n      return await this.loader?.loadDims(this.loadSpecRequired);\n    } catch (e) {\n      this.volumeDataObservers.forEach(observer => observer.onVolumeLoadError(this, e));\n      return undefined;\n    }\n  }\n\n  /**\n   * Loads new data as specified in `this.loadSpecRequired`. Clones `loadSpecRequired` into `loadSpec` to indicate\n   * that the data that *must* be loaded is now the data that *has* been loaded.\n   */\n  async loadNewData(onChannelLoaded) {\n    this.setUnloaded();\n    this.loadSpec = {\n      ...this.loadSpecRequired,\n      subregion: this.loadSpecRequired.subregion.clone()\n    };\n    try {\n      await this.loader?.loadVolumeData(this, undefined, onChannelLoaded);\n    } catch (e) {\n      this.volumeDataObservers.forEach(observer => observer.onVolumeLoadError(this, e));\n      throw e;\n    }\n  }\n\n  // we calculate the physical size of the volume (voxels*pixel_size)\n  // and then normalize to the max physical dimension\n  // NOTE: This function MUST be called to set up some important dimensional info\n  setVoxelSize(size) {\n    // only set the data if it is > 0.  zero is not an allowed value.\n    size.x = size.x > 0 ? size.x : 1.0;\n    size.y = size.y > 0 ? size.y : 1.0;\n    size.z = size.z > 0 ? size.z : 1.0;\n    this.physicalPixelSize = size;\n    this.physicalSize = this.imageInfo.originalSize.clone().multiply(this.physicalPixelSize);\n    // Volume is scaled such that its largest physical dimension is 1 world unit - save that dimension for conversions\n    this.physicalScale = Math.max(this.physicalSize.x, this.physicalSize.y, this.physicalSize.z);\n    // Compute the volume's max extent - scaled to max dimension.\n    this.normPhysicalSize = this.physicalSize.clone().divideScalar(this.physicalScale);\n    // While we're here, pick a power of 10 that divides into our max dimension a reasonable number of times\n    // and save it to be the length of tick marks in 3d.\n    this.tickMarkPhysicalLength = 10 ** Math.floor(Math.log10(this.physicalScale / 2));\n  }\n  setUnitSymbol(symbol) {\n    this.physicalUnitSymbol = symbol;\n  }\n\n  /** Computes the center of the volume subset */\n  getContentCenter() {\n    // center point: (normRegionSize / 2 + normRegionOffset - 0.5) * normPhysicalSize;\n    return this.normRegionSize.clone().divideScalar(2).add(this.normRegionOffset).subScalar(0.5).multiply(this.normPhysicalSize);\n  }\n  cleanup() {\n    // no op\n  }\n  getChannel(channelIndex) {\n    return this.channels[channelIndex];\n  }\n  onChannelLoaded(batch) {\n    // check to see if all channels are now loaded, and fire an event(?)\n    if (this.loadSpec.channels.every(channelIndex => this.channels[channelIndex].loaded)) {\n      this.loaded = true;\n    }\n    batch.forEach(channelIndex => this.channelLoadCallback?.(this, channelIndex));\n    this.volumeDataObservers.forEach(observer => observer.onVolumeData(this, batch));\n  }\n\n  /**\n   * Assign volume data via a 2d array containing the z slices as tiles across it.  Assumes that the incoming data is consistent with the image's pre-existing imageInfo tile metadata.\n   * @param {number} channelIndex\n   * @param {Uint8Array} atlasdata\n   * @param {number} atlaswidth\n   * @param {number} atlasheight\n   */\n  setChannelDataFromAtlas(channelIndex, atlasdata, atlaswidth, atlasheight, range, dtype = \"uint8\") {\n    this.channels[channelIndex].setFromAtlas(atlasdata, atlaswidth, atlasheight, dtype, range[0], range[1], this.imageInfo.subregionSize);\n    this.onChannelLoaded([channelIndex]);\n  }\n\n  // ASSUMES that this.channelData.options is already set and incoming data is consistent with it\n  /**\n   * Assign volume data as a 3d array ordered x,y,z. The xy size must be equal to tilewidth*tileheight from the imageInfo used to construct this Volume.  Assumes that the incoming data is consistent with the image's pre-existing imageInfo tile metadata.\n   * @param {number} channelIndex\n   * @param {Uint8Array} volumeData\n   */\n  setChannelDataFromVolume(channelIndex, volumeData, range, dtype = \"uint8\") {\n    const {\n      subregionSize,\n      atlasTileDims\n    } = this.imageInfo;\n    this.channels[channelIndex].setFromVolumeData(volumeData, subregionSize.x, subregionSize.y, subregionSize.z, atlasTileDims.x * subregionSize.x, atlasTileDims.y * subregionSize.y, range[0], range[1], dtype);\n    this.onChannelLoaded([channelIndex]);\n  }\n\n  // TODO: decide if this should update imageInfo or not. For now, leave imageInfo alone as the \"original\" data\n  /**\n   * Add a new channel ready to receive data from one of the setChannelDataFrom* calls.\n   * Name and color will be defaulted if not provided. For now, leave imageInfo alone as the \"original\" data\n   * @param {string} name\n   * @param {Array.<number>} color [r,g,b]\n   */\n  appendEmptyChannel(name, color) {\n    const idx = this.imageInfo.numChannels;\n    const chname = name || \"channel_\" + idx;\n    const chcolor = color || getColorByChannelIndex(idx);\n    this.numChannels += 1;\n    this.channelNames.push(chname);\n    this.channelColorsDefault.push(chcolor);\n    this.channels.push(new Channel(chname));\n    for (let i = 0; i < this.volumeDataObservers.length; ++i) {\n      this.volumeDataObservers[i].onVolumeChannelAdded(this, idx);\n    }\n    return idx;\n  }\n\n  /**\n   * Get a value from the volume data\n   * @return {number} the intensity value from the given channel at the given xyz location\n   * @param {number} c The channel index\n   * @param {number} x\n   * @param {number} y\n   * @param {number} z\n   */\n  getIntensity(c, x, y, z) {\n    return this.channels[c].getIntensity(x, y, z);\n  }\n\n  /**\n   * Get the 256-bin histogram for the given channel\n   * @return {Histogram} the histogram\n   * @param {number} c The channel index\n   */\n  getHistogram(c) {\n    return this.channels[c].getHistogram();\n  }\n\n  /**\n   * Set the lut for the given channel\n   * @param {number} c The channel index\n   * @param {Array.<number>} lut The lut as a 256 element array\n   */\n  setLut(c, lut) {\n    this.channels[c].setLut(lut);\n  }\n\n  /**\n   * Set the color palette for the given channel\n   * @param {number} c The channel index\n   * @param {Array.<number>} palette The colors as a 256 element array * RGBA\n   */\n  setColorPalette(c, palette) {\n    this.channels[c].setColorPalette(palette);\n  }\n\n  /**\n   * Set the color palette alpha multiplier for the given channel.\n   * This will blend between the ordinary color lut and this colorPalette lut.\n   * @param {number} c The channel index\n   * @param {number} alpha The alpha value as a number from 0 to 1\n   */\n  setColorPaletteAlpha(c, alpha) {\n    this.channels[c].setColorPaletteAlpha(alpha);\n  }\n\n  /**\n   * Return the intrinsic rotation associated with this volume (radians)\n   * @return {Array.<number>} the xyz Euler angles (radians)\n   */\n  getRotation() {\n    // default axis order is XYZ\n    return this.imageInfo.transform.rotation.toArray();\n  }\n\n  /**\n   * Return the intrinsic translation (pivot center delta) associated with this volume, in normalized volume units\n   * @return {Array.<number>} the xyz translation in normalized volume units\n   */\n  getTranslation() {\n    return this.voxelsToWorldSpace(this.imageInfo.transform.translation.toArray());\n  }\n\n  /**\n   * Return a translation in normalized volume units, given a translation in image voxels\n   * @return {Array.<number>} the xyz translation in normalized volume units\n   */\n  voxelsToWorldSpace(xyz) {\n    // ASSUME: xyz is in original (level 0) image voxels, compatible with physicalPixelSize.\n    // account for pixel_size and normalized scaling in the threejs volume representation we're using\n    const m = 1.0 / Math.max(this.physicalSize.x, Math.max(this.physicalSize.y, this.physicalSize.z));\n    return new Vector3().fromArray(xyz).multiply(this.physicalPixelSize).multiplyScalar(m).toArray();\n  }\n  addVolumeDataObserver(o) {\n    this.volumeDataObservers.push(o);\n  }\n  removeVolumeDataObserver(o) {\n    if (o) {\n      const i = this.volumeDataObservers.indexOf(o);\n      if (i !== -1) {\n        this.volumeDataObservers.splice(i, 1);\n      }\n    }\n  }\n  removeAllVolumeDataObservers() {\n    this.volumeDataObservers = [];\n  }\n}","import { Box3, Vector3 } from \"three\";\nimport Volume from \"../Volume.js\";\nimport { CImageInfo } from \"../ImageInfo.js\";\nimport { buildDefaultMetadata } from \"./VolumeLoaderUtils.js\";\nexport class LoadSpec {\n  time = 0;\n  /** The max size of a volume atlas that may be produced by a load. Used to pick the appropriate multiscale level. */\n\n  /** An optional bias added to the scale level index after the optimal level is picked based on `maxAtlasEdge`. */\n\n  /**\n   * The max scale level to load. Even when this is specified, the loader may pick a *lower* scale level based on\n   * limits imposed by `scaleLevelBias` and `maxAtlasEdge` (or their defaults if unspecified).\n   */\n\n  /** Subregion of volume to load. If not specified, the entire volume is loaded. Specify as floats between 0-1. */\n  subregion = new Box3(new Vector3(0, 0, 0), new Vector3(1, 1, 1));\n  /** Treat multiscaleLevel literally and don't use other constraints to change it.\n   * By default we will try to load the best level based on the maxAtlasEdge and scaleLevelBias,\n   * so this is false.\n   */\n  useExplicitLevel = false;\n}\nexport function loadSpecToString(spec) {\n  const {\n    min,\n    max\n  } = spec.subregion;\n  return `${spec.multiscaleLevel}:${spec.time}:x(${min.x},${max.x}):y(${min.y},${max.y}):z(${min.z},${max.z})`;\n}\n\n/**\n * @callback PerChannelCallback\n * @param {string} imageurl\n * @param {Volume} volume\n * @param {number} channelindex\n */\n\n/**\n * @callback RawChannelDataCallback - allow lists of channel indices and data arrays to be passed to the callback\n * @param {number[]} channelIndex - The indices of the channels that were loaded\n * @param {NumberType[]} dtype - The data type of the data arrays\n * @param {TypedArray<NumberType>[]} data - The raw data for each channel\n * @param {[number, number][]} ranges - The min and max values for each channel in their original range\n * @param {[number, number]} atlasDims - The dimensions of the atlas, if the data is in an atlas format\n */\n\n/**\n * Loads volume data from a source specified by a `LoadSpec`.\n *\n * Loaders may keep state for reuse between volume creation and volume loading, and should be kept alive until volume\n * loading is complete. (See `createVolume`)\n */\n\n/** Abstract class which allows loaders to accept and return types that are easier to transfer to/from a worker. */\nexport class ThreadableVolumeLoader {\n  /** Unchanged from `IVolumeLoader`. See that interface for details. */\n\n  /**\n   * Creates an `ImageInfo` object from a `LoadSpec`, which may be passed to the `Volume` constructor to create an\n   * empty volume that can accept data loaded with the given `LoadSpec`.\n   *\n   * Also returns a new `LoadSpec` that may have been modified from the input `LoadSpec` to reflect the constraints or\n   * abilities of the loader. This new `LoadSpec` should be used when constructing the `Volume`, _not_ the original.\n   */\n\n  /**\n   * Begins loading per-channel data for the volume specified by `imageInfo` and `loadSpec`.\n   *\n   * This function accepts two required callbacks. The first, `onUpdateVolumeMetadata`, should be called at most once\n   * to modify the `Volume`'s `imageInfo` and/or `loadSpec` properties based on changes made by this load. Actual\n   * loaded channel data is passed to `onData` as it is loaded.\n   *\n   * Depending on the loader, the array passed to `onData` may be in simple 3d dimension order or reflect a 2d atlas.\n   * If the latter, the dimensions of the atlas are passed as the third argument to `onData`.\n   *\n   * The returned promise should resolve when all data has been loaded, or reject if any error occurs while loading.\n   */\n\n  setPrefetchPriority(_directions) {\n    // no-op by default\n  }\n  syncMultichannelLoading(_sync) {\n    // default behavior is async, to update channels as they arrive, depending on each\n    // loader's implementation details.\n  }\n  updateFetchOptions(_options) {\n    // no-op by default\n  }\n  async createVolume(loadSpec, onChannelLoaded) {\n    const {\n      imageInfo,\n      loadSpec: adjustedLoadSpec\n    } = await this.createImageInfo(loadSpec);\n    const vol = new Volume(imageInfo, adjustedLoadSpec, this);\n    vol.channelLoadCallback = onChannelLoaded;\n    vol.imageMetadata = buildDefaultMetadata(imageInfo);\n    return vol;\n  }\n  async loadVolumeData(volume, loadSpecOverride, onChannelLoaded) {\n    const onUpdateMetadata = (imageInfo, loadSpec) => {\n      if (imageInfo) {\n        volume.imageInfo = new CImageInfo(imageInfo);\n        volume.updateDimensions();\n      }\n      volume.loadSpec = {\n        ...loadSpec,\n        ...spec\n      };\n    };\n    const onChannelData = (channelIndices, dtypes, dataArrays, ranges, atlasDims) => {\n      for (let i = 0; i < channelIndices.length; i++) {\n        const channelIndex = channelIndices[i];\n        const dtype = dtypes[i];\n        const data = dataArrays[i];\n        const range = ranges[i];\n        if (atlasDims) {\n          volume.setChannelDataFromAtlas(channelIndex, data, atlasDims[0], atlasDims[1], range, dtype);\n        } else {\n          volume.setChannelDataFromVolume(channelIndex, data, range, dtype);\n        }\n        onChannelLoaded?.(volume, channelIndex);\n      }\n    };\n    const spec = {\n      ...volume.loadSpec,\n      ...loadSpecOverride\n    };\n    return this.loadRawChannelData(volume.imageInfo.imageInfo, spec, onUpdateMetadata, onChannelData);\n  }\n}","const allEqual = arr => arr.every(v => v === arr[0]);\nconst pushN = (arr, val, n) => {\n  for (let i = 0; i < n; i++) {\n    arr.push(val);\n  }\n};\nconst directionToIndex = dir => {\n  const absDir = dir >> 1; // shave off sign bit to get index in TZYX\n  return absDir + Number(absDir !== 0); // convert TZYX -> TCZYX by skipping c (index 1)\n};\nfunction updateMinMax(val, minmax) {\n  if (val < minmax[0]) {\n    minmax[0] = val;\n  }\n  if (val > minmax[1]) {\n    minmax[1] = val;\n  }\n}\n\n/**\n * Since the user is most likely to want nearby data (in space or time) first, we should prefetch those chunks first.\n *\n * Given a list of just-loaded chunks and some bounds, `ChunkPrefetchIterator` iterates evenly outwards in T/Z/Y/X.\n */\n// NOTE: Assumes `chunks` form a rectangular prism! Will create gaps otherwise! (in practice they always should)\nexport default class ChunkPrefetchIterator {\n  constructor(chunks, tzyxMaxPrefetchOffset, tczyxChunksPerSource, priorityDirections, onlyPriorityDirections = false) {\n    // Get min and max chunk coordinates for T/Z/Y/X\n    const extrema = [[Infinity, -Infinity], [Infinity, -Infinity], [Infinity, -Infinity], [Infinity, -Infinity]];\n    for (const chunk of chunks) {\n      updateMinMax(chunk[0], extrema[0]);\n      updateMinMax(chunk[2], extrema[1]);\n      updateMinMax(chunk[3], extrema[2]);\n      updateMinMax(chunk[4], extrema[3]);\n    }\n\n    // Create `PrefetchDirectionState`s for each direction\n    this.directionStates = [];\n    this.priorityDirectionStates = [];\n\n    // iterating like this: direction is the index in the flattened entries\n    // and corresponds to our +T, -T, +Z, -Z, +Y, -Y, +X, -X directions in order\n    // because extrema is in TZYX order.\n    for (const [direction, start] of extrema.flat().entries()) {\n      const dimension = direction >> 1; // shave off sign bit to get index in TZYX\n      const tczyxIndex = dimension + Number(dimension !== 0); // convert TZYX -> TCZYX by skipping c (index 1)\n      let end;\n      if (direction & 1) {\n        // Positive direction - end is either the max coordinate in the fetched set plus the max offset in this\n        // dimension, or the max chunk coordinate in this dimension, whichever comes first\n        const endsPerSource = tczyxChunksPerSource.map(chunkDims => {\n          return Math.min(start + tzyxMaxPrefetchOffset[dimension], chunkDims[tczyxIndex] - 1);\n        });\n\n        // Save some time: if all sources have the same end, we can just store that\n        if (allEqual(endsPerSource)) {\n          end = endsPerSource[0];\n        } else {\n          // Otherwise, expand our ends per source array to ends per channel\n          end = [];\n          for (const [i, sourceEnd] of endsPerSource.entries()) {\n            pushN(end, sourceEnd, tczyxChunksPerSource[i][1]);\n          }\n        }\n        // end = Math.min(start + tzyxMaxPrefetchOffset[dimension], tczyxChunksPerDimension[dimension] - 1);\n      } else {\n        // Negative direction - end is either the min coordinate in the fetched set minus the max offset in this\n        // dimension, or 0, whichever comes first\n        end = Math.max(start - tzyxMaxPrefetchOffset[dimension], 0);\n      }\n      const directionState = {\n        direction,\n        start,\n        end,\n        chunks: []\n      };\n      if (priorityDirections && priorityDirections.includes(direction)) {\n        this.priorityDirectionStates.push(directionState);\n      } else {\n        // we have an option setting that can let us ignore non-priority directions\n        if (!onlyPriorityDirections) {\n          this.directionStates.push(directionState);\n        }\n      }\n    }\n\n    // Fill each `PrefetchDirectionState` with chunks at the border of the fetched set\n    for (const chunk of chunks) {\n      for (const dir of this.directionStates) {\n        if (chunk[directionToIndex(dir.direction)] === dir.start) {\n          dir.chunks.push(chunk);\n        }\n      }\n      for (const dir of this.priorityDirectionStates) {\n        if (chunk[directionToIndex(dir.direction)] === dir.start) {\n          dir.chunks.push(chunk);\n        }\n      }\n    }\n  }\n  static *iterateDirections(directions) {\n    let offset = 1;\n    while (directions.length > 0) {\n      // Remove directions in which we have reached the end (or, if per-channel ends, the end for all channels)\n      directions = directions.filter(dir => {\n        const end = Array.isArray(dir.end) ? Math.max(...dir.end) : dir.end;\n        if (dir.direction & 1) {\n          return dir.start + offset <= end;\n        } else {\n          return dir.start - offset >= end;\n        }\n      });\n\n      // Yield chunks one chunk farther out in every remaining direction\n      for (const dir of directions) {\n        const offsetDir = offset * (dir.direction & 1 ? 1 : -1);\n        for (const chunk of dir.chunks) {\n          // Skip this chunk if this channel has a specific per-channel end and we've reached it\n          if (Array.isArray(dir.end) && chunk[directionToIndex(dir.direction)] + offsetDir > dir.end[chunk[1]]) {\n            continue;\n          }\n          const newChunk = chunk.slice();\n          newChunk[directionToIndex(dir.direction)] += offsetDir;\n          yield newChunk;\n        }\n      }\n      offset += 1;\n    }\n  }\n  *[Symbol.iterator]() {\n    // Yield all chunks in priority direction(s) first, if any\n    if (this.priorityDirectionStates.length > 0) {\n      for (const chunk of ChunkPrefetchIterator.iterateDirections(this.priorityDirectionStates)) {\n        yield chunk;\n      }\n    }\n\n    // Then yield all chunks in other directions\n    for (const chunk of ChunkPrefetchIterator.iterateDirections(this.directionStates)) {\n      yield chunk;\n    }\n  }\n}","/**\n * `Readable` is zarrita's minimal abstraction for any source of data.\n * `WrappedStore` wraps another `Readable` and adds (optional) connections to `VolumeCache` and `RequestQueue`.\n */\nclass WrappedStore {\n  constructor(baseStore, cache, queue) {\n    this.baseStore = baseStore;\n    this.cache = cache;\n    this.queue = queue;\n  }\n  // Dummy implementation to make this class easier to use in tests\n  set(_key, _value) {\n    return Promise.resolve();\n  }\n  async getAndCache(key, cacheKey, opts) {\n    const result = await this.baseStore.get(key, opts);\n    if (this.cache && result) {\n      this.cache.insert(cacheKey, result);\n    }\n    return result;\n  }\n  async get(key, opts) {\n    const ZARR_EXTS = [\".zarray\", \".zgroup\", \".zattrs\", \"zarr.json\"];\n    if (!this.cache || ZARR_EXTS.some(s => key.endsWith(s))) {\n      return this.baseStore.get(key, opts?.options);\n    }\n    if (opts?.reportKey) {\n      opts.reportKey(key, opts.subscriber);\n    }\n    let keyPrefix = this.baseStore.url ?? \"\";\n    if (keyPrefix !== \"\" && !(keyPrefix instanceof URL) && !keyPrefix.endsWith(\"/\")) {\n      keyPrefix += \"/\";\n    }\n    const fullKey = keyPrefix + key.slice(1);\n\n    // Check the cache\n    const cacheResult = this.cache.get(fullKey);\n    if (cacheResult) {\n      return new Uint8Array(cacheResult);\n    }\n\n    // Not in cache; load the chunk and cache it\n    if (this.queue && opts) {\n      return this.queue.addRequest(fullKey, opts.subscriber, () => this.getAndCache(key, fullKey, opts?.options), opts.isPrefetch);\n    } else {\n      // Should we ever hit this code?  We should always have a request queue.\n      return this.getAndCache(key, fullKey, opts?.options);\n    }\n  }\n}\nexport default WrappedStore;","import { errorConstructors } from \"serialize-error\";\nimport { NodeNotFoundError, KeyError } from \"@zarrita/core\";\n// geotiff doesn't export its error types...\n\n/** Groups possible load errors into a few broad categories which we can give similar guidance to the user about. */\nexport let VolumeLoadErrorType = /*#__PURE__*/function (VolumeLoadErrorType) {\n  VolumeLoadErrorType[\"UNKNOWN\"] = \"unknown\";\n  VolumeLoadErrorType[\"NOT_FOUND\"] = \"not_found\";\n  VolumeLoadErrorType[\"TOO_LARGE\"] = \"too_large\";\n  VolumeLoadErrorType[\"LOAD_DATA_FAILED\"] = \"load_data_failed\";\n  VolumeLoadErrorType[\"INVALID_METADATA\"] = \"invalid_metadata\";\n  VolumeLoadErrorType[\"INVALID_MULTI_SOURCE_ZARR\"] = \"invalid_multi_source_zarr\";\n  return VolumeLoadErrorType;\n}({});\nexport class VolumeLoadError extends Error {\n  constructor(message, options) {\n    super(message, options);\n    this.name = \"VolumeLoadError\";\n    this.type = options?.type ?? VolumeLoadErrorType.UNKNOWN;\n  }\n}\n\n// serialize-error only ever calls an error constructor with zero arguments. The required `ErrorConstructor`\n// type is a bit too restrictive - as long as the constructor can be called with no arguments it's fine.\nerrorConstructors.set(\"NodeNotFoundError\", NodeNotFoundError);\nerrorConstructors.set(\"KeyError\", KeyError);\nerrorConstructors.set(\"VolumeLoadError\", VolumeLoadError);\n\n/** Curried function to re-throw an error wrapped in a `VolumeLoadError` with the given `message` and `type`. */\nexport function wrapVolumeLoadError(message = \"Unknown error occurred while loading volume data\", type = VolumeLoadErrorType.UNKNOWN, ignore) {\n  return e => {\n    if (ignore !== undefined && e === ignore) {\n      return e;\n    }\n    if (e instanceof VolumeLoadError) {\n      throw e;\n    }\n    console.log(`Error loading volume data: ${e}`);\n    throw new VolumeLoadError(message, {\n      type,\n      cause: e\n    });\n  };\n}","import { VolumeLoadErrorType, VolumeLoadError } from \"../VolumeLoadError.js\";\n/** Extracts channel names from a `ZarrSource`. Handles missing `omeroMetadata`. Does *not* resolve name collisions. */\nexport function getSourceChannelNames(src) {\n  if (src.omeroMetadata?.channels) {\n    return src.omeroMetadata.channels.map(({\n      label\n    }, idx) => label ?? `Channel ${idx + src.channelOffset}`);\n  }\n  const length = src.scaleLevels[0].shape[src.axesTCZYX[1]];\n  return Array.from({\n    length\n  }, (_, idx) => `Channel ${idx + src.channelOffset}`);\n}\n\n/** Turns `axesTCZYX` into the number of dimensions in the array */\nexport const getDimensionCount = ([t, c, z]) => 2 + Number(t > -1) + Number(c > -1) + Number(z > -1);\nexport function remapAxesToTCZYX(axes) {\n  const axesTCZYX = [-1, -1, -1, -1, -1];\n  const axisNames = [\"t\", \"c\", \"z\", \"y\", \"x\"];\n  axes.forEach((axis, idx) => {\n    const axisIdx = axisNames.indexOf(axis.name);\n    if (axisIdx > -1) {\n      axesTCZYX[axisIdx] = idx;\n    } else {\n      throw new VolumeLoadError(`Unrecognized axis in zarr: ${axis.name}`, {\n        type: VolumeLoadErrorType.INVALID_METADATA\n      });\n    }\n  });\n\n  // it is possible that Z might not exist but we require X and Y at least.\n  const noXAxis = axesTCZYX[4] === -1;\n  if (noXAxis || axesTCZYX[3] === -1) {\n    throw new VolumeLoadError(`Did not find ${noXAxis ? \"an X\" : \"a Y\"} axis in zarr`, {\n      type: VolumeLoadErrorType.INVALID_METADATA\n    });\n  }\n  return axesTCZYX;\n}\n\n/** Reorder an array of values [T, C, Z, Y, X] to the given dimension order */\nexport function orderByDimension(valsTCZYX, orderTCZYX) {\n  const specLen = getDimensionCount(orderTCZYX);\n  const result = Array(specLen);\n  orderTCZYX.forEach((val, idx) => {\n    if (val >= 0) {\n      if (val >= specLen) {\n        throw new VolumeLoadError(`Unexpected axis index in zarr: ${val}`, {\n          type: VolumeLoadErrorType.INVALID_METADATA\n        });\n      }\n      result[val] = valsTCZYX[idx];\n    }\n  });\n  return result;\n}\n\n/** Reorder an array of values in the given dimension order to [T, C, Z, Y, X] */\nexport function orderByTCZYX(valsDimension, orderTCZYX, defaultValue) {\n  const result = [defaultValue, defaultValue, defaultValue, defaultValue, defaultValue];\n  orderTCZYX.forEach((val, idx) => {\n    if (val >= 0) {\n      if (val >= valsDimension.length) {\n        throw new VolumeLoadError(`Unexpected axis index in zarr: ${val}`, {\n          type: VolumeLoadErrorType.INVALID_METADATA\n        });\n      }\n      result[idx] = valsDimension[val];\n    }\n  });\n  return result;\n}\n\n/** Select the scale transform from an OME metadata object with coordinate transforms, and return it in TCZYX order */\nexport function getScale(dataset, orderTCZYX) {\n  const transforms = dataset.coordinateTransformations;\n  if (transforms === undefined) {\n    console.warn(\"WARNING: OMEZarrLoader: no coordinate transformations for scale level.\");\n    return [1, 1, 1, 1, 1];\n  }\n\n  // this assumes we'll never encounter the \"path\" variant\n  const isScaleTransform = t => t.type === \"scale\";\n\n  // there can be any number of coordinateTransformations\n  // but there must be only one of type \"scale\".\n  const scaleTransform = transforms.find(isScaleTransform);\n  if (!scaleTransform) {\n    console.warn(`WARNING: OMEZarrLoader: no coordinate transformation of type \"scale\" for scale level.`);\n    return [1, 1, 1, 1, 1];\n  }\n  const scale = scaleTransform.scale.slice();\n  return orderByTCZYX(scale, orderTCZYX, 1);\n}\n\n/**\n * Defines a partial order of zarr arrays based on their size. Specifically:\n * - If array size x, y, z are all equal, the arrays are equal\n * - otherwise, if all xyz of `a` are less than or equal to those of `b`, `a` is less than `b` (and vice versa)\n * - if some xyz is less and some is greater, the arrays are uncomparable\n */\nfunction compareZarrArraySize(aArr, aTCZYX, bArr, bTCZYX) {\n  const aZ = aTCZYX[2] > -1 ? aArr.shape[aTCZYX[2]] : 1;\n  const bZ = bTCZYX[2] > -1 ? bArr.shape[bTCZYX[2]] : 1;\n  const diffZ = aZ - bZ;\n  const diffY = aArr.shape[aTCZYX[3]] - bArr.shape[bTCZYX[3]];\n  const diffX = aArr.shape[aTCZYX[4]] - bArr.shape[bTCZYX[4]];\n  if (diffZ === 0 && diffY === 0 && diffX === 0) {\n    return 0;\n  } else if (diffZ <= 0 && diffY <= 0 && diffX <= 0) {\n    return -1;\n  } else if (diffZ >= 0 && diffY >= 0 && diffX >= 0) {\n    return 1;\n  } else {\n    return undefined;\n  }\n}\nconst EPSILON = 0.00001;\nconst aboutEquals = (a, b) => Math.abs(a - b) < EPSILON;\nfunction scaleTransformsAreEqual(aSrc, aLevel, bSrc, bLevel) {\n  const aScale = getScale(aSrc.multiscaleMetadata.datasets[aLevel], aSrc.axesTCZYX);\n  const bScale = getScale(bSrc.multiscaleMetadata.datasets[bLevel], bSrc.axesTCZYX);\n  return aboutEquals(aScale[2], bScale[2]) && aboutEquals(aScale[3], bScale[3]) && aboutEquals(aScale[4], bScale[4]);\n}\n\n/**\n * Ensures that all scale levels in `sources` are matched up by size. More precisely: enforces that, for any scale\n * level `i`, the size of zarr array `s[i]` is equal for every source `s`. We accomplish this by removing any arrays\n * (and their associated OME dataset metadata) which don't match up in all sources.\n *\n * Note that this function modifies the input `sources` array rather than returning a new value.\n *\n * Assumes all sources have scale levels ordered by size from largest to smallest. (This should always be true for\n * compliant OME-Zarr data.)\n */\nexport function matchSourceScaleLevels(sources) {\n  if (sources.length < 2) {\n    return;\n  }\n\n  // Save matching scale levels and metadata here\n  const matchedLevels = Array.from({\n    length: sources.length\n  }, () => []);\n  const matchedMetas = Array.from({\n    length: sources.length\n  }, () => []);\n\n  // Start as many index counters as we have sources\n  const scaleIndexes = new Array(sources.length).fill(0);\n  while (scaleIndexes.every((val, idx) => val < sources[idx].scaleLevels.length)) {\n    // First pass: find the smallest source / determine if all sources are equal\n    let allEqual = true;\n    let smallestIdx = 0;\n    let smallestSrc = sources[0];\n    let smallestArr = smallestSrc.scaleLevels[scaleIndexes[0]];\n    for (let currentIdx = 1; currentIdx < sources.length; currentIdx++) {\n      const currentSrc = sources[currentIdx];\n      const currentArr = currentSrc.scaleLevels[scaleIndexes[currentIdx]];\n      const ordering = compareZarrArraySize(smallestArr, smallestSrc.axesTCZYX, currentArr, currentSrc.axesTCZYX);\n      if (!ordering) {\n        // Arrays are equal, or they are uncomparable\n        if (ordering === undefined) {\n          throw new VolumeLoadError(\"Incompatible zarr arrays: pixel dimensions are mismatched\", {\n            type: VolumeLoadErrorType.INVALID_MULTI_SOURCE_ZARR\n          });\n        }\n\n        // Now we know the arrays are equal, but they may still be invalid to match up because...\n        // ...they have different scale transformations\n        if (!scaleTransformsAreEqual(smallestSrc, scaleIndexes[smallestIdx], currentSrc, scaleIndexes[currentIdx])) {\n          // today we are going to treat this as a warning.\n          // For our implementation it is enough that the xyz pixel ranges are the same.\n          // Ideally scale*arraysize=physical size is really the quantity that should be equal, for combining two volume data sets as channels.\n          console.warn(\"Incompatible zarr arrays: scale levels of equal size have different scale transformations\");\n        }\n\n        // ...they have different numbers of timesteps\n        const largestT = smallestSrc.axesTCZYX[0] > -1 ? smallestArr.shape[smallestSrc.axesTCZYX[0]] : 1;\n        const currentT = currentSrc.axesTCZYX[0] > -1 ? currentArr.shape[currentSrc.axesTCZYX[0]] : 1;\n        if (largestT !== currentT) {\n          // we also treat this as a warning.\n          // In OmeZarrLoader we will take the minimum T size of all sources\n          console.warn(`Incompatible zarr arrays: different numbers of timesteps: ${largestT} vs ${currentT}`);\n        }\n      } else {\n        allEqual = false;\n        if (ordering > 0) {\n          smallestIdx = currentIdx;\n          smallestSrc = currentSrc;\n          smallestArr = currentArr;\n        }\n      }\n    }\n    if (allEqual) {\n      // We've found a matching set of scale levels! Save it and increment all indexes\n      for (let i = 0; i < scaleIndexes.length; i++) {\n        const currentSrc = sources[i];\n        const matchedScaleLevel = scaleIndexes[i];\n        matchedLevels[i].push(currentSrc.scaleLevels[matchedScaleLevel]);\n        matchedMetas[i].push(currentSrc.multiscaleMetadata.datasets[matchedScaleLevel]);\n        scaleIndexes[i] += 1;\n      }\n    } else {\n      // Increment the indexes of the sources which are larger than the smallest\n      for (const [idx, srcIdx] of scaleIndexes.entries()) {\n        const currentSrc = sources[idx];\n        const currentArr = currentSrc.scaleLevels[srcIdx];\n        const ordering = compareZarrArraySize(smallestArr, smallestSrc.axesTCZYX, currentArr, currentSrc.axesTCZYX);\n        if (ordering !== 0) {\n          scaleIndexes[idx] += 1;\n        }\n      }\n    }\n  }\n  if (sources[0].scaleLevels.length === 0) {\n    throw new VolumeLoadError(\"Incompatible zarr arrays: no sets of scale levels found that matched in all sources\", {\n      type: VolumeLoadErrorType.INVALID_MULTI_SOURCE_ZARR\n    });\n  }\n  for (let i = 0; i < sources.length; i++) {\n    sources[i].scaleLevels = matchedLevels[i];\n    sources[i].multiscaleMetadata.datasets = matchedMetas[i];\n  }\n}","import { VolumeLoadError, VolumeLoadErrorType } from \"../VolumeLoadError.js\";\nfunction isObjectWithProp(obj, prop) {\n  return typeof obj === \"object\" && obj !== null && prop in obj;\n}\nfunction assertMetadataHasProp(obj, prop, name = \"zarr\") {\n  if (!isObjectWithProp(obj, prop)) {\n    throw new VolumeLoadError(`${name} metadata is missing required entry \"${prop}\"`, {\n      type: VolumeLoadErrorType.INVALID_METADATA\n    });\n  }\n}\nfunction assertPropIsArray(obj, prop, name = \"zarr\") {\n  if (!Array.isArray(obj[prop])) {\n    throw new VolumeLoadError(`${name} metadata entry \"${prop}\" is not an array`, {\n      type: VolumeLoadErrorType.INVALID_METADATA\n    });\n  }\n}\n\n/**\n * Validates that the `OMEZarrMetadata` record `data` has the minimal amount of data required to open a volume. Since\n * we only ever open one multiscale, we only validate the multiscale metadata record at index `multiscaleIdx` here.\n * `name` is used in error messages to identify the source of the metadata.\n */\nexport function validateOMEZarrMetadata(data, multiscaleIdx = 0, name = \"zarr\") {\n  // data is an object with a key \"multiscales\", which is an array\n  assertMetadataHasProp(data, \"multiscales\", name);\n  assertPropIsArray(data, \"multiscales\", name);\n\n  // check that a multiscale metadata entry exists at `multiscaleIdx`\n  const multiscaleMeta = data.multiscales[multiscaleIdx];\n  if (!multiscaleMeta) {\n    throw new VolumeLoadError(`${name} metadata does not have requested multiscale level ${multiscaleIdx}`, {\n      type: VolumeLoadErrorType.INVALID_METADATA\n    });\n  }\n  const multiscaleMetaName = isObjectWithProp(multiscaleMeta, \"name\") ? ` (\"${multiscaleMeta.name})` : \"\";\n  const multiscaleName = `${name} multiscale ${multiscaleIdx}${multiscaleMetaName}`;\n\n  // multiscale has a key \"axes\", which is an array. Each axis has a \"name\".\n  assertMetadataHasProp(multiscaleMeta, \"axes\", multiscaleName);\n  assertPropIsArray(multiscaleMeta, \"axes\", multiscaleName);\n  multiscaleMeta.axes.forEach((axis, i) => assertMetadataHasProp(axis, \"name\", `${multiscaleName} axis ${i}`));\n\n  // multiscale has a key \"datasets\", which is an array. Each dataset has a \"path\".\n  assertMetadataHasProp(multiscaleMeta, \"datasets\", name);\n  assertPropIsArray(multiscaleMeta, \"datasets\", name);\n  multiscaleMeta.datasets.forEach((data, i) => assertMetadataHasProp(data, \"path\", `${multiscaleName} dataset ${i}`));\n}","import { Box3, Vector3 } from \"three\";\nimport * as zarr from \"@zarrita/core\";\nimport { get as zarrGet, slice } from \"@zarrita/indexing\";\n// Importing `FetchStore` from its home subpackage (@zarrita/storage) causes errors.\n// Getting it from the top-level package means we don't get its type. This is also a bug, but it's more acceptable.\nimport { FetchStore } from \"zarrita\";\nimport SubscribableRequestQueue from \"../utils/SubscribableRequestQueue.js\";\nimport { ThreadableVolumeLoader } from \"./IVolumeLoader.js\";\nimport { composeSubregion, computePackedAtlasDims, convertSubregionToPixels, pickLevelToLoad, unitNameToSymbol } from \"./VolumeLoaderUtils.js\";\nimport ChunkPrefetchIterator from \"./zarr_utils/ChunkPrefetchIterator.js\";\nimport WrappedStore from \"./zarr_utils/WrappedStore.js\";\nimport { getDimensionCount, getScale, getSourceChannelNames, matchSourceScaleLevels, orderByDimension, orderByTCZYX, remapAxesToTCZYX } from \"./zarr_utils/utils.js\";\nimport { VolumeLoadError, VolumeLoadErrorType, wrapVolumeLoadError } from \"./VolumeLoadError.js\";\nimport { validateOMEZarrMetadata } from \"./zarr_utils/validation.js\";\nconst CHUNK_REQUEST_CANCEL_REASON = \"chunk request cancelled\";\n\n// returns the converted data and the original min and max values\nfunction convertChannel(channelData, dtype) {\n  // get min and max\n  // TODO FIXME Histogram will also compute min and max!\n  let min = channelData[0];\n  let max = channelData[0];\n  for (let i = 0; i < channelData.length; i++) {\n    const val = channelData[i];\n    if (val < min) {\n      min = val;\n    }\n    if (val > max) {\n      max = val;\n    }\n  }\n  if (dtype === \"float64\") {\n    // convert to float32\n    const f32 = new Float32Array(channelData.length);\n    for (let i = 0; i < channelData.length; i++) {\n      f32[i] = channelData[i];\n    }\n    dtype = \"float32\";\n    channelData = f32;\n  }\n  return {\n    data: channelData,\n    dtype,\n    min,\n    max\n  };\n}\nconst DEFAULT_FETCH_OPTIONS = {\n  maxPrefetchDistance: [5, 5, 5, 5],\n  maxPrefetchChunks: 30\n};\nclass OMEZarrLoader extends ThreadableVolumeLoader {\n  /** The ID of the subscriber responsible for \"actual loads\" (non-prefetch requests) */\n\n  /** The ID of the subscriber responsible for prefetches, so that requests can be cancelled and reissued */\n\n  // TODO: this property should definitely be owned by `Volume` if this loader is ever used by multiple volumes.\n  //   This may cause errors or incorrect results otherwise!\n\n  syncChannels = false;\n  constructor(\n  /**\n   * Array of records, each containing the objects and metadata we need to load from one source of multiscale zarr\n   * data. See documentation on `ZarrSource` for more.\n   */\n  sources, /** Handle to a `SubscribableRequestQueue` for smart concurrency management and request cancelling/reissuing. */\n  requestQueue, /** Options to configure (pre)fetching behavior. */\n  fetchOptions = DEFAULT_FETCH_OPTIONS, /** Direction(s) to prioritize when prefetching. Stored separate from `fetchOptions` since it may be mutated. */\n  priorityDirections = []) {\n    super();\n    this.sources = sources;\n    this.requestQueue = requestQueue;\n    this.fetchOptions = fetchOptions;\n    this.priorityDirections = priorityDirections;\n  }\n\n  /**\n   * Creates a new `OMEZarrLoader`.\n   *\n   * @param urls The URL(s) of the OME-Zarr data to load. If `urls` is an array, the loader will attempt to find scale\n   *  levels with exactly the same size in every source. If matching level(s) are available, the loader will produce a\n   *  volume containing all channels from every provided zarr in the order they appear in `urls`. If no matching sets\n   *  of scale levels are available, creation fails.\n   * @param scenes The scene(s) to load from each URL. If `urls` is an array, `scenes` may either be an array of values\n   *  corresponding to each URL, or a single value to apply to all URLs. Default 0.\n   * @param cache A cache to use for storing fetched data. If not provided, a new cache will be created.\n   * @param queue A queue to use for managing requests. If not provided, a new queue will be created.\n   * @param fetchOptions Options to configure (pre)fetching behavior.\n   */\n  static async createLoader(urls, scenes = 0, cache, queue, fetchOptions) {\n    // Setup queue and store, get basic metadata\n    if (!queue) {\n      queue = new SubscribableRequestQueue(fetchOptions?.concurrencyLimit, fetchOptions?.prefetchConcurrencyLimit);\n    }\n    const urlsArr = Array.isArray(urls) ? urls : [urls];\n    const scenesArr = Array.isArray(scenes) ? scenes : [scenes];\n\n    // Create one `ZarrSource` per URL\n    const sourceProms = urlsArr.map(async (url, i) => {\n      const store = new WrappedStore(new FetchStore(url), cache, queue);\n      const root = zarr.root(store);\n      const group = await zarr.open(root, {\n        kind: \"group\"\n      }).catch(wrapVolumeLoadError(`Failed to open OME-Zarr data at ${url}`, VolumeLoadErrorType.NOT_FOUND));\n\n      // Pick scene (multiscale)\n      let scene = scenesArr[Math.min(i, scenesArr.length - 1)];\n      if (scene > group.attrs.multiscales?.length) {\n        console.warn(`WARNING: OMEZarrLoader: scene ${scene} is invalid. Using scene 0.`);\n        scene = 0;\n      }\n      validateOMEZarrMetadata(group.attrs, scene, urlsArr.length > 1 ? `Zarr source ${i}` : \"Zarr\");\n      const {\n        multiscales,\n        omero\n      } = group.attrs;\n      const multiscaleMetadata = multiscales[scene];\n\n      // Open all scale levels of multiscale\n      const lvlProms = multiscaleMetadata.datasets.map(({\n        path\n      }) => zarr.open(root.resolve(path), {\n        kind: \"array\"\n      }).catch(wrapVolumeLoadError(`Failed to open scale level ${path} of OME-Zarr data at ${url}`, VolumeLoadErrorType.NOT_FOUND)));\n      const scaleLevels = await Promise.all(lvlProms);\n      const axesTCZYX = remapAxesToTCZYX(multiscaleMetadata.axes);\n      return {\n        scaleLevels,\n        multiscaleMetadata,\n        omeroMetadata: omero,\n        axesTCZYX,\n        channelOffset: 0\n      };\n    });\n    const sources = await Promise.all(sourceProms);\n\n    // Set `channelOffset`s so we can match channel indices to sources\n    let channelCount = 0;\n    for (const s of sources) {\n      s.channelOffset = channelCount;\n      channelCount += s.omeroMetadata?.channels.length ?? s.scaleLevels[0].shape[s.axesTCZYX[1]];\n    }\n    // Ensure the sizes of all sources' scale levels are matched up. See this function's docs for more.\n    matchSourceScaleLevels(sources);\n    // TODO: if `matchSourceScaleLevels` returned successfully, every one of these sources' `multiscaleMetadata` is the\n    // same in every field we care about, so we only ever use the first source's `multiscaleMetadata` after this point.\n    // Should we only store one `OMEMultiscale` record total, rather than one per source?\n    const priorityDirs = fetchOptions?.priorityDirections ? fetchOptions.priorityDirections.slice() : undefined;\n    return new OMEZarrLoader(sources, queue, fetchOptions, priorityDirs);\n  }\n  getUnitSymbols() {\n    const source = this.sources[0];\n    // Assume all spatial axes in all sources have the same units - we have no means of storing per-axis unit symbols\n    const xi = source.axesTCZYX[4];\n    const spaceUnitName = source.multiscaleMetadata.axes[xi].unit;\n    const spaceUnitSymbol = unitNameToSymbol(spaceUnitName) || spaceUnitName || \"\";\n    const ti = source.axesTCZYX[0];\n    const timeUnitName = ti > -1 ? source.multiscaleMetadata.axes[ti].unit : undefined;\n    const timeUnitSymbol = unitNameToSymbol(timeUnitName) || timeUnitName || \"\";\n    return [spaceUnitSymbol, timeUnitSymbol];\n  }\n  getLevelShapesZYX() {\n    const source = this.sources[0];\n    const [z, y, x] = source.axesTCZYX.slice(-3);\n    return source.scaleLevels.map(({\n      shape\n    }) => [z === -1 ? 1 : shape[z], shape[y], shape[x]]);\n  }\n  getScale(level) {\n    return getScale(this.sources[0].multiscaleMetadata.datasets[level], this.sources[0].axesTCZYX);\n  }\n  orderByDimension(valsTCZYX, sourceIdx = 0) {\n    return orderByDimension(valsTCZYX, this.sources[sourceIdx].axesTCZYX);\n  }\n  orderByTCZYX(valsDimension, defaultValue, sourceIdx = 0) {\n    return orderByTCZYX(valsDimension, this.sources[sourceIdx].axesTCZYX, defaultValue);\n  }\n\n  /**\n   * Converts a volume channel index to the index of its zarr source and its channel index within that zarr.\n   * e.g., if the loader has 2 sources, the first with 3 channels and the second with 2, then `matchChannelToSource(4)`\n   * returns `[1, 1]` (the second channel of the second source).\n   */\n  matchChannelToSource(absoluteChannelIndex) {\n    const lastSrcIdx = this.sources.length - 1;\n    const lastSrc = this.sources[lastSrcIdx];\n    const lastSrcNumChannels = lastSrc.scaleLevels[0].shape[lastSrc.axesTCZYX[1]];\n    const maxChannelIndex = lastSrc.channelOffset + lastSrcNumChannels;\n    if (absoluteChannelIndex > maxChannelIndex) {\n      throw new VolumeLoadError(`Volume channel index ${absoluteChannelIndex} out of range (${maxChannelIndex} channels available)`, {\n        type: VolumeLoadErrorType.INVALID_METADATA\n      });\n    }\n    const firstGreaterIdx = this.sources.findIndex(src => src.channelOffset > absoluteChannelIndex);\n    const sourceIndex = firstGreaterIdx === -1 ? lastSrcIdx : firstGreaterIdx - 1;\n    const channelIndexInSource = absoluteChannelIndex - this.sources[sourceIndex].channelOffset;\n    return {\n      sourceIndex,\n      channelIndexInSource\n    };\n  }\n\n  /**\n   * Change which directions to prioritize when prefetching. All chunks will be prefetched in these directions before\n   * any chunks are prefetched in any other directions.\n   */\n  setPrefetchPriority(directions) {\n    this.priorityDirections = directions;\n  }\n  syncMultichannelLoading(sync) {\n    this.syncChannels = sync;\n  }\n  updateFetchOptions(options) {\n    this.fetchOptions = {\n      ...this.fetchOptions,\n      ...options\n    };\n  }\n  loadDims(loadSpec) {\n    const [spaceUnit, timeUnit] = this.getUnitSymbols();\n    // Compute subregion size so we can factor that in\n    const maxExtent = this.maxExtent ?? new Box3(new Vector3(0, 0, 0), new Vector3(1, 1, 1));\n    const subregion = composeSubregion(loadSpec.subregion, maxExtent);\n    const regionSize = subregion.getSize(new Vector3());\n    const regionArr = [1, 1, regionSize.z, regionSize.y, regionSize.x];\n    const result = this.sources[0].scaleLevels.map((level, i) => {\n      const scale = this.getScale(i);\n      const dims = {\n        spaceUnit: spaceUnit,\n        timeUnit: timeUnit,\n        shape: this.orderByTCZYX(level.shape, 1).map((val, idx) => Math.max(Math.ceil(val * regionArr[idx]), 1)),\n        spacing: this.orderByTCZYX(scale, 1),\n        dataType: level.dtype\n      };\n      return dims;\n    });\n    return Promise.resolve(result);\n  }\n  createImageInfo(loadSpec) {\n    // We ensured most info (dims, chunks, etc.) matched between sources earlier, so we can just use the first source.\n    const source0 = this.sources[0];\n    const [t,, z, y, x] = source0.axesTCZYX;\n    const hasT = t > -1;\n    const hasZ = z > -1;\n    const levelToLoad = pickLevelToLoad(loadSpec, this.getLevelShapesZYX());\n    const shapeLv = source0.scaleLevels[levelToLoad].shape;\n    const [spatialUnit, timeUnit] = this.getUnitSymbols();\n\n    // Now we care about other sources: # of channels is the `channelOffset` of the last source plus its # of channels\n    const sourceLast = this.sources[this.sources.length - 1];\n    const cLast = sourceLast.axesTCZYX[1];\n    const lastHasC = cLast > -1;\n    const numChannels = sourceLast.channelOffset + (lastHasC ? sourceLast.scaleLevels[levelToLoad].shape[cLast] : 1);\n    // we need to make sure that the corresponding matched shapes\n    // use the min size of T\n    let times = 1;\n    if (hasT) {\n      times = shapeLv[t];\n      for (let i = 0; i < this.sources.length; i++) {\n        const shape = this.sources[i].scaleLevels[levelToLoad].shape;\n        const tindex = this.sources[i].axesTCZYX[0];\n        if (shape[tindex] < times) {\n          console.warn(\"The number of time points is not consistent across sources: \", shape[tindex], times);\n          times = shape[tindex];\n        }\n      }\n    }\n    if (!this.maxExtent) {\n      this.maxExtent = loadSpec.subregion.clone();\n    }\n\n    // from source 0:\n    const pxDimsLv = convertSubregionToPixels(loadSpec.subregion, new Vector3(shapeLv[x], shapeLv[y], hasZ ? shapeLv[z] : 1));\n    const pxSizeLv = pxDimsLv.getSize(new Vector3());\n    const atlasTileDims = computePackedAtlasDims(pxSizeLv.z, pxSizeLv.x, pxSizeLv.y);\n\n    // Channel names is the other place where we have to check every source\n    // Track which channel names we've seen so far, so that we can rename them to avoid name collisions\n    const channelNamesMap = new Map();\n    const channelNames = this.sources.flatMap(src => {\n      const sourceChannelNames = getSourceChannelNames(src);\n\n      // Resolve name collisions\n      return sourceChannelNames.map(channelName => {\n        const numMatchingChannels = channelNamesMap.get(channelName);\n        if (numMatchingChannels !== undefined) {\n          // If e.g. we've seen channel \"Membrane\" once before, rename this one to \"Membrane (1)\"\n          channelNamesMap.set(channelName, numMatchingChannels + 1);\n          return `${channelName} (${numMatchingChannels})`;\n        } else {\n          channelNamesMap.set(channelName, 1);\n          return channelName;\n        }\n      });\n    });\n    const alldims = source0.scaleLevels.map((level, i) => {\n      const dims = {\n        spaceUnit: spatialUnit,\n        timeUnit: timeUnit,\n        shape: this.orderByTCZYX(level.shape, 1),\n        spacing: this.getScale(i),\n        dataType: level.dtype\n      };\n      return dims;\n    });\n    const imgdata = {\n      name: source0.omeroMetadata?.name || \"Volume\",\n      atlasTileDims: [atlasTileDims.x, atlasTileDims.y],\n      subregionSize: [pxSizeLv.x, pxSizeLv.y, pxSizeLv.z],\n      subregionOffset: [0, 0, 0],\n      combinedNumChannels: numChannels,\n      channelNames,\n      multiscaleLevel: levelToLoad,\n      multiscaleLevelDims: alldims,\n      transform: {\n        translation: [0, 0, 0],\n        rotation: [0, 0, 0],\n        scale: [1, 1, 1]\n      }\n    };\n\n    // The `LoadSpec` passed in at this stage should represent the subset which this loader loads, not that\n    // which the volume contains. The volume contains the full extent of the subset recognized by this loader.\n    const fullExtentLoadSpec = {\n      ...loadSpec,\n      subregion: new Box3(new Vector3(0, 0, 0), new Vector3(1, 1, 1))\n    };\n    return Promise.resolve({\n      imageInfo: imgdata,\n      loadSpec: fullExtentLoadSpec\n    });\n  }\n  async prefetchChunk(scaleLevel, coords, subscriber) {\n    const {\n      store,\n      path\n    } = scaleLevel;\n    const separator = path.endsWith(\"/\") ? \"\" : \"/\";\n    const key = path + separator + this.orderByDimension(coords).join(\"/\");\n    // Calling `get` and doing nothing with the result still triggers a cache check, fetch, and insertion\n    await store.get(key, {\n      subscriber,\n      isPrefetch: true\n    }).catch(wrapVolumeLoadError(`Unable to prefetch chunk with key ${key}`, VolumeLoadErrorType.LOAD_DATA_FAILED, CHUNK_REQUEST_CANCEL_REASON));\n  }\n\n  /** Reads a list of chunk keys requested by a `loadVolumeData` call and sets up appropriate prefetch requests. */\n  beginPrefetch(keys, scaleLevel) {\n    // Convert keys to arrays of coords\n    const chunkCoords = keys.map(({\n      sourceIdx,\n      key\n    }) => {\n      const numDims = getDimensionCount(this.sources[sourceIdx].axesTCZYX);\n      const coordsInDimensionOrder = key.trim().split(\"/\").slice(-numDims).filter(s => s !== \"\").map(s => parseInt(s, 10));\n      const sourceCoords = this.orderByTCZYX(coordsInDimensionOrder, 0, sourceIdx);\n      // Convert source channel index to absolute channel index for `ChunkPrefetchIterator`'s benefit\n      // (we match chunk coordinates output from `ChunkPrefetchIterator` back to sources below)\n      sourceCoords[1] += this.sources[sourceIdx].channelOffset;\n      return sourceCoords;\n    });\n\n    // Get number of chunks per dimension in every source array\n    const chunkDimsTCZYX = this.sources.map(src => {\n      const level = src.scaleLevels[scaleLevel];\n      const chunkDimsUnordered = level.shape.map((dim, idx) => Math.ceil(dim / level.chunks[idx]));\n      return this.orderByTCZYX(chunkDimsUnordered, 1);\n    });\n    // `ChunkPrefetchIterator` yields chunk coordinates in order of roughly how likely they are to be loaded next\n    const prefetchIterator = new ChunkPrefetchIterator(chunkCoords, this.fetchOptions.maxPrefetchDistance, chunkDimsTCZYX, this.priorityDirections, this.fetchOptions.onlyPriorityDirections);\n    const subscriber = this.requestQueue.addSubscriber();\n    let prefetchCount = 0;\n    for (const chunk of prefetchIterator) {\n      if (prefetchCount >= this.fetchOptions.maxPrefetchChunks) {\n        break;\n      }\n      // Match absolute channel coordinate back to source index and channel index\n      const {\n        sourceIndex,\n        channelIndexInSource\n      } = this.matchChannelToSource(chunk[1]);\n      const sourceScaleLevel = this.sources[sourceIndex].scaleLevels[scaleLevel];\n      chunk[1] = channelIndexInSource;\n      this.prefetchChunk(sourceScaleLevel, chunk, subscriber);\n      prefetchCount++;\n    }\n\n    // Clear out old prefetch requests (requests which also cover this new prefetch will be preserved)\n    if (this.prefetchSubscriber !== undefined) {\n      this.requestQueue.removeSubscriber(this.prefetchSubscriber, CHUNK_REQUEST_CANCEL_REASON);\n    }\n    this.prefetchSubscriber = subscriber;\n  }\n  updateImageInfoForLoad(imageInfo, loadSpec) {\n    // Apply `this.maxExtent` to subregion, if it exists\n    const maxExtent = this.maxExtent ?? new Box3(new Vector3(0, 0, 0), new Vector3(1, 1, 1));\n    const subregion = composeSubregion(loadSpec.subregion, maxExtent);\n\n    // Pick the level to load based on the subregion size\n    const multiscaleLevel = pickLevelToLoad({\n      ...loadSpec,\n      subregion\n    }, this.getLevelShapesZYX());\n    const array0Shape = this.sources[0].scaleLevels[multiscaleLevel].shape;\n\n    // Convert subregion to volume voxels\n    const [z, y, x] = this.sources[0].axesTCZYX.slice(2);\n    const regionPx = convertSubregionToPixels(subregion, new Vector3(array0Shape[x], array0Shape[y], z === -1 ? 1 : array0Shape[z]));\n\n    // Derive other image info properties from subregion and level to load\n    const subregionSize = regionPx.getSize(new Vector3());\n    const atlasTileDims = computePackedAtlasDims(subregionSize.z, subregionSize.x, subregionSize.y);\n    return {\n      ...imageInfo,\n      atlasTileDims: [atlasTileDims.x, atlasTileDims.y],\n      subregionSize: [subregionSize.x, subregionSize.y, subregionSize.z],\n      subregionOffset: [regionPx.min.x, regionPx.min.y, regionPx.min.z],\n      multiscaleLevel\n    };\n  }\n  async loadRawChannelData(imageInfo, loadSpec, onUpdateMetadata, onData) {\n    // This seemingly useless line keeps a stable local copy of `syncChannels` which the async closures below capture\n    // so that changes to `this.syncChannels` don't affect the behavior of loads in progress.\n    const syncChannels = this.syncChannels;\n    const updatedImageInfo = this.updateImageInfoForLoad(imageInfo, loadSpec);\n    onUpdateMetadata(updatedImageInfo);\n    const {\n      combinedNumChannels,\n      multiscaleLevel\n    } = updatedImageInfo;\n    const channelIndexes = loadSpec.channels ?? Array.from({\n      length: combinedNumChannels\n    }, (_, i) => i);\n    const subscriber = this.requestQueue.addSubscriber();\n\n    // Prefetch housekeeping: we want to save keys involved in this load to prefetch later\n    const keys = [];\n    const reportKeyBase = (sourceIdx, key, sub) => {\n      if (sub === subscriber) {\n        keys.push({\n          sourceIdx,\n          key\n        });\n      }\n    };\n    const resultChannelIndices = [];\n    const resultChannelData = [];\n    const resultChannelDtype = [];\n    const resultChannelRanges = [];\n    const channelPromises = channelIndexes.map(async ch => {\n      // Build slice spec\n      const min = new Vector3(...updatedImageInfo.subregionOffset);\n      const max = min.clone().add(new Vector3(...updatedImageInfo.subregionSize));\n      const {\n        sourceIndex: sourceIdx,\n        channelIndexInSource: sourceCh\n      } = this.matchChannelToSource(ch);\n      const unorderedSpec = [loadSpec.time, sourceCh, slice(min.z, max.z), slice(min.y, max.y), slice(min.x, max.x)];\n      const level = this.sources[sourceIdx].scaleLevels[multiscaleLevel];\n      const sliceSpec = this.orderByDimension(unorderedSpec, sourceIdx);\n      const reportKey = (key, sub) => reportKeyBase(sourceIdx, key, sub);\n      const result = await zarrGet(level, sliceSpec, {\n        opts: {\n          subscriber,\n          reportKey\n        }\n      }).catch(wrapVolumeLoadError(\"Could not load OME-Zarr volume data\", VolumeLoadErrorType.LOAD_DATA_FAILED, CHUNK_REQUEST_CANCEL_REASON));\n      if (result?.data === undefined) {\n        return;\n      }\n      const converted = convertChannel(result.data, level.dtype);\n      if (syncChannels) {\n        resultChannelDtype.push(converted.dtype);\n        resultChannelData.push(converted.data);\n        resultChannelIndices.push(ch);\n        resultChannelRanges.push([converted.min, converted.max]);\n      } else {\n        onData([ch], [converted.dtype], [converted.data], [[converted.min, converted.max]]);\n      }\n    });\n\n    // Cancel any in-flight requests from previous loads that aren't useful to this one\n    if (this.loadSubscriber !== undefined) {\n      this.requestQueue.removeSubscriber(this.loadSubscriber, CHUNK_REQUEST_CANCEL_REASON);\n    }\n    this.loadSubscriber = subscriber;\n    this.beginPrefetch(keys, multiscaleLevel);\n    await Promise.all(channelPromises);\n    if (syncChannels) {\n      onData(resultChannelIndices, resultChannelDtype, resultChannelData, resultChannelRanges);\n    }\n    this.requestQueue.removeSubscriber(subscriber, CHUNK_REQUEST_CANCEL_REASON);\n  }\n}\nexport { OMEZarrLoader };","import { _internal_get_array_context, KeyError } from \"@zarrita/core\";\nimport { BasicIndexer } from \"./indexer.js\";\nimport { create_queue } from \"./util.js\";\nfunction unwrap(arr, idx) {\n    return \"get\" in arr ? arr.get(idx) : arr[idx];\n}\nexport async function get(arr, selection, opts, setter) {\n    const context = _internal_get_array_context(arr);\n    const indexer = new BasicIndexer({\n        selection,\n        shape: arr.shape,\n        chunk_shape: arr.chunks,\n    });\n    const out = setter.prepare(new context.TypedArray(indexer.shape.reduce((a, b) => a * b, 1)), indexer.shape, context.get_strides(indexer.shape, opts.order));\n    const queue = opts.create_queue?.() ?? create_queue();\n    for (const { chunk_coords, mapping } of indexer) {\n        queue.add(() => arr.getChunk(chunk_coords, opts.opts)\n            .then(({ data, shape, stride }) => {\n            const chunk = setter.prepare(data, shape, stride);\n            setter.set_from_chunk(out, chunk, mapping);\n        })\n            .catch((err) => {\n            // re-throw error if not a missing chunk\n            if (!(err instanceof KeyError))\n                throw err;\n            // KeyError, we need to fill the corresponding array\n            if (context.fill_value) {\n                setter.set_scalar(out, mapping\n                    .map((m) => m.to)\n                    .filter((s) => s !== null), context.fill_value);\n            }\n        }));\n    }\n    await queue.onIdle();\n    // If the final out shape is empty, we just return a scalar.\n    return indexer.shape.length === 0 ? unwrap(out.data, 0) : out;\n}\n","export let TimeUnit = /*#__PURE__*/function (TimeUnit) {\n  TimeUnit[TimeUnit[\"MILLISECOND\"] = 0] = \"MILLISECOND\";\n  TimeUnit[TimeUnit[\"SECOND\"] = 1] = \"SECOND\";\n  TimeUnit[TimeUnit[\"MINUTE\"] = 2] = \"MINUTE\";\n  TimeUnit[TimeUnit[\"HOUR\"] = 3] = \"HOUR\";\n  TimeUnit[TimeUnit[\"DAY\"] = 4] = \"DAY\";\n  return TimeUnit;\n}({});\nconst recognizedTimeUnits = {\n  [TimeUnit.MILLISECOND]: new Set([\"ms\", \"millisecond\", \"milliseconds\"]),\n  [TimeUnit.SECOND]: new Set([\"s\", \"sec\", \"second\", \"seconds\"]),\n  [TimeUnit.MINUTE]: new Set([\"m\", \"min\", \"minute\", \"minutes\"]),\n  [TimeUnit.HOUR]: new Set([\"h\", \"hr\", \"hour\", \"hours\"]),\n  [TimeUnit.DAY]: new Set([\"d\", \"day\", \"days\"])\n};\n\n/**\n * Parses an OME-compatible time unit into a TimeUnit enum.\n * @param unit string unit\n * @returns\n * - `TimeUnit.MILLISECOND` if unit is \"ms\", \"millisecond\", or \"milliseconds\"\n * - `TimeUnit.SECOND` if unit is \"s\", \"sec\", \"second\", or \"seconds\"\n * - `TimeUnit.MINUTE` if unit is \"m\", \"min\", \"minute\", or \"minutes\"\n * - `TimeUnit.HOUR` if unit is \"h\", \"hr\", \"hour\", or \"hours\"\n * - `TimeUnit.DAY` if unit is \"d\", \"day\", or \"days\"\n * - `undefined` if unit is not recognized\n */\nexport function parseTimeUnit(unit) {\n  for (const [timeUnit, recognizedUnits] of Object.entries(recognizedTimeUnits)) {\n    if (recognizedUnits.has(unit)) {\n      return timeUnit;\n    }\n  }\n}","import { parseTimeUnit, TimeUnit } from \"../constants/time.js\";\nimport { Axis } from \"../VolumeRenderSettings.js\";\nexport const DEFAULT_SIG_FIGS = 5;\nconst SECONDS_IN_MS = 1000;\nconst MINUTES_IN_MS = SECONDS_IN_MS * 60;\nconst HOURS_IN_MS = MINUTES_IN_MS * 60;\nconst DAYS_IN_MS = HOURS_IN_MS * 24;\n\n// Adapted from https://gist.github.com/ArneS/2ecfbe4a9d7072ac56c0.\nfunction digitToUnicodeSupercript(n) {\n  const subst = [0x2070, 185, 178, 179, 0x2074, 0x2075, 0x2076, 0x2077, 0x2078, 0x2079];\n  return String.fromCharCode(subst[n]);\n}\n\n/**\n * Converts a number to scientific notation with the specified number of significant\n * figures, handling negative numbers and rounding.\n * @param input The number to convert.\n * @param significantFigures the number of signficant figures/digits. Must be >= 1.\n * @returns a string, formatted as a number in scientific notation.\n * @example\n * ```\n * numberToSciNotation(1, 3) // \"1.00×10⁰\"\n * numberToSciNotation(0.99, 2) // \"9.9×10⁻¹\"\n * numberToSciNotation(0.999, 2) // \"1.0×10⁰\"\n * numberToSciNotation(-0.05, 1) // \"-5×10⁻²\"\n * numberToSciNotation(1400, 3) // \"1.40×10³\"\n * ```\n */\nfunction numberToSciNotation(input, sigFigs = DEFAULT_SIG_FIGS) {\n  const nativeExpForm = input.toExponential(sigFigs - 1);\n  const [significand, exponent] = nativeExpForm.split(\"e\");\n  const expSign = exponent[0] === \"-\" ? \"⁻\" : \"\";\n  const expDigits = exponent.slice(1).split(\"\");\n  const expSuperscript = expDigits.map(digit => digitToUnicodeSupercript(Number(digit))).join(\"\");\n  return `${significand}×10${expSign}${expSuperscript}`;\n}\n\n/**\n * Returns a string-encoded number rounded to a specified decimal precision, without ever formatting in scientific\n * notation like `Number.toPrecision` might do.\n */\nfunction toSigFigs(value, sigFigs) {\n  const exponent = Math.floor(Math.log10(Math.abs(value)));\n  return value.toFixed(Math.max(sigFigs - exponent - 1, 0));\n}\n\n/** Trims trailing instances of `char` off the end of `str`. */\n// This is not technically a number utility, but it's useful to `formatNumber` below.\nfunction trimTrailing(str, char) {\n  let i = str.length - 1;\n  while (str[i] === char) {\n    i--;\n  }\n  return str.slice(0, i + 1);\n}\n\n/**\n * Formats numbers for display as a string with a (hopefully) limited length.\n *\n * - If the number is an integer with 4 or fewer digits, it is returned as a string.\n * - If the number is a decimal, it is rounded to `sigFigs` significant figures. (default 5)\n * - If the number's absolute value is over 10,000 or less than 0.01, it is formatted in scientific notation to\n *   `sciSigFigs` significant figures. (Default `sigFigs - 2`, so 3 if neither are specified. The `- 2` leaves space\n *   for the exponential part. Remember: the purpose of this function is keeping number strings *consistently* short!)\n */\nexport function formatNumber(value, sigFigs = DEFAULT_SIG_FIGS, sciSigFigs = sigFigs - 2) {\n  const valueAbs = Math.abs(value);\n  if (Number.isInteger(value)) {\n    // Format integers with 5+ digits in scientific notation\n    if (valueAbs >= 10_000) {\n      return numberToSciNotation(value, sciSigFigs);\n    }\n    // Just stringify other integers\n    return value.toString();\n  } else {\n    const numStr = toSigFigs(value, sigFigs);\n    const numRounded = Math.abs(Number(numStr));\n    if (numRounded >= 10_000 || numRounded < 0.01) {\n      return numberToSciNotation(value, sciSigFigs);\n    }\n    const trimmed = trimTrailing(numStr, \"0\");\n    return trimmed.endsWith(\".\") ? trimmed.slice(0, -1) : trimmed;\n  }\n}\nconst timeUnitEnumToMilliseconds = {\n  [TimeUnit.MILLISECOND]: 1,\n  [TimeUnit.SECOND]: SECONDS_IN_MS,\n  [TimeUnit.MINUTE]: MINUTES_IN_MS,\n  [TimeUnit.HOUR]: HOURS_IN_MS,\n  [TimeUnit.DAY]: DAYS_IN_MS\n};\nexport function timeToMilliseconds(time, unit) {\n  const timeUnitMultiplier = timeUnitEnumToMilliseconds[unit];\n  if (timeUnitMultiplier === undefined) {\n    throw new Error(\"Unrecognized time unit\");\n  }\n  return time * timeUnitMultiplier;\n}\n\n/**\n * Pads the `value` with zeroes to the specified `length` if `shouldPad` is true\n * and returns the resulting string. Otherwise, returns the string representation of `value`.\n */\nfunction padConditionally(value, length, shouldPad) {\n  return shouldPad ? value.toString().padStart(length, \"0\") : value.toString();\n}\nfunction formatTimestamp(timeMs, options) {\n  const {\n    useMs,\n    useSec,\n    useMin,\n    useHours,\n    useDays\n  } = options;\n  const digits = [];\n  const units = [];\n  if (useDays) {\n    const days = Math.floor(timeMs / DAYS_IN_MS);\n    digits.push(days.toString());\n    units.push(\"d\");\n  }\n  if (useHours) {\n    const hours = Math.floor(timeMs % DAYS_IN_MS / HOURS_IN_MS);\n    // If the previous unit is included, pad the hours to 2 digits so the\n    // timestamp is consistent.\n    digits.push(padConditionally(hours, 2, useDays));\n    units.push(\"h\");\n  }\n  if (useMin) {\n    const minutes = Math.floor(timeMs % HOURS_IN_MS / MINUTES_IN_MS);\n    digits.push(padConditionally(minutes, 2, useHours));\n    units.push(\"m\");\n  }\n  if (useSec) {\n    const seconds = Math.floor(timeMs % MINUTES_IN_MS / SECONDS_IN_MS);\n    let secondString = padConditionally(seconds, 2, useMin);\n    units.push(\"s\");\n    // If using milliseconds, add as a decimal to the seconds string.\n    if (useMs) {\n      const milliseconds = Math.floor(timeMs % SECONDS_IN_MS);\n      secondString += \".\" + milliseconds.toString().padStart(3, \"0\");\n      // Do not add milliseconds to unit label, since they'll be shown as\n      // part of the seconds string.\n    }\n    digits.push(secondString);\n  } else if (useMs) {\n    const milliseconds = Math.floor(timeMs % SECONDS_IN_MS);\n    digits.push(milliseconds.toString());\n    units.push(\"ms\");\n  }\n  return {\n    timestamp: digits.join(\":\"),\n    units: units.join(\":\")\n  };\n}\n\n/**\n * Gets a timestamp formatted as `{time} / {total} {unit}`. If `unit` is a recognized\n * time unit, the timestamp will be formatted as a `d:hh:mm:ss.ms` string.\n *\n * @param time Current time, in specified units.\n * @param total Total time, in specified units.\n * @param unit The unit of time.\n * @returns A formatted timestamp string.\n * - If `unit` is not recognized, the timestamp will be formatted as `{time} / {total} {unit}`,\n * where `time` and `total` are formatted with significant digits as needed.\n * - If `unit` is recognized, the timestamp will be formatted as `d:hh:mm:ss.ms`, specifying\n * the most significant unit based on the total time, and the least significant unit with\n * `unit`. See `parseTimeUnit()` for recognized time units.\n */\nexport function getTimestamp(time, total, unit) {\n  const timeUnit = parseTimeUnit(unit);\n  if (timeUnit === undefined) {\n    return `${formatNumber(time)} / ${formatNumber(total)} ${unit}`;\n  }\n  const timeMs = timeToMilliseconds(time, timeUnit);\n  const totalMs = timeToMilliseconds(total, timeUnit);\n\n  // Toggle each unit based on the total time and the provided timeUnit.\n  // Exploit an enum property where TimeUnit.Milliseconds < TimeUnit.Second < TimeUnit.Minute ... etc.\n  const options = {\n    useMs: timeUnit == TimeUnit.MILLISECOND,\n    useSec: timeUnit == TimeUnit.SECOND || timeUnit <= TimeUnit.SECOND && totalMs >= SECONDS_IN_MS,\n    useMin: timeUnit == TimeUnit.MINUTE || timeUnit <= TimeUnit.MINUTE && totalMs >= MINUTES_IN_MS,\n    useHours: timeUnit == TimeUnit.HOUR || timeUnit <= TimeUnit.HOUR && totalMs >= HOURS_IN_MS,\n    useDays: timeUnit == TimeUnit.DAY || timeUnit <= TimeUnit.DAY && totalMs >= DAYS_IN_MS\n  };\n  const {\n    timestamp,\n    units\n  } = formatTimestamp(timeMs, options);\n  const {\n    timestamp: totalTimestamp\n  } = formatTimestamp(totalMs, options);\n  return `${timestamp} / ${totalTimestamp} ${units}`;\n}\n\n/**\n * Constrains the `src` vector relative to the `target` so it only has freedom along the\n * specified `axis`. Does nothing if `axis = Axis.NONE`.\n *\n * @example\n * ```\n *   const src = [1, 2, 3];\n *   const target = [4, 5, 6];\n *   const constrained = constrainToAxis(src, target, Axis.X);\n *   console.log(constrained); // [1, 5, 6]\n * ```\n */\nexport function constrainToAxis(src, target, axis) {\n  switch (axis) {\n    case Axis.X:\n      return [src[0], target[1], target[2]];\n    case Axis.Y:\n      return [target[0], src[1], target[2]];\n    case Axis.Z:\n      return [target[0], target[1], src[2]];\n    default:\n      return [...src];\n  }\n}\nexport function getDataRange(data) {\n  let min = data[0];\n  let max = data[0];\n  for (let i = 1; i < data.length; i++) {\n    min = Math.min(min, data[i]);\n    max = Math.max(max, data[i]);\n  }\n  return [min, max];\n}","import { Box3, Vector3 } from \"three\";\nimport { ThreadableVolumeLoader } from \"./IVolumeLoader.js\";\nimport { computeAtlasSize } from \"../ImageInfo.js\";\nimport { getDataRange } from \"../utils/num_utils.js\";\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\n/* eslint-enable @typescript-eslint/naming-convention */\n\nconst rescalePixelSize = json => {\n  // the pixel_size_x/y/z are the physical size of the original pixels represented by\n  // width and height.  We need to get a physical pixel size that is consistent\n  // with the tile_width and tile_height.\n  const px = json.pixel_size_x * json.width / json.tile_width;\n  const py = json.pixel_size_y * json.height / json.tile_height;\n  const pz = json.pixel_size_z;\n  return [px, py, pz];\n};\nconst convertImageInfo = json => {\n  const [px, py, pz] = rescalePixelSize(json);\n  // translation is in pixels that are in the space of json.width, json.height.\n  // We need to convert this to the space of the tile_width and tile_height.\n  const tr = json.transform?.translation ?? [0, 0, 0];\n  tr[0] = tr[0] * json.tile_width / json.width;\n  tr[1] = tr[1] * json.tile_height / json.height;\n  return {\n    name: json.name,\n    atlasTileDims: [json.cols, json.rows],\n    subregionSize: [json.tile_width, json.tile_height, json.tiles],\n    subregionOffset: [0, 0, 0],\n    combinedNumChannels: json.channels,\n    channelNames: json.channel_names,\n    channelColors: json.channel_colors,\n    multiscaleLevel: 0,\n    multiscaleLevelDims: [{\n      shape: [json.times || 1, json.channels, json.tiles, json.tile_height, json.tile_width],\n      spacing: [json.time_scale || 1, 1, pz, py, px],\n      spaceUnit: json.pixel_size_unit || \"μm\",\n      timeUnit: json.time_unit || \"s\",\n      dataType: \"uint8\"\n    }],\n    transform: {\n      translation: tr,\n      rotation: json.transform?.rotation ? json.transform.rotation : [0, 0, 0],\n      scale: [1, 1, 1]\n    },\n    userData: {\n      ...json.userData,\n      // for metadata display reasons\n      originalVolumeSize: [json.width, json.height, json.tiles],\n      originalPhysicalPixelSize: [json.pixel_size_x, json.pixel_size_y, json.pixel_size_z]\n    }\n  };\n};\nclass JsonImageInfoLoader extends ThreadableVolumeLoader {\n  syncChannels = false;\n  constructor(urls, cache) {\n    super();\n    if (Array.isArray(urls)) {\n      this.urls = urls;\n    } else {\n      this.urls = [urls];\n    }\n    this.jsonInfo = new Array(this.urls.length);\n    this.cache = cache;\n  }\n  async getJsonImageInfo(time) {\n    const cachedInfo = this.jsonInfo[time];\n    if (cachedInfo) {\n      return cachedInfo;\n    }\n    const response = await fetch(this.urls[time]);\n    const imageInfo = await response.json();\n    imageInfo.pixel_size_unit = imageInfo.pixel_size_unit || \"μm\";\n    imageInfo.times = imageInfo.times || this.urls.length;\n    this.jsonInfo[time] = imageInfo;\n    return imageInfo;\n  }\n  syncMultichannelLoading(sync) {\n    this.syncChannels = sync;\n  }\n  async loadDims(loadSpec) {\n    const jsonInfo = await this.getJsonImageInfo(loadSpec.time);\n    const [px, py, pz] = rescalePixelSize(jsonInfo);\n    const d = {\n      shape: [jsonInfo.times || 1, jsonInfo.channels, jsonInfo.tiles, jsonInfo.tile_height, jsonInfo.tile_width],\n      spacing: [1, 1, pz, py, px],\n      spaceUnit: jsonInfo.pixel_size_unit ?? \"μm\",\n      dataType: \"uint8\",\n      timeUnit: jsonInfo.time_unit ?? \"s\"\n    };\n    return [d];\n  }\n  async createImageInfo(loadSpec) {\n    const jsonInfo = await this.getJsonImageInfo(loadSpec.time);\n    return {\n      imageInfo: convertImageInfo(jsonInfo),\n      loadSpec\n    };\n  }\n  async loadRawChannelData(imageInfo, loadSpec, onUpdateMetadata, onData) {\n    // if you need to adjust image paths prior to download,\n    // now is the time to do it.\n    // Try to figure out the urlPrefix from the LoadSpec.\n    // For this format we assume the image data is in the same directory as the json file.\n    const jsonInfo = await this.getJsonImageInfo(loadSpec.time);\n    let images = jsonInfo?.images;\n    if (!images) {\n      return;\n    }\n    const requestedChannels = loadSpec.channels;\n    if (requestedChannels) {\n      // If only some channels are requested, load only images which contain at least one requested channel\n      images = images.filter(({\n        channels\n      }) => channels.some(ch => requestedChannels.includes(ch)));\n    }\n\n    // This regex removes everything after the last slash, so the url had better be simple.\n    const urlPrefix = this.urls[loadSpec.time].replace(/[^/]*$/, \"\");\n    images = images.map(element => ({\n      ...element,\n      name: urlPrefix + element.name\n    }));\n\n    // Update `image`'s `loadSpec` before loading\n    const adjustedLoadSpec = {\n      ...loadSpec,\n      // `subregion` and `multiscaleLevel` are unused by this loader\n      subregion: new Box3(new Vector3(0, 0, 0), new Vector3(1, 1, 1)),\n      multiscaleLevel: 0,\n      // include all channels in any loaded images\n      channels: images.flatMap(({\n        channels\n      }) => channels)\n    };\n    onUpdateMetadata(undefined, adjustedLoadSpec);\n    const [w, h] = computeAtlasSize(imageInfo);\n    const wrappedOnData = (ch, dtype, data, ranges) => onData(ch, dtype, data, ranges, [w, h]);\n    await JsonImageInfoLoader.loadVolumeAtlasData(images, wrappedOnData, this.cache, this.syncChannels);\n  }\n\n  /**\n   * load per-channel volume data from a batch of image files containing the volume slices tiled across the images\n   * @param {Array.<{name:string, channels:Array.<number>}>} imageArray\n   * @param {RawChannelDataCallback} onData Per-channel callback. Called when each channel's atlased volume data is loaded\n   * @param {VolumeCache} cache\n   * @example loadVolumeAtlasData([{\n   *     \"name\": \"AICS-10_5_5.ome.tif_atlas_0.png\",\n   *     \"channels\": [0, 1, 2]\n   * }, {\n   *     \"name\": \"AICS-10_5_5.ome.tif_atlas_1.png\",\n   *     \"channels\": [3, 4, 5]\n   * }, {\n   *     \"name\": \"AICS-10_5_5.ome.tif_atlas_2.png\",\n   *     \"channels\": [6, 7, 8]\n   * }], mycallback);\n   */\n  static async loadVolumeAtlasData(imageArray, onData, cache, syncChannels = false) {\n    const resultChannelIndices = [];\n    const resultChannelDtype = [];\n    const resultChannelData = [];\n    const resultChannelRanges = [];\n    const imagePromises = imageArray.map(async image => {\n      // Because the data is fetched such that one fetch returns a whole batch,\n      // if any in batch is cached then they all should be. So if any in batch is NOT cached,\n      // then we will have to do a batch request. This logic works both ways because it's all or nothing.\n      let cacheHit = true;\n      for (let j = 0; j < Math.min(image.channels.length, 4); ++j) {\n        const chindex = image.channels[j];\n        const cacheResult = cache?.get(`${image.name}/${chindex}`);\n        if (cacheResult) {\n          // all data coming from this loader is natively 8-bit\n          const channelData = new Uint8Array(cacheResult);\n          if (syncChannels) {\n            // if we are synchronizing channels, we need to keep track of the data\n            resultChannelIndices.push(chindex);\n            resultChannelDtype.push(\"uint8\");\n            resultChannelData.push(channelData);\n            resultChannelRanges.push(getDataRange(channelData));\n          } else {\n            onData([chindex], [\"uint8\"], [channelData], [getDataRange(channelData)]);\n          }\n        } else {\n          cacheHit = false;\n          // we can stop checking because we know we are going to have to fetch the whole batch\n          break;\n        }\n      }\n\n      // if all channels were in cache then we can move on to the next\n      // image (batch) without requesting\n      if (cacheHit) {\n        return;\n      }\n      const response = await fetch(image.name, {\n        mode: \"cors\"\n      });\n      const blob = await response.blob();\n      const bitmap = await createImageBitmap(blob);\n      const canvas = new OffscreenCanvas(bitmap.width, bitmap.height);\n      const ctx = canvas.getContext(\"2d\");\n      if (!ctx) {\n        console.log(\"Error creating canvas 2d context for \" + image.name);\n        return;\n      }\n      ctx.globalCompositeOperation = \"copy\";\n      ctx.globalAlpha = 1.0;\n      ctx.drawImage(bitmap, 0, 0);\n      const iData = ctx.getImageData(0, 0, bitmap.width, bitmap.height);\n      const channelsBits = [];\n      const length = bitmap.width * bitmap.height;\n\n      // allocate channels in batch\n      for (let ch = 0; ch < Math.min(image.channels.length, 4); ++ch) {\n        channelsBits.push(new Uint8Array(length));\n      }\n\n      // extract the data\n      const channelRange = [];\n      for (let j = 0; j < Math.min(image.channels.length, 4); ++j) {\n        let rawMin = Infinity;\n        let rawMax = -Infinity;\n        for (let px = 0; px < length; px++) {\n          channelsBits[j][px] = iData.data[px * 4 + j];\n          rawMin = Math.min(rawMin, channelsBits[j][px]);\n          rawMax = Math.max(rawMax, channelsBits[j][px]);\n        }\n        channelRange[j] = [rawMin, rawMax];\n      }\n\n      // done with `iData` and `canvas` now.\n\n      for (let ch = 0; ch < Math.min(image.channels.length, 4); ++ch) {\n        const chindex = image.channels[ch];\n        cache?.insert(`${image.name}/${chindex}`, channelsBits[ch]);\n        // NOTE: the atlas dimensions passed in here are currently unused by `JSONImageInfoLoader`\n        // all data coming from this loader is natively 8-bit\n        if (syncChannels) {\n          resultChannelIndices.push(chindex);\n          resultChannelDtype.push(\"uint8\");\n          resultChannelData.push(channelsBits[ch]);\n          resultChannelRanges.push(channelRange[ch]);\n        } else {\n          onData([chindex], [\"uint8\"], [channelsBits[ch]], [channelRange[ch]], [bitmap.width, bitmap.height]);\n        }\n      }\n    });\n    await Promise.all(imagePromises);\n    if (syncChannels) {\n      onData(resultChannelIndices, resultChannelDtype, resultChannelData, resultChannelRanges);\n    }\n  }\n}\nexport { JsonImageInfoLoader };","import { Box3, Vector3 } from \"three\";\nimport { ThreadableVolumeLoader } from \"./IVolumeLoader.js\";\nimport { computePackedAtlasDims } from \"./VolumeLoaderUtils.js\";\nimport { getDataRange } from \"../utils/num_utils.js\";\n\n// this is the form in which a 4D numpy array arrives as converted\n// by jupyterlab into a js object.\n// This loader does not yet support multiple time samples.\n\n// minimal metadata for visualization\n\nconst convertImageInfo = json => {\n  const atlasTileDims = computePackedAtlasDims(json.sizeZ, json.sizeX, json.sizeY);\n  return {\n    name: json.name,\n    // assumption: the data is already sized to fit in our viewer's preferred\n    // memory footprint (a tiled atlas texture as of this writing)\n    atlasTileDims: [atlasTileDims.x, atlasTileDims.y],\n    subregionSize: [json.sizeX, json.sizeY, json.sizeZ],\n    subregionOffset: [0, 0, 0],\n    combinedNumChannels: json.sizeC,\n    channelNames: json.channelNames,\n    channelColors: undefined,\n    multiscaleLevel: 0,\n    multiscaleLevelDims: [{\n      shape: [1, json.sizeC, json.sizeZ, json.sizeY, json.sizeX],\n      spacing: [1, 1, json.physicalPixelSize[2], json.physicalPixelSize[1], json.physicalPixelSize[0]],\n      spaceUnit: json.spatialUnit || \"μm\",\n      timeUnit: \"s\",\n      dataType: \"uint8\"\n    }],\n    transform: {\n      translation: [0, 0, 0],\n      rotation: [0, 0, 0],\n      scale: [1, 1, 1]\n    },\n    userData: json.userData\n  };\n};\nclass RawArrayLoader extends ThreadableVolumeLoader {\n  constructor(rawData, rawDataInfo) {\n    super();\n    this.jsonInfo = rawDataInfo;\n    this.data = rawData;\n    // check consistent dims\n    if (this.data.shape[0] !== this.jsonInfo.sizeC || this.data.shape[1] !== this.jsonInfo.sizeZ || this.data.shape[2] !== this.jsonInfo.sizeY || this.data.shape[3] !== this.jsonInfo.sizeX) {\n      throw new Error(\"RawArrayLoader: data shape does not match metadata\");\n    }\n  }\n  async loadDims(_loadSpec) {\n    const jsonInfo = this.jsonInfo;\n    const d = {\n      shape: [1, jsonInfo.sizeC, jsonInfo.sizeZ, jsonInfo.sizeY, jsonInfo.sizeX],\n      spacing: [1, 1, jsonInfo.physicalPixelSize[2], jsonInfo.physicalPixelSize[1], jsonInfo.physicalPixelSize[0]],\n      spaceUnit: jsonInfo.spatialUnit || \"μm\",\n      dataType: \"uint8\",\n      timeUnit: \"s\" // time unit not specified\n    };\n    return [d];\n  }\n  async createImageInfo(loadSpec) {\n    return {\n      imageInfo: convertImageInfo(this.jsonInfo),\n      loadSpec\n    };\n  }\n  loadRawChannelData(imageInfo, loadSpec, onUpdateMetadata, onData) {\n    const requestedChannels = loadSpec.channels;\n    const adjustedLoadSpec = {\n      ...loadSpec,\n      // `subregion` and `multiscaleLevel` are unused by this loader\n      subregion: new Box3(new Vector3(0, 0, 0), new Vector3(1, 1, 1)),\n      multiscaleLevel: 0\n    };\n    onUpdateMetadata(undefined, adjustedLoadSpec);\n    for (let chindex = 0; chindex < imageInfo.combinedNumChannels; ++chindex) {\n      if (requestedChannels && requestedChannels.length > 0 && !requestedChannels.includes(chindex)) {\n        continue;\n      }\n      const volSizeBytes = this.data.shape[3] * this.data.shape[2] * this.data.shape[1]; // x*y*z pixels * 1 byte/pixel\n      const channelData = new Uint8Array(this.data.buffer.buffer, chindex * volSizeBytes, volSizeBytes);\n      const range = getDataRange(channelData);\n      // all data coming from this loader is natively 8-bit\n      onData([chindex], [\"uint8\"], [channelData], [range]);\n    }\n    return Promise.resolve();\n  }\n}\nexport { RawArrayLoader };","import { fromUrl } from \"geotiff\";\nimport { deserializeError } from \"serialize-error\";\nimport { ThreadableVolumeLoader, LoadSpec } from \"./IVolumeLoader.js\";\nimport { computePackedAtlasDims, MAX_ATLAS_EDGE } from \"./VolumeLoaderUtils.js\";\nimport { VolumeLoadError, VolumeLoadErrorType, wrapVolumeLoadError } from \"./VolumeLoadError.js\";\nimport { CImageInfo } from \"../ImageInfo.js\";\nfunction prepareXML(xml) {\n  // trim trailing unicode zeros?\n  // eslint-disable-next-line no-control-regex\n  const expr = /[\\u0000]$/g;\n  return xml.trim().replace(expr, \"\").trim();\n}\nfunction getOME(xml) {\n  const parser = new DOMParser();\n  try {\n    const xmlDoc = parser.parseFromString(xml, \"text/xml\");\n    return xmlDoc.getElementsByTagName(\"OME\")[0];\n  } catch (e) {\n    throw new VolumeLoadError(\"Could not find OME metadata in TIFF file\", {\n      type: VolumeLoadErrorType.INVALID_METADATA,\n      cause: e\n    });\n  }\n}\nclass OMEDims {\n  sizex = 0;\n  sizey = 0;\n  sizez = 1;\n  sizec = 1;\n  sizet = 1;\n  unit = \"\";\n  pixeltype = \"\";\n  dimensionorder = \"\";\n  pixelsizex = 1;\n  pixelsizey = 1;\n  pixelsizez = 1;\n  channelnames = [];\n}\nfunction getDtype(omepixeltype) {\n  const mapping = {\n    uint8: \"uint8\",\n    uint16: \"uint16\",\n    uint32: \"uint32\",\n    int8: \"int8\",\n    int16: \"int16\",\n    int32: \"int32\",\n    float: \"float32\"\n  };\n  const dtype = mapping[omepixeltype];\n  if (dtype === undefined) {\n    console.warn(`Unsupported OME pixel type ${omepixeltype}; defaulting to uint8`);\n    return \"uint8\";\n  }\n  return dtype;\n}\nfunction getAttributeOrError(el, attr) {\n  const val = el.getAttribute(attr);\n  if (val === null) {\n    throw new VolumeLoadError(`Missing attribute ${attr} in OME-TIFF metadata`, {\n      type: VolumeLoadErrorType.INVALID_METADATA\n    });\n  }\n  return val;\n}\nfunction getOMEDims(imageEl) {\n  const dims = new OMEDims();\n  const pixelsEl = imageEl.getElementsByTagName(\"Pixels\")[0];\n  dims.sizex = Number(getAttributeOrError(pixelsEl, \"SizeX\"));\n  dims.sizey = Number(getAttributeOrError(pixelsEl, \"SizeY\"));\n  dims.sizez = Number(pixelsEl.getAttribute(\"SizeZ\"));\n  dims.sizec = Number(pixelsEl.getAttribute(\"SizeC\"));\n  dims.sizet = Number(pixelsEl.getAttribute(\"SizeT\"));\n  dims.unit = pixelsEl.getAttribute(\"PhysicalSizeXUnit\") || \"\";\n  dims.pixeltype = pixelsEl.getAttribute(\"Type\") || \"\";\n  dims.dimensionorder = pixelsEl.getAttribute(\"DimensionOrder\") || \"XYZCT\";\n  dims.pixelsizex = Number(pixelsEl.getAttribute(\"PhysicalSizeX\"));\n  dims.pixelsizey = Number(pixelsEl.getAttribute(\"PhysicalSizeY\"));\n  dims.pixelsizez = Number(pixelsEl.getAttribute(\"PhysicalSizeZ\"));\n  const channelsEls = pixelsEl.getElementsByTagName(\"Channel\");\n  for (let i = 0; i < channelsEls.length; ++i) {\n    const name = channelsEls[i].getAttribute(\"Name\");\n    const id = channelsEls[i].getAttribute(\"ID\");\n    dims.channelnames.push(name ? name : id ? id : \"Channel\" + i);\n  }\n  return dims;\n}\nconst getBytesPerSample = type => type === \"uint8\" ? 1 : type === \"uint16\" ? 2 : 4;\n\n// Despite the class `TiffLoader` extends, this loader is not threadable, since geotiff internally uses features that\n// aren't available on workers. It uses its own specialized workers anyways.\nclass TiffLoader extends ThreadableVolumeLoader {\n  constructor(url) {\n    super();\n    this.url = url;\n  }\n  async loadOmeDims() {\n    if (!this.dims) {\n      const tiff = await fromUrl(this.url, {\n        allowFullFile: true\n      }).catch(wrapVolumeLoadError(`Could not open TIFF file at ${this.url}`, VolumeLoadErrorType.NOT_FOUND));\n      // DO NOT DO THIS, ITS SLOW\n      // const imagecount = await tiff.getImageCount();\n      // read the FIRST image\n      const image = await tiff.getImage().catch(wrapVolumeLoadError(\"Failed to open TIFF image\", VolumeLoadErrorType.NOT_FOUND));\n      const tiffimgdesc = prepareXML(image.getFileDirectory().ImageDescription);\n      const omeEl = getOME(tiffimgdesc);\n      const image0El = omeEl.getElementsByTagName(\"Image\")[0];\n      this.dims = getOMEDims(image0El);\n    }\n    return this.dims;\n  }\n  async loadDims(_loadSpec) {\n    const dims = await this.loadOmeDims();\n    const atlasDims = computePackedAtlasDims(dims.sizez, dims.sizex, dims.sizey);\n    // fit tiles to max of 2048x2048?\n    const targetSize = MAX_ATLAS_EDGE;\n    const tilesizex = Math.floor(targetSize / atlasDims.x);\n    const tilesizey = Math.floor(targetSize / atlasDims.y);\n    const d = {\n      shape: [dims.sizet, dims.sizec, dims.sizez, tilesizey, tilesizex],\n      spacing: [1, 1, dims.pixelsizez, dims.pixelsizey * dims.sizey / tilesizey, dims.pixelsizex * dims.sizex / tilesizex],\n      spaceUnit: dims.unit ? dims.unit : \"micron\",\n      dataType: getDtype(dims.pixeltype),\n      timeUnit: \"s\"\n    };\n    return [d];\n  }\n  async createImageInfo(_loadSpec) {\n    const dims = await this.loadOmeDims();\n    // compare with sizex, sizey\n    //const width = image.getWidth();\n    //const height = image.getHeight();\n\n    // TODO allow user setting of this downsampling info?\n    // TODO allow ROI selection: range of x,y,z,c for a given t\n    const atlasDims = computePackedAtlasDims(dims.sizez, dims.sizex, dims.sizey);\n    // fit tiles to max of 2048x2048?\n    const targetSize = MAX_ATLAS_EDGE;\n    const tilesizex = Math.floor(targetSize / atlasDims.x);\n    const tilesizey = Math.floor(targetSize / atlasDims.y);\n\n    // load tiff and check metadata\n\n    const imgdata = {\n      name: \"TEST\",\n      atlasTileDims: [atlasDims.x, atlasDims.y],\n      subregionSize: [tilesizex, tilesizey, dims.sizez],\n      subregionOffset: [0, 0, 0],\n      combinedNumChannels: dims.sizec,\n      channelNames: dims.channelnames,\n      multiscaleLevel: 0,\n      multiscaleLevelDims: [{\n        shape: [dims.sizet, dims.sizec, dims.sizez, tilesizey, tilesizex],\n        spacing: [1, 1, dims.pixelsizez, dims.pixelsizey * dims.sizey / tilesizey, dims.pixelsizex * dims.sizex / tilesizex],\n        spaceUnit: dims.unit || \"\",\n        timeUnit: \"\",\n        dataType: getDtype(dims.pixeltype)\n      }],\n      transform: {\n        translation: [0, 0, 0],\n        rotation: [0, 0, 0],\n        scale: [1, 1, 1]\n      }\n    };\n\n    // This loader uses no fields from `LoadSpec`. Initialize volume with defaults.\n    return {\n      imageInfo: imgdata,\n      loadSpec: new LoadSpec()\n    };\n  }\n  async loadRawChannelData(imageInfo, _loadSpec, _onUpdateMetadata, onData) {\n    const dims = await this.loadOmeDims();\n\n    // get some size info.\n    const cimageinfo = new CImageInfo(imageInfo);\n    const volumeSize = cimageinfo.volumeSize;\n    const channelProms = [];\n    // do each channel on a worker?\n    for (let channel = 0; channel < imageInfo.combinedNumChannels; ++channel) {\n      const thisChannelProm = new Promise((resolve, reject) => {\n        const params = {\n          channel: channel,\n          // these are target xy sizes for the in-memory volume data\n          // they may or may not be the same size as original xy sizes\n          tilesizex: volumeSize.x,\n          tilesizey: volumeSize.y,\n          sizec: imageInfo.combinedNumChannels,\n          sizez: volumeSize.z,\n          dimensionOrder: dims.dimensionorder,\n          bytesPerSample: getBytesPerSample(dims.pixeltype),\n          url: this.url\n        };\n        const worker = new Worker(new URL(\"../workers/FetchTiffWorker\", import.meta.url));\n        worker.onmessage = e => {\n          if (e.data.isError) {\n            reject(deserializeError(e.data.error));\n            return;\n          }\n          const {\n            data,\n            dtype,\n            channel,\n            range\n          } = e.data;\n          onData([channel], [dtype], [data], [range]);\n          worker.terminate();\n          resolve();\n        };\n        worker.postMessage(params);\n      });\n      channelProms.push(thisChannelProm);\n    }\n\n    // waiting for all channels to load allows errors to propagate to the caller via this promise\n    await Promise.all(channelProms);\n  }\n}\nexport { TiffLoader };","/**\n * Directions in which to move outward from the loaded set of chunks while prefetching.\n *\n * Ordered in pairs of opposite directions both because that's a sensible order in which to prefetch for our purposes,\n * and because it lets us treat the least significant bit as the sign. So `direction >> 1` gives the index of the\n * direction in TZYX-ordered arrays, and `direction & 1` gives the sign of the direction (e.g. positive vs negative Z).\n */\nexport let PrefetchDirection = /*#__PURE__*/function (PrefetchDirection) {\n  PrefetchDirection[PrefetchDirection[\"T_MINUS\"] = 0] = \"T_MINUS\";\n  PrefetchDirection[PrefetchDirection[\"T_PLUS\"] = 1] = \"T_PLUS\";\n  PrefetchDirection[PrefetchDirection[\"Z_MINUS\"] = 2] = \"Z_MINUS\";\n  PrefetchDirection[PrefetchDirection[\"Z_PLUS\"] = 3] = \"Z_PLUS\";\n  PrefetchDirection[PrefetchDirection[\"Y_MINUS\"] = 4] = \"Y_MINUS\";\n  PrefetchDirection[PrefetchDirection[\"Y_PLUS\"] = 5] = \"Y_PLUS\";\n  PrefetchDirection[PrefetchDirection[\"X_MINUS\"] = 6] = \"X_MINUS\";\n  PrefetchDirection[PrefetchDirection[\"X_PLUS\"] = 7] = \"X_PLUS\";\n  return PrefetchDirection;\n}({});\n\n/** https://ngff.openmicroscopy.org/latest/#multiscale-md */\n\n/** https://ngff.openmicroscopy.org/latest/#omero-md */\n\n/** A record with everything we need to access and use a single remote source of multiscale OME-Zarr data. */","import { OMEZarrLoader } from \"./OmeZarrLoader.js\";\nimport { JsonImageInfoLoader } from \"./JsonImageInfoLoader.js\";\nimport { RawArrayLoader } from \"./RawArrayLoader.js\";\nimport { TiffLoader } from \"./TiffLoader.js\";\nexport { PrefetchDirection } from \"./zarr_utils/types.js\";\nexport let VolumeFileFormat = /*#__PURE__*/function (VolumeFileFormat) {\n  VolumeFileFormat[\"ZARR\"] = \"zarr\";\n  VolumeFileFormat[\"JSON\"] = \"json\";\n  VolumeFileFormat[\"TIFF\"] = \"tiff\";\n  VolumeFileFormat[\"DATA\"] = \"data\";\n  return VolumeFileFormat;\n}({});\n\n// superset of all necessary loader options\n\nexport function pathToFileType(path) {\n  if (path.endsWith(\".json\")) {\n    return VolumeFileFormat.JSON;\n  } else if (path.endsWith(\".tif\") || path.endsWith(\".tiff\")) {\n    return VolumeFileFormat.TIFF;\n  }\n  return VolumeFileFormat.ZARR;\n}\nexport async function createVolumeLoader(path, options) {\n  const pathString = Array.isArray(path) ? path[0] : path;\n  const fileType = options?.fileType || pathToFileType(pathString);\n  switch (fileType) {\n    case VolumeFileFormat.ZARR:\n      return await OMEZarrLoader.createLoader(path, options?.scene, options?.cache, options?.queue, options?.fetchOptions);\n    case VolumeFileFormat.JSON:\n      return new JsonImageInfoLoader(path, options?.cache);\n    case VolumeFileFormat.TIFF:\n      return new TiffLoader(pathString);\n    case VolumeFileFormat.DATA:\n      if (!options?.rawArrayOptions) {\n        throw new Error(\"Must provide RawArrayOptions for RawArrayLoader\");\n      }\n      return new RawArrayLoader(options?.rawArrayOptions.data, options?.rawArrayOptions.metadata);\n  }\n}","/** The types of requests that can be made to the worker. Mostly corresponds to methods on `IVolumeLoader`. */\nexport let WorkerMsgType = /*#__PURE__*/function (WorkerMsgType) {\n  WorkerMsgType[WorkerMsgType[\"INIT\"] = 0] = \"INIT\";\n  WorkerMsgType[WorkerMsgType[\"CREATE_LOADER\"] = 1] = \"CREATE_LOADER\";\n  WorkerMsgType[WorkerMsgType[\"CREATE_VOLUME\"] = 2] = \"CREATE_VOLUME\";\n  WorkerMsgType[WorkerMsgType[\"LOAD_DIMS\"] = 3] = \"LOAD_DIMS\";\n  WorkerMsgType[WorkerMsgType[\"LOAD_VOLUME_DATA\"] = 4] = \"LOAD_VOLUME_DATA\";\n  WorkerMsgType[WorkerMsgType[\"SET_PREFETCH_PRIORITY_DIRECTIONS\"] = 5] = \"SET_PREFETCH_PRIORITY_DIRECTIONS\";\n  WorkerMsgType[WorkerMsgType[\"SYNCHRONIZE_MULTICHANNEL_LOADING\"] = 6] = \"SYNCHRONIZE_MULTICHANNEL_LOADING\";\n  WorkerMsgType[WorkerMsgType[\"UPDATE_FETCH_OPTIONS\"] = 7] = \"UPDATE_FETCH_OPTIONS\";\n  return WorkerMsgType;\n}({});\n\n/** The kind of response a worker can return - `SUCCESS`, `ERROR`, or `EVENT`. */\nexport let WorkerResponseResult = /*#__PURE__*/function (WorkerResponseResult) {\n  WorkerResponseResult[WorkerResponseResult[\"SUCCESS\"] = 0] = \"SUCCESS\";\n  WorkerResponseResult[WorkerResponseResult[\"ERROR\"] = 1] = \"ERROR\";\n  WorkerResponseResult[WorkerResponseResult[\"EVENT\"] = 2] = \"EVENT\";\n  return WorkerResponseResult;\n}({});\n\n/** The kind of events that can occur when loading */\nexport let WorkerEventType = /*#__PURE__*/function (WorkerEventType) {\n  WorkerEventType[WorkerEventType[\"METADATA_UPDATE\"] = 0] = \"METADATA_UPDATE\";\n  WorkerEventType[WorkerEventType[\"CHANNEL_LOAD\"] = 1] = \"CHANNEL_LOAD\";\n  return WorkerEventType;\n}({});\n\n/** All messages to/from a worker carry a `msgId`, a `type`, and a `payload` (whose type is determined by `type`). */\n\n/** Maps each `WorkerMsgType` to the type of the payload of requests of that type. */\n\n/** Maps each `WorkerMsgType` to the type of the payload of responses of that type. */\n\n/** Event for when a batch of channel data loads. */\n\n/** Event for when metadata updates. */\n\n/** All valid types of worker requests, with some `WorkerMsgType` and a matching payload type. */\n\n/** All valid types of worker responses: `SUCCESS` with a matching payload, `ERROR` with a message, or an `EVENT`. */","import { serializeError } from \"serialize-error\";\nimport VolumeCache from \"../VolumeCache.js\";\nimport { VolumeFileFormat, createVolumeLoader, pathToFileType } from \"../loaders/index.js\";\nimport { VolumeLoadError } from \"../loaders/VolumeLoadError.js\";\nimport RequestQueue from \"../utils/RequestQueue.js\";\nimport SubscribableRequestQueue from \"../utils/SubscribableRequestQueue.js\";\nimport { WorkerEventType, WorkerMsgType, WorkerResponseResult } from \"./types.js\";\nimport { rebuildLoadSpec } from \"./util.js\";\nlet cache = undefined;\nlet queue = undefined;\nlet subscribableQueue = undefined;\nlet loader = undefined;\nlet initialized = false;\nlet copyOnLoad = false;\nconst messageHandlers = {\n  [WorkerMsgType.INIT]: ({\n    maxCacheSize,\n    maxActiveRequests,\n    maxLowPriorityRequests\n  }) => {\n    if (!initialized) {\n      cache = new VolumeCache(maxCacheSize);\n      queue = new RequestQueue(maxActiveRequests, maxLowPriorityRequests);\n      subscribableQueue = new SubscribableRequestQueue(queue);\n      initialized = true;\n    }\n    return Promise.resolve();\n  },\n  [WorkerMsgType.CREATE_LOADER]: async ({\n    path,\n    options\n  }) => {\n    const pathString = Array.isArray(path) ? path[0] : path;\n    const fileType = options?.fileType || pathToFileType(pathString);\n    copyOnLoad = fileType === VolumeFileFormat.JSON;\n    loader = await createVolumeLoader(path, {\n      ...options,\n      cache,\n      queue: subscribableQueue\n    });\n    return loader !== undefined;\n  },\n  [WorkerMsgType.CREATE_VOLUME]: async loadSpec => {\n    if (loader === undefined) {\n      throw new VolumeLoadError(\"No loader created\");\n    }\n    return await loader.createImageInfo(rebuildLoadSpec(loadSpec));\n  },\n  [WorkerMsgType.LOAD_DIMS]: async loadSpec => {\n    if (loader === undefined) {\n      throw new VolumeLoadError(\"No loader created\");\n    }\n    return await loader.loadDims(rebuildLoadSpec(loadSpec));\n  },\n  [WorkerMsgType.LOAD_VOLUME_DATA]: ({\n    imageInfo,\n    loadSpec,\n    loaderId,\n    loadId\n  }) => {\n    if (loader === undefined) {\n      throw new VolumeLoadError(\"No loader created\");\n    }\n    return loader.loadRawChannelData(imageInfo, rebuildLoadSpec(loadSpec), (imageInfo, loadSpec) => {\n      const message = {\n        responseResult: WorkerResponseResult.EVENT,\n        eventType: WorkerEventType.METADATA_UPDATE,\n        loaderId,\n        loadId,\n        imageInfo,\n        loadSpec\n      };\n      self.postMessage(message);\n    }, (channelIndex, dtype, data, ranges, atlasDims) => {\n      const message = {\n        responseResult: WorkerResponseResult.EVENT,\n        eventType: WorkerEventType.CHANNEL_LOAD,\n        loaderId,\n        loadId,\n        channelIndex,\n        dtype,\n        data,\n        ranges,\n        atlasDims\n      };\n      self.postMessage(message, copyOnLoad ? [] : data.map(d => d.buffer));\n    });\n  },\n  [WorkerMsgType.SET_PREFETCH_PRIORITY_DIRECTIONS]: directions => {\n    // Silently does nothing if the loader isn't an `OMEZarrLoader`\n    loader?.setPrefetchPriority(directions);\n    return Promise.resolve();\n  },\n  [WorkerMsgType.SYNCHRONIZE_MULTICHANNEL_LOADING]: syncChannels => {\n    loader?.syncMultichannelLoading(syncChannels);\n    return Promise.resolve();\n  },\n  [WorkerMsgType.UPDATE_FETCH_OPTIONS]: fetchOptions => {\n    loader?.updateFetchOptions(fetchOptions);\n    return Promise.resolve();\n  }\n};\nself.onmessage = async ({\n  data\n}) => {\n  const {\n    msgId,\n    type,\n    payload\n  } = data;\n  let message;\n  try {\n    const response = await messageHandlers[type](payload);\n    message = {\n      responseResult: WorkerResponseResult.SUCCESS,\n      msgId,\n      type,\n      payload: response\n    };\n  } catch (e) {\n    message = {\n      responseResult: WorkerResponseResult.ERROR,\n      msgId,\n      type,\n      payload: serializeError(e)\n    };\n  }\n  self.postMessage(message);\n};","import { Box3, Vector3 } from \"three\";\n/** Recreates a `LoadSpec` that has just been sent to/from a worker to restore three.js object prototypes */\nexport function rebuildLoadSpec(spec) {\n  return {\n    ...spec,\n    subregion: new Box3(new Vector3().copy(spec.subregion.min), new Vector3().copy(spec.subregion.max))\n  };\n}"],"names":["NonError","Error","name","constructor","message","super","_prepareSuperMessage","JSON","stringify","String","commonProperties","property","enumerable","toJsonWasCalled","WeakSet","getErrorConstructor","get","destroyCircular","from","seen","to","forceEnumerable","maxDepth","depth","useToJSON","serialize","Array","isArray","isErrorLike","push","toJSON","has","add","json","delete","continueDestroyCircular","value","key","Object","entries","Uint8Array","pipe","includes","defineProperty","configurable","writable","serializeError","options","Number","POSITIVE_INFINITY","deserializeError","Boolean","isMinimumViableSerializedError","VolumeCache","maxSize","this","Map","currentSize","first","last","size","numberOfEntries","removeEntryFromStore","entry","data","byteLength","removeEntryFromList","prev","next","addEntryAsFirst","moveEntryToFirst","evictLast","console","error","evict","insert","getResult","getEntry","undefined","newEntry","set","result","clearWithPrefix","prefix","startsWith","clear","ClampToEdgeWrapping","UnsignedByteType","RedIntegerFormat","InterpolateDiscrete","InterpolateLinear","InterpolateSmooth","SRGBColorSpace","LinearSRGBColorSpace","LinearTransfer","SRGBTransfer","EventDispatcher","addEventListener","type","listener","_listeners","listeners","indexOf","hasEventListener","removeEventListener","listenerArray","index","splice","dispatchEvent","event","target","array","slice","i","l","length","call","_lut","generateUUID","d0","Math","random","d1","d2","d3","toLowerCase","clamp","min","max","lerp","x","y","t","PI","prototype","isVector2","width","height","setScalar","scalar","setX","setY","setComponent","getComponent","clone","copy","v","addScalar","s","addVectors","a","b","addScaledVector","sub","subScalar","subVectors","multiply","multiplyScalar","divide","divideScalar","applyMatrix3","m","e","elements","clampScalar","minVal","maxVal","clampLength","floor","ceil","round","roundToZero","trunc","negate","dot","cross","lengthSq","sqrt","manhattanLength","abs","normalize","angle","atan2","angleTo","denominator","theta","acos","distanceTo","distanceToSquared","dx","dy","manhattanDistanceTo","setLength","alpha","lerpVectors","v1","v2","equals","fromArray","offset","toArray","fromBufferAttribute","attribute","getX","getY","rotateAround","center","c","cos","sin","Symbol","iterator","Matrix3","n11","n12","n13","n21","n22","n23","n31","n32","n33","isMatrix3","te","identity","me","extractBasis","xAxis","yAxis","zAxis","setFromMatrix3Column","setFromMatrix4","multiplyMatrices","premultiply","ae","be","a11","a12","a13","a21","a22","a23","a31","a32","a33","b11","b12","b13","b21","b22","b23","b31","b32","b33","determinant","d","f","g","h","invert","t11","t12","t13","det","detInv","transpose","tmp","getNormalMatrix","matrix4","transposeIntoArray","r","setUvTransform","tx","ty","sx","sy","rotation","cx","cy","scale","_m3","makeScale","rotate","makeRotation","translate","makeTranslation","matrix","createElementNS","document","Int8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","LINEAR_REC709_TO_XYZ","XYZ_TO_LINEAR_REC709","createColorManagement","ColorManagement","enabled","workingColorSpace","spaces","convert","color","sourceColorSpace","targetColorSpace","transfer","SRGBToLinear","primaries","toXYZ","fromXYZ","LinearToSRGB","fromWorkingColorSpace","toWorkingColorSpace","getPrimaries","colorSpace","getTransfer","getLuminanceCoefficients","luminanceCoefficients","define","colorSpaces","assign","_getMatrix","targetMatrix","_getDrawingBufferColorSpace","outputColorSpaceConfig","drawingBufferColorSpace","_getUnpackColorSpace","workingColorSpaceConfig","unpackColorSpace","REC709_PRIMARIES","REC709_LUMINANCE_COEFFICIENTS","D65","whitePoint","pow","_canvas","ImageUtils","getDataURL","image","test","src","HTMLCanvasElement","canvas","context","getContext","ImageData","putImageData","drawImage","warn","toDataURL","sRGBToLinear","HTMLImageElement","ImageBitmap","imageData","getImageData","_sourceId","Source","isSource","uuid","dataReady","version","needsUpdate","meta","isRootObject","images","output","url","isDataTexture","serializeImage","_textureId","Texture","DEFAULT_IMAGE","mapping","DEFAULT_MAPPING","wrapS","wrapT","magFilter","LinearFilter","minFilter","LinearMipmapLinearFilter","format","RGBAFormat","anisotropy","DEFAULT_ANISOTROPY","isTexture","source","mipmaps","channel","internalFormat","repeat","matrixAutoUpdate","generateMipmaps","premultiplyAlpha","flipY","unpackAlignment","userData","onUpdate","isRenderTargetTexture","pmremVersion","updateMatrix","parse","textures","metadata","generator","wrap","keys","dispose","transformUv","uv","needsPMREMUpdate","Quaternion","z","w","isQuaternion","_x","_y","_z","_w","slerpFlat","dst","dstOffset","src0","srcOffset0","src1","srcOffset1","x0","y0","z0","w0","x1","y1","z1","w1","dir","sqrSin","EPSILON","len","tDir","multiplyQuaternionsFlat","_onChangeCallback","quaternion","setFromEuler","euler","update","order","_order","c1","c2","c3","s1","s2","s3","setFromAxisAngle","axis","halfAngle","setFromRotationMatrix","m11","m12","m13","m21","m22","m23","m31","m32","m33","trace","setFromUnitVectors","vFrom","vTo","q","rotateTowards","step","slerp","conjugate","multiplyQuaternions","qax","qay","qaz","qaw","qbx","qby","qbz","qbw","qb","cosHalfTheta","sqrSinHalfTheta","sinHalfTheta","halfTheta","ratioA","ratioB","slerpQuaternions","qa","theta1","theta2","r1","r2","getZ","getW","_onChange","callback","isVector3","setZ","multiplyVectors","applyEuler","applyQuaternion","_quaternion$4","applyAxisAngle","applyNormalMatrix","applyMatrix4","vx","vy","vz","qx","qy","qz","qw","tz","project","camera","matrixWorldInverse","projectionMatrix","unproject","projectionMatrixInverse","matrixWorld","transformDirection","crossVectors","ax","ay","az","bx","by","bz","projectOnVector","projectOnPlane","planeNormal","_vector$c","reflect","normal","dz","setFromSpherical","setFromSphericalCoords","radius","phi","sinPhiRadius","setFromCylindrical","setFromCylindricalCoords","setFromMatrixPosition","setFromMatrixScale","setFromMatrixColumn","sz","setFromColor","randomDirection","u","Box3","isBox3","setFromArray","makeEmpty","il","expandByPoint","_vector$b","setFromBufferAttribute","count","setFromPoints","points","setFromCenterAndSize","halfSize","setFromObject","object","precise","expandByObject","box","isEmpty","getCenter","getSize","point","expandByVector","vector","expandByScalar","updateWorldMatrix","geometry","positionAttribute","getAttribute","isInstancedMesh","isMesh","getVertexPosition","boundingBox","computeBoundingBox","_box$4","union","children","containsPoint","containsBox","getParameter","intersectsBox","intersectsSphere","sphere","clampPoint","intersectsPlane","plane","constant","intersectsTriangle","triangle","_center","_extents","_v0$2","_v1$7","_v2$4","_f0","_f1","_f2","axes","satForAxes","_triangleNormal","distanceToPoint","getBoundingSphere","intersect","_points","_testAxis","v0","extents","j","p0","p1","p2","Matrix4","n14","n24","n34","n41","n42","n43","n44","isMatrix4","copyPosition","setFromMatrix3","makeBasis","extractRotation","scaleX","_v1$5","scaleY","scaleZ","makeRotationFromEuler","af","bf","ce","cf","de","df","ac","ad","bc","bd","makeRotationFromQuaternion","compose","_zero","_one","lookAt","eye","up","a14","a24","a34","a41","a42","a43","a44","b14","b24","b34","b41","b42","b43","b44","setPosition","t14","getMaxScaleOnAxis","scaleXSq","scaleYSq","scaleZSq","makeRotationX","makeRotationY","makeRotationZ","makeRotationAxis","makeShear","xy","xz","yx","yz","zx","zy","position","x2","y2","z2","xx","yy","zz","wx","wy","wz","decompose","_m1$2","invSX","invSY","invSZ","makePerspective","left","right","top","bottom","near","far","coordinateSystem","WebGLCoordinateSystem","makeOrthographic","p","zInv","_matrix$2","_quaternion$3","DEFAULT_ORDER","isEuler","asin","setFromQuaternion","setFromVector3","reorder","newOrder","Layers","mask","enable","enableAll","toggle","disable","disableAll","layers","isEnabled","_object3DId","_v1$4","_q1","_m1$1","_target","_position$3","_scale$2","_quaternion$2","_xAxis","_yAxis","_zAxis","_addedEvent","_removedEvent","_childaddedEvent","child","_childremovedEvent","Object3D","isObject3D","parent","DEFAULT_UP","defineProperties","modelViewMatrix","normalMatrix","DEFAULT_MATRIX_AUTO_UPDATE","matrixWorldAutoUpdate","DEFAULT_MATRIX_WORLD_AUTO_UPDATE","matrixWorldNeedsUpdate","visible","castShadow","receiveShadow","frustumCulled","renderOrder","animations","onBeforeShadow","onAfterShadow","onBeforeRender","onAfterRender","setRotationFromAxisAngle","setRotationFromEuler","setRotationFromMatrix","setRotationFromQuaternion","rotateOnAxis","rotateOnWorldAxis","rotateX","rotateY","rotateZ","translateOnAxis","distance","translateX","translateY","translateZ","localToWorld","worldToLocal","isCamera","isLight","arguments","removeFromParent","remove","attach","getObjectById","id","getObjectByProperty","getObjectByName","getObjectsByProperty","getWorldPosition","getWorldQuaternion","getWorldScale","getWorldDirection","raycast","traverse","traverseVisible","traverseAncestors","updateMatrixWorld","force","updateParents","updateChildren","geometries","materials","shapes","skeletons","nodes","library","element","instanceMatrix","instanceColor","isBatchedMesh","perObjectFrustumCulled","sortObjects","drawRanges","_drawRanges","reservedRanges","_reservedRanges","visibility","_visibility","active","_active","bounds","_bounds","map","bound","boxInitialized","boxMin","boxMax","sphereInitialized","sphereRadius","sphereCenter","maxInstanceCount","_maxInstanceCount","maxVertexCount","_maxVertexCount","maxIndexCount","_maxIndexCount","geometryInitialized","_geometryInitialized","geometryCount","_geometryCount","matricesTexture","_matricesTexture","_colorsTexture","colorsTexture","boundingSphere","isScene","background","isColor","environment","isLine","isPoints","parameters","shape","isSkinnedMesh","bindMode","bindMatrix","skeleton","material","uuids","animation","extractFromCache","cache","values","recursive","_colorKeywords","_hslA","_hslB","hue2rgb","Color","setHex","setStyle","setRGB","hex","setHSL","style","handleAlpha","string","parseFloat","exec","components","parseInt","charAt","setColorName","copySRGBToLinear","copyLinearToSRGB","convertSRGBToLinear","convertLinearToSRGB","getHex","_color","getHexString","toString","getHSL","hue","saturation","lightness","delta","getRGB","getStyle","toFixed","offsetHSL","addColors","color1","color2","lerpColors","lerpHSL","NAMES","DataTexture","NearestFilter","convertArray","forceClone","BYTES_PER_ELEMENT","Interpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","_cachedIndex","valueSize","settings","DefaultSettings_","evaluate","pp","i1","t1","t0","validate_interval","seek","linear_scan","forward_scan","giveUpAt","copySampleValue_","t1global","mid","intervalChanged_","interpolate_","getSettings_","stride","CubicInterpolant","_weightPrev","_offsetPrev","_weightNext","_offsetNext","endingStart","endingEnd","iPrev","iNext","tPrev","tNext","halfDt","o1","o0","oP","oN","wP","wN","ppp","sP","s0","sN","LinearInterpolant","offset1","offset0","weight1","weight0","DiscreteInterpolant","KeyframeTrack","times","interpolation","TimeBufferType","ValueBufferType","setInterpolation","DefaultInterpolation","track","trackType","getInterpolation","ValueTypeName","InterpolantFactoryMethodDiscrete","getValueSize","InterpolantFactoryMethodLinear","InterpolantFactoryMethodSmooth","factoryMethod","createInterpolant","shift","timeOffset","n","timeScale","trim","startTime","endTime","nKeys","validate","valid","prevTime","currTime","isNaN","ArrayBuffer","isView","DataView","optimize","smoothInterpolation","lastIndex","writeIndex","keep","time","offsetP","offsetN","readOffset","writeOffset","TypedKeyframeTrack","BooleanKeyframeTrack","QuaternionLinearInterpolant","end","QuaternionKeyframeTrack","StringKeyframeTrack","_RESERVED_CHARS_RE","_reservedRe","RegExp","_wordChar","_wordCharOrDot","replace","_trackRe","_supportedObjectNames","PropertyBinding","rootNode","path","parsedPath","parseTrackName","node","findNode","nodeName","getValue","_getValue_unbound","setValue","_setValue_unbound","create","root","isAnimationObjectGroup","Composite","sanitizeNodeName","trackName","matches","results","objectName","objectIndex","propertyName","propertyIndex","lastDot","lastIndexOf","substring","bone","getBoneByName","searchNodeSubtree","childNode","subTreeNode","_getValue_unavailable","_setValue_unavailable","_getValue_direct","buffer","targetObject","_getValue_array","resolvedProperty","_getValue_arrayElement","_getValue_toArray","_setValue_direct","_setValue_direct_setNeedsUpdate","_setValue_direct_setMatrixWorldNeedsUpdate","_setValue_array","dest","_setValue_array_setNeedsUpdate","_setValue_array_setMatrixWorldNeedsUpdate","_setValue_arrayElement","_setValue_arrayElement_setNeedsUpdate","_setValue_arrayElement_setMatrixWorldNeedsUpdate","_setValue_fromArray","_setValue_fromArray_setNeedsUpdate","_setValue_fromArray_setMatrixWorldNeedsUpdate","targetArray","bind","sourceArray","bones","nodeProperty","versioning","Versioning","None","NeedsUpdate","MatrixWorldNeedsUpdate","bindingType","BindingType","Direct","morphAttributes","morphTargetDictionary","ArrayElement","HasFromToArray","EntireArray","GetterByBindingType","SetterByBindingTypeAndVersioning","unbind","targetGroup","optionalParsedPath","_targetGroup","_bindings","subscribe_","firstValidIndex","nCachedObjects_","binding","bindings","__THREE_DEVTOOLS__","CustomEvent","detail","revision","window","__THREE__","BoolArray","byteOffset","idx","fill","ByteStringArray","_data","chars","view","TextDecoder","decode","_encode","TextEncoder","encode","encoded","UnicodeStringArray","str","int32","out","codePointAt","fromCodePoint","subarray","json_decode_object","bytes","byteswap_inplace","bytes_per_element","numFlips","endByteIndex","CONSTRUCTORS","int8","int16","int64","globalThis","BigInt64Array","uint8","uint16","uint32","uint64","BigUint64Array","float32","float64","bool","V2_STRING_REGEX","get_ctr","data_type","match","kind","ctr","get_strides","row_major_stride","col_major_stride","ndim","create_chunk_key_encoder","configuration","chunk_coords","join","separator","get_array_order","codecs","maybe_transpose_codec","find","endian_regex","is_sharding_codec","codec","ensure_correct_scalar","fill_value","BigInt","proxy","arr","Proxy","prop","TransposeCodec","fromConfig","row_major_strides","every","get_order","chunk","empty_like","n_dims","src_data","out_data","src_idx","out_idx","dim","convert_array_order","LITTLE_ENDIAN_OS","system_is_little_endian","TypedArray","EndianCodec","endian","Crc32cCodec","_","VLenUTF8","_chunk","decoder","getUint32","pos","item_length","registry","then","default","create_codec_pipeline","chunk_metadata","load_codecs","array_to_array","array_to_bytes","bytes_to_bytes","async","chunk_meta","promises","Codec","MAX_BIG_UINT","create_sharded_chunk_getter","location","shard_shape","encode_shard_key","sharding_config","store","getRange","get_range","index_shape","chunk_shape","index_codec","index_codecs","chunk_coord","shard_coord","shard_path","resolve","checksum_size","index_size","reduce","suffixLength","linear_offset","acc","sel","Location","URL","endsWith","pathname","attrs","attributes","CONTEXT_MARKER","shared_context","encode_chunk_key","chunk_key_encoding","native_order","get_chunk_bytes","chunk_grid","chunk_key","chunk_path","create_context","chunks","dtype","getChunk","maybe_bytes","is","query","is_boolean","is_string","is_bigint","is_object","is_dtype","open_v2","loc","meta_bytes","load_attrs","open_array_v2","open_group_v2","catch","err","rest","coerce_dtype","filters","compressor","zarr_format","node_type","dimension_separator","v2_to_v3_array_metadata","_meta","v2_to_v3_group_metadata","open_v3","meta_doc","_open_v3","start","stop","indices","step_is_negative","lower","upper","slice_indices","v3","IndexError","msg","IntDimIndexer","dim_sel","dim_len","dim_chunk_len","nitems","err_boundscheck","normalize_integer_selection","dim_chunk_ix","dim_offset","dim_chunk_sel","SliceDimIndexer","nchunks","err_negative_step","dim_chunk_ix_from","dim_chunk_ix_to","range","dim_limit","dim_out_offset","dim_chunk_sel_start","remainder","dim_chunk_sel_stop","dim_out_sel","BasicIndexer","dim_indexers","selection","normalized","err_too_many_indices","check_selection_length","normalize_selection","filter","ixr","sixr","dim_projections","iterables","iterators","it","some","done","product","object_array_proxy","lengthArg","Reflect","string_array_proxy","StringArrayConstructor","compat","setter","prepare","set_scalar","cast_scalar","set_from_chunk","indices_len","out_selection","slices","curr_stride","projections","proj","projs","dstride","dstrides","sstride","sstrides","sfrom","sstep","fetch_range","opts","headers","Range","fetch","base","resolved","search","handle_response","response","status","arrayBuffer","statusText","overrides","useSuffixRequest","href","init","suffix_length","use_suffix_request","method","ok","content_length","fetch_suffix","DEFAULT_REQUEST_CANCEL_REASON","RequestQueue","maxActiveRequests","maxLowPriorityRequests","allRequests","activeRequests","Set","queue","queueLowPriority","registerRequest","requestAction","promiseResolve","promiseReject","promise","Promise","reject","requestItem","action","addRequestToQueue","lowPriority","timeoutId","clearTimeout","dequeue","addRequest","delayMs","lowPriorityIndex","setTimeout","addRequests","requests","item","numRequests","requestKey","cancelRequest","cancelReason","queueIndex","cancelAllRequests","hasRequest","requestRunning","SubscribableRequestQueue","nextSubscriberId","subscribers","resolveAll","subscriberId","rejectAll","reason","addSubscriber","subscriber","existingRequest","rejectSubscription","subscriptions","findIndex","rejecters","removeSubscriber","hasSubscriber","isSubscribed","Histogram","dataMinBin","dataMaxBin","maxBin","bins","binSize","hinfo","calculateHistogram","pixelCount","findBin","dataValue","dataMin","numBins","binIndex","findBinOfValue","getDataMin","getDataMax","getMin","getMax","getNumBins","getBin","getBinRange","findBinOfPercentile","pct","limit","findBestFitBins","hmin","findAutoIJBins","pixcount","threshold","hmax","findAutoMinMax","th","defaultColors","myrand","imul","getColorByChannelIndex","hh","hsv","HSVtoRGB","val","cmin","cmax","xmin","xmax","remapDomain","valueMin","valueMax","oldMin","oldMax","newMin","newMax","remapDomainForCP","LUT_ENTRIES","LUT_ARRAY_LENGTH","controlPointToRGBA","controlPoint","opacity","createFullRangeControlPoints","opacityMin","opacityMax","Lut","lut","controlPoints","createFullRange","createFromMinMax","createFromControlPoints","startVal","endVal","createFromWindowLevel","wnd","lvl","sort","rgba","c0","color0","arrayFromControlPoints","createFromEqHistogram","histogram","lutControlPoints","slope","lastSlope","lastOpacity","createLabelColors","lastr","lastg","lastb","lasta","ibin","rgb","remapDomains","newLut","iOld","i0","remapLut","nudgeEndPoints","newControlPoints","oldFirstX","oldLastX","cp","newCP","second","secondLast","Infinity","nudgeRemappedEndControlPoints","remapControlPoints","ARRAY_CONSTRUCTORS","Channel","loaded","imgData","rawMin","rawMax","dataTexture","lutTexture","volumeData","dims","colorPalette","colorPaletteAlpha","combineLuts","rgbColor","ret","setRawDataRange","getHistogram","getIntensity","normalizeRaw","getIntensityFromAtlas","numXtiles","tilex","tiley","rebuildDataTexture","dataType","setFromAtlas","bitsArray","subregionSize","unpackFromAtlas","volimgdata","ctor","atlasrow","tileoffset","tilerowoffset","destOffset","setFromVolumeData","packToAtlas","log","sourceOffset","setLut","setColorPalette","palette","setColorPaletteAlpha","volumeSize","volumeDims","CImageInfo","imageInfo","atlasTileDims","subregionOffset","combinedNumChannels","channelNames","channelColors","multiscaleLevel","multiscaleLevelDims","spacing","spaceUnit","timeUnit","transform","translation","currentLevelDims","numChannels","originalSize","physicalPixelSize","spatialUnit","numMultiscaleLevels","MAX_ATLAS_EDGE","UNIT_SYMBOLS","angstrom","day","foot","hour","inch","meter","micron","mile","minute","parsec","yard","SI_UNITS","SI_PREFIX_ABBVS","micro","deca","unitNameToSymbol","unitName","prefixedSIUnit","siUnit","toUpperCase","computePackedAtlasDims","tw","nextrows","nextcols","ratio","nrows","ncols","doesSpatialDimensionFitInAtlas","spatialDimZYX","maxAtlasEdge","maxCeil","pickLevelToLoadUnscaled","loadSpec","spatialDimsZYX","useExplicitLevel","levelToLoad","estimateLevelForAtlas","scaleLevelBias","smallestDims","pickLevelToLoad","subregion","scaleDims","scaleMultipleDimsToSubregion","convertSubregionToPixels","region","composeSubregion","container","Volume","LoadSpec","loader","channels","_val","loadSpecRequired","imageMetadata","normRegionSize","normRegionOffset","physicalSize","physicalScale","normPhysicalSize","tickMarkPhysicalLength","setVoxelSize","channelColorsDefault","physicalUnitSymbol","volumeDataObservers","setUnloaded","forEach","isLoaded","updateDimensions","mustLoadNewData","mayLoadNewScaleLevel","updateRequiredData","required","onChannelLoaded","shouldReload","loadScaleLevelDims","dimsZYX","loadNewData","loadDims","observer","onVolumeLoadError","loadVolumeData","log10","setUnitSymbol","symbol","getContentCenter","cleanup","getChannel","channelIndex","batch","channelLoadCallback","onVolumeData","setChannelDataFromAtlas","atlasdata","atlaswidth","atlasheight","setChannelDataFromVolume","appendEmptyChannel","chname","chcolor","onVolumeChannelAdded","getRotation","getTranslation","voxelsToWorldSpace","xyz","addVolumeDataObserver","o","removeVolumeDataObserver","removeAllVolumeDataObservers","ThreadableVolumeLoader","setPrefetchPriority","_directions","syncMultichannelLoading","_sync","updateFetchOptions","_options","createVolume","adjustedLoadSpec","createImageInfo","vol","rawImageInfo","obj","hasOwnProperty","buildDefaultMetadata","volume","loadSpecOverride","spec","loadRawChannelData","channelIndices","dtypes","dataArrays","ranges","atlasDims","allEqual","pushN","directionToIndex","absDir","updateMinMax","minmax","ChunkPrefetchIterator","tzyxMaxPrefetchOffset","tczyxChunksPerSource","priorityDirections","onlyPriorityDirections","extrema","directionStates","priorityDirectionStates","direction","flat","dimension","tczyxIndex","endsPerSource","chunkDims","sourceEnd","directionState","iterateDirections","directions","offsetDir","newChunk","baseStore","_key","_value","getAndCache","cacheKey","reportKey","keyPrefix","fullKey","cacheResult","isPrefetch","VolumeLoadErrorType","VolumeLoadError","UNKNOWN","wrapVolumeLoadError","ignore","cause","getDimensionCount","orderByTCZYX","valsDimension","orderTCZYX","defaultValue","INVALID_METADATA","getScale","dataset","transforms","coordinateTransformations","scaleTransform","compareZarrArraySize","aArr","aTCZYX","bArr","bTCZYX","diffZ","diffY","diffX","aboutEquals","scaleTransformsAreEqual","aSrc","aLevel","bSrc","bLevel","aScale","multiscaleMetadata","datasets","axesTCZYX","bScale","isObjectWithProp","assertMetadataHasProp","assertPropIsArray","CHUNK_REQUEST_CANCEL_REASON","DEFAULT_FETCH_OPTIONS","maxPrefetchDistance","maxPrefetchChunks","OMEZarrLoader","syncChannels","sources","requestQueue","fetchOptions","createLoader","urls","scenes","concurrencyLimit","prefetchConcurrencyLimit","urlsArr","scenesArr","sourceProms","group","NOT_FOUND","scene","multiscales","multiscaleIdx","multiscaleMeta","multiscaleName","validateOMEZarrMetadata","omero","lvlProms","scaleLevels","all","omeroMetadata","axisNames","axisIdx","noXAxis","remapAxesToTCZYX","channelOffset","channelCount","matchedLevels","matchedMetas","scaleIndexes","smallestIdx","smallestSrc","smallestArr","currentIdx","currentSrc","currentArr","ordering","INVALID_MULTI_SOURCE_ZARR","largestT","currentT","matchedScaleLevel","srcIdx","matchSourceScaleLevels","priorityDirs","getUnitSymbols","xi","spaceUnitName","unit","spaceUnitSymbol","ti","timeUnitName","getLevelShapesZYX","level","orderByDimension","valsTCZYX","sourceIdx","specLen","matchChannelToSource","absoluteChannelIndex","lastSrcIdx","lastSrc","lastSrcNumChannels","maxChannelIndex","firstGreaterIdx","sourceIndex","channelIndexInSource","sync","maxExtent","regionSize","regionArr","source0","hasT","hasZ","shapeLv","sourceLast","cLast","lastHasC","tindex","pxSizeLv","channelNamesMap","flatMap","sourceChannelNames","label","getSourceChannelNames","channelName","numMatchingChannels","alldims","imgdata","fullExtentLoadSpec","prefetchChunk","scaleLevel","coords","LOAD_DATA_FAILED","beginPrefetch","chunkCoords","numDims","coordsInDimensionOrder","split","sourceCoords","chunkDimsTCZYX","chunkDimsUnordered","prefetchIterator","prefetchCount","sourceScaleLevel","prefetchSubscriber","updateImageInfoForLoad","array0Shape","regionPx","onUpdateMetadata","onData","updatedImageInfo","channelIndexes","resultChannelIndices","resultChannelData","resultChannelDtype","resultChannelRanges","channelPromises","sourceCh","ch","unorderedSpec","sliceSpec","indexer","create_queue","fn","onIdle","unwrap","reportKeyBase","converted","channelData","f32","convertChannel","loadSubscriber","TimeUnit","MILLISECOND","SECOND","MINUTE","HOUR","DAY","getDataRange","rescalePixelSize","pixel_size_x","tile_width","pixel_size_y","tile_height","pixel_size_z","convertImageInfo","px","py","pz","tr","cols","rows","tiles","channel_names","channel_colors","time_scale","pixel_size_unit","time_unit","originalVolumeSize","originalPhysicalPixelSize","JsonImageInfoLoader","jsonInfo","getJsonImageInfo","cachedInfo","requestedChannels","urlPrefix","volDims","computeAtlasSize","loadVolumeAtlasData","imageArray","imagePromises","cacheHit","chindex","mode","blob","bitmap","createImageBitmap","ctx","OffscreenCanvas","globalCompositeOperation","globalAlpha","iData","channelsBits","channelRange","sizeZ","sizeX","sizeY","sizeC","RawArrayLoader","rawData","rawDataInfo","_loadSpec","volSizeBytes","OMEDims","sizex","sizey","sizez","sizec","sizet","pixeltype","dimensionorder","pixelsizex","pixelsizey","pixelsizez","channelnames","getDtype","omepixeltype","float","getAttributeOrError","el","attr","TiffLoader","loadOmeDims","tiff","allowFullFile","image0El","xml","parser","DOMParser","parseFromString","getElementsByTagName","getOME","getImage","getFileDirectory","ImageDescription","imageEl","pixelsEl","channelsEls","getOMEDims","targetSize","tilesizex","tilesizey","_onUpdateMetadata","channelProms","thisChannelProm","params","dimensionOrder","bytesPerSample","worker","Worker","onmessage","isError","terminate","postMessage","VolumeFileFormat","pathToFileType","TIFF","ZARR","subscribableQueue","WorkerMsgType","WorkerResponseResult","WorkerEventType","rebuildLoadSpec","initialized","copyOnLoad","messageHandlers","INIT","maxCacheSize","CREATE_LOADER","pathString","fileType","DATA","rawArrayOptions","createVolumeLoader","CREATE_VOLUME","LOAD_DIMS","LOAD_VOLUME_DATA","loaderId","loadId","responseResult","EVENT","eventType","METADATA_UPDATE","self","CHANNEL_LOAD","SET_PREFETCH_PRIORITY_DIRECTIONS","SYNCHRONIZE_MULTICHANNEL_LOADING","UPDATE_FETCH_OPTIONS","msgId","payload","SUCCESS","ERROR"],"sourceRoot":""}